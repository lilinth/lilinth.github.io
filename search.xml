<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RTC 晶振与温度的关系</title>
      <link href="/2025/07/30/RTC_Crystal/"/>
      <url>/2025/07/30/RTC_Crystal/</url>
      
        <content type="html"><![CDATA[<h1 id="RTC-晶振与温度的关系"><a href="#RTC-晶振与温度的关系" class="headerlink" title="RTC 晶振与温度的关系"></a>RTC 晶振与温度的关系</h1><h2 id="✅-1-晶振基本特性（以-FC-135R-为例）"><a href="#✅-1-晶振基本特性（以-FC-135R-为例）" class="headerlink" title="✅ 1. 晶振基本特性（以 FC-135R 为例）"></a>✅ 1. 晶振基本特性（以 FC-135R 为例）</h2><table><thead><tr><th>参数项</th><th>数值</th></tr></thead><tbody><tr><td>晶体频率</td><td>32.768 kHz（RTC常用）</td></tr><tr><td>标准频差容差</td><td>±20 ppm（在 25 °C ±5 °C）</td></tr><tr><td>温度特性曲线</td><td>抛物线型偏移</td></tr><tr><td>周转温度</td><td>25 °C（频率误差最小点）</td></tr><tr><td>温度系数 B</td><td>−0.04 ppm&#x2F;°C²（每偏离1°C平方）</td></tr></tbody></table><hr><h2 id="🌡️-2-温度对频率的影响（抛物线规律）"><a href="#🌡️-2-温度对频率的影响（抛物线规律）" class="headerlink" title="🌡️ 2. 温度对频率的影响（抛物线规律）"></a>🌡️ 2. 温度对频率的影响（抛物线规律）</h2><ul><li><p>晶振偏差计算公式：</p><p>$$<br>\Delta f &#x3D; B \times (T - T_0)^2<br>$$</p><ul><li>$T_0 &#x3D; 25°C$，为周转点；</li><li>B &#x3D; −0.04 ppm&#x2F;°C²；</li></ul></li><li><p>举例：</p><ul><li><p>若温度为 50°C，ΔT&#x3D;25°C：</p><p>$$<br>\Delta f &#x3D; -0.04 × 25² &#x3D; -25 ppm<br>$$</p><p>对应每天慢约 2.16 秒。</p></li></ul></li></ul><hr><h2 id="⏱-3-时间误差与-ppm-对应关系"><a href="#⏱-3-时间误差与-ppm-对应关系" class="headerlink" title="⏱ 3. 时间误差与 ppm 对应关系"></a>⏱ 3. 时间误差与 ppm 对应关系</h2><table><thead><tr><th>频率偏移 (ppm)</th><th>每天时间偏差</th></tr></thead><tbody><tr><td>1 ppm</td><td>0.0864 秒</td></tr><tr><td>10 ppm</td><td>0.864 秒</td></tr><tr><td>20 ppm</td><td>1.728 秒</td></tr><tr><td>50 ppm</td><td>4.32 秒</td></tr></tbody></table><hr><h2 id="📉-4-反推温度"><a href="#📉-4-反推温度" class="headerlink" title="📉 4. 反推温度"></a>📉 4. 反推温度</h2><p>假设系统一天 <strong>慢了 5 秒</strong>：</p><ul><li><p>对应频率偏移：</p><p>$$<br>5 &#x2F; 86400 ≈ 57.9 ppm<br>$$</p></li><li><p>代入公式反推温差：</p><p>$$<br>\Delta T ≈ \sqrt{57.9 &#x2F; 0.04} ≈ 38°C<br>$$</p></li><li><p>得到环境温度：约为 <strong>63 °C</strong>（若高温导致变慢）</p></li></ul><hr><h2 id="🎯-5-若要求误差-≤-2-秒-天（≈-23-1-ppm）"><a href="#🎯-5-若要求误差-≤-2-秒-天（≈-23-1-ppm）" class="headerlink" title="🎯 5. 若要求误差 ≤ 2 秒&#x2F;天（≈ 23.1 ppm）"></a>🎯 5. 若要求误差 ≤ 2 秒&#x2F;天（≈ 23.1 ppm）</h2><p>解：</p><p>$$<br>|T - 25| \le \sqrt{23.1 &#x2F; 0.04} ≈ 24°C<br>$$</p><p>即温度需维持在：</p><ul><li><strong>1 °C ≤ 温度 ≤ 49 °C</strong><br>否则频率偏差会超过 ±2 秒&#x2F;天。</li></ul><hr><h2 id="⚠️-6-附加误差来源"><a href="#⚠️-6-附加误差来源" class="headerlink" title="⚠️ 6. 附加误差来源"></a>⚠️ 6. 附加误差来源</h2><table><thead><tr><th>来源</th><th>说明</th></tr></thead><tbody><tr><td>初始频差</td><td>±20 ppm 出厂误差（最大±1.7秒）</td></tr><tr><td>老化</td><td>约 ±3 ppm&#x2F;年（约 ±0.26 秒&#x2F;天）</td></tr><tr><td>负载电容影响</td><td>板载设计差异可能造成额外 ppm 偏移</td></tr><tr><td>温度突变</td><td>快速加热&#x2F;冷却引起瞬时偏移</td></tr></tbody></table><hr><h2 id="✅-7-实际情况"><a href="#✅-7-实际情况" class="headerlink" title="✅ 7. 实际情况"></a>✅ 7. 实际情况</h2><ul><li><p><strong>如只靠晶振运行</strong>，维持温度在 <strong>1–49 °C</strong> 可控制在 ±2秒&#x2F;天；</p></li><li><p><strong>若应用对时间精度要求更高</strong>，可以：</p><ul><li>使用 <strong>温补晶振（TCXO）</strong> 或更高精度 RTC；</li><li>启用 <strong>NTP &#x2F; PTP &#x2F; GPS 时间同步机制</strong>；</li><li>添加 <strong>温度监测与补偿校准</strong>。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HAProxy 转发 Windows RDP</title>
      <link href="/2025/07/30/haproxy_rdp_configuration/"/>
      <url>/2025/07/30/haproxy_rdp_configuration/</url>
      
        <content type="html"><![CDATA[<h1 id="HAProxy-转发-Windows-RDP"><a href="#HAProxy-转发-Windows-RDP" class="headerlink" title="HAProxy 转发 Windows RDP"></a>HAProxy 转发 Windows RDP</h1><p>部署 HAProxy 实现 Windows RDP 的 TCP 转发、会话粘性及健康检查。</p><hr><h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><ul><li><strong>操作系统</strong>：Linux（Debian &#x2F; Ubuntu &#x2F; CentOS 等）  </li><li><strong>安装 HAProxy</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment"># Debian / Ubuntu</span></span><br><span class="line">  sudo apt update</span><br><span class="line">  sudo apt install haproxy</span><br><span class="line"></span><br><span class="line">  <span class="comment"># CentOS</span></span><br><span class="line">  sudo yum install haproxy</span><br><span class="line">  ````</span><br><span class="line"></span><br><span class="line">* **后端 Windows 系统**：</span><br><span class="line"></span><br><span class="line">  * 启用 RDP（TCP 端口 3389），并确保防火墙已开放。</span><br><span class="line">* **网络连通性测试**：</span><br><span class="line">  HAProxy 主机能访问后端所有 RDP 服务器的 3389 端口。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">## 二、工作原理概述</span></span><br><span class="line"></span><br><span class="line">* RDP 基于 TCP 协议，不属于 HTTP，因此只能使用 `mode tcp` 模式，否则连接失败 。</span><br><span class="line">* Microsoft 客户端登录后会附带 RDP cookie（mstshash），HAProxy 可通过该 cookie 实现会话粘滞性分发。</span><br><span class="line">* 使用 `tcp-request inspect-delay` 等待初始数据包，提取 RDP cookie 进行粘滞判断。</span><br><span class="line">* 利用 `stick-table` 存储客户端与服务器映射关系，结合 `persist rdp-cookie` 与 `balance leastconn` 实现负载均衡及粘滞性。</span><br><span class="line">* 通过 `tcp-check connect port 3389` 对后端进行健康检查。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">## 三、HAProxy 配置示例</span></span><br><span class="line"></span><br><span class="line">```cfg</span><br><span class="line">global</span><br><span class="line"><span class="built_in">log</span> /dev/loglocal0</span><br><span class="line"><span class="built_in">log</span> /dev/loglocal1 notice</span><br><span class="line"><span class="built_in">chroot</span> /var/lib/haproxy</span><br><span class="line">stats socket /run/haproxy/admin.sock mode 660 level admin</span><br><span class="line">stats <span class="built_in">timeout</span> 30s</span><br><span class="line">user haproxy</span><br><span class="line">group haproxy</span><br><span class="line">daemon</span><br><span class="line"></span><br><span class="line"><span class="comment"># Default SSL material locations</span></span><br><span class="line">ca-base /etc/ssl/certs</span><br><span class="line">crt-base /etc/ssl/private</span><br><span class="line"></span><br><span class="line"><span class="comment"># See: https://ssl-config.mozilla.org/#  server=haproxy&amp;  server-version=2.0.3&amp;config=intermediate</span></span><br><span class="line">        ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384</span><br><span class="line">        ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256</span><br><span class="line">        ssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets</span><br><span class="line"></span><br><span class="line">tune.ssl.default-dh-param 2048</span><br><span class="line">tune.bufsize 16384</span><br><span class="line">tune.maxaccept 2000</span><br><span class="line">tune.maxpollevents 200</span><br><span class="line">tune.pipesize 524288</span><br><span class="line">tune.ssl.cachesize 1000000</span><br><span class="line">tune.ssl.maxrecord 32768</span><br><span class="line">tune.ssl.default-dh-param 2048</span><br><span class="line">tune.ssl.cachesize 1000000</span><br><span class="line">tune.ssl.maxrecord 32768</span><br><span class="line">tune.maxaccept 2000</span><br><span class="line">tune.maxpollevents 200</span><br><span class="line">tune.pipesize 524288</span><br><span class="line">tune.ssl.cachesize 1000000</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line"><span class="built_in">log</span>global</span><br><span class="line">modehttp</span><br><span class="line">optionhttplog</span><br><span class="line">optiondontlognull</span><br><span class="line">        <span class="built_in">timeout</span> connect 5000</span><br><span class="line">        <span class="built_in">timeout</span> client  50000</span><br><span class="line">        <span class="built_in">timeout</span>   server  50000</span><br><span class="line">errorfile 400 /etc/haproxy/errors/400.http</span><br><span class="line">errorfile 403 /etc/haproxy/errors/403.http</span><br><span class="line">errorfile 408 /etc/haproxy/errors/408.http</span><br><span class="line">errorfile 500 /etc/haproxy/errors/500.http</span><br><span class="line">errorfile 502 /etc/haproxy/errors/502.http</span><br><span class="line">errorfile 503 /etc/haproxy/errors/503.http</span><br><span class="line">errorfile 504 /etc/haproxy/errors/504.http</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">frontend rdp_frontend</span><br><span class="line"></span><br><span class="line">  mode tcp</span><br><span class="line">  <span class="built_in">timeout</span> client 1h</span><br><span class="line">  <span class="built_in">log</span> global</span><br><span class="line">  option tcplog</span><br><span class="line">  tcp-request inspect-delay 5s</span><br><span class="line">  tcp-request content accept <span class="keyword">if</span> &#123; req_ssl_hello_type 0 &#125;</span><br><span class="line">  tcp-request content accept <span class="keyword">if</span> &#123; req_rdp_cookie_cnt gt 0 &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">bind</span> *:59001-59002</span><br><span class="line">  option tcplog</span><br><span class="line"></span><br><span class="line">  use_backend rdp_1 <span class="keyword">if</span> &#123; dst_port 59001 &#125;</span><br><span class="line">  use_backend rdp_2 <span class="keyword">if</span> &#123; dst_port 59002 &#125;</span><br><span class="line">  </span><br><span class="line">backend rdp_1</span><br><span class="line">  mode tcp</span><br><span class="line">  balance leastconn</span><br><span class="line">  persist rdp-cookie</span><br><span class="line">  <span class="built_in">timeout</span> connect 4s</span><br><span class="line">  <span class="built_in">timeout</span> server 1h</span><br><span class="line">  <span class="built_in">log</span> global</span><br><span class="line">  option tcplog</span><br><span class="line">  option tcp-check</span><br><span class="line">  option tcpka</span><br><span class="line">  tcp-check connect port 3389</span><br><span class="line">  stick-table <span class="built_in">type</span> string size 10k expire 12h</span><br><span class="line">  stick on rdp_cookie(mstshash) upper</span><br><span class="line">  server rdp1 10.0.0.1:3389 check verify none</span><br><span class="line">backend rdp_2</span><br><span class="line">  mode tcp</span><br><span class="line">  balance leastconn</span><br><span class="line">  persist rdp-cookie</span><br><span class="line">  <span class="built_in">timeout</span> connect 4s</span><br><span class="line">  <span class="built_in">timeout</span> server 1h</span><br><span class="line">  <span class="built_in">log</span> global</span><br><span class="line">  option tcplog</span><br><span class="line">  option tcp-check</span><br><span class="line">  option tcpka</span><br><span class="line">  tcp-check connect port 3389</span><br><span class="line">  stick-table <span class="built_in">type</span> string size 10k expire 12h</span><br><span class="line">  stick on rdp_cookie(mstshash) upper</span><br><span class="line">  server rdp2 10.0.0.2:3389 check verify none</span><br></pre></td></tr></table></figure></li></ul><h3 id="🔑-关键解释"><a href="#🔑-关键解释" class="headerlink" title="🔑 关键解释"></a>🔑 关键解释</h3><ul><li>使用 <code>mode tcp</code> 转发原始 RDP 流量，避免 HTTP 层干扰。</li><li><code>timeout client/server = 1h</code> 适应长时间空闲 RDP 会话。</li><li><code>tcp-request inspect-delay 5s</code> 确保客户端发送 RDP cookie 后进行粘滞决策。</li><li><code>stick-table</code> + <code>persist rdp-cookie</code> + <code>balance leastconn</code> 实现既负载均衡又粘性粘滞效果。如用户名重复（仅有限字符识别），可能粘附不同用户，建议使用 <code>user@domain</code> 格式登录保证唯一性。</li><li>启用 <code>tcp-check connect port 3389</code> 进行后端健康探测，结合 <code>inter/rise/fall</code> 参数可快速响应服务状态变化。</li></ul><hr><h2 id="四、部署与校验步骤"><a href="#四、部署与校验步骤" class="headerlink" title="四、部署与校验步骤"></a>四、部署与校验步骤</h2><ol><li><p><strong>验证配置语法</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haproxy -c -f /etc/haproxy/haproxy.cfg</span><br></pre></td></tr></table></figure></li><li><p><strong>启动或重载服务</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> haproxy</span><br><span class="line">systemctl restart haproxy</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="五、常见问题"><a href="#五、常见问题" class="headerlink" title="五、常见问题"></a>五、常见问题</h2><table><thead><tr><th>问题 &#x2F; 场景</th><th>解决方案与建议</th></tr></thead><tbody><tr><td>客户端无 cookie</td><td>连接将随机分配，可能多次连接同一后端，建议为无用户场景配置默认后端。</td></tr><tr><td>用户名重复</td><td>cookie 基于用户名前 9 字符生成，避免不同用户重复影响粘性；推荐使用完整邮箱格式。</td></tr><tr><td>多 HAProxy 节点</td><td>可使用 <code>peers</code> 同步 stick-table，实现多节点间粘滞表共享。</td></tr><tr><td>重载不中断会话</td><td>使用 reload 而非 restart，老进程接管现有链接，匹配 stick-table 数据迁移。</td></tr></tbody></table><hr><h2 id="六、整体流程概览"><a href="#六、整体流程概览" class="headerlink" title="六、整体流程概览"></a>六、整体流程概览</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 系统安装 HAProxy</span><br><span class="line">2. 编辑 haproxy.cfg，配置 global / defaults / frontend / backend</span><br><span class="line">3. 配置粘滞、健康检查、负载均衡策略</span><br><span class="line">4. 校验配置并重载服务</span><br><span class="line">5. 测试连接、粘性、故障切换行为</span><br><span class="line">6. 查看映射表，调试用户对应关系</span><br><span class="line">7. 根据部署需求调整（用户名策略、多节点 peering 等）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InfiniBand（IB）网卡测试与性能调优</title>
      <link href="/2025/07/30/infiniband_card_test/"/>
      <url>/2025/07/30/infiniband_card_test/</url>
      
        <content type="html"><![CDATA[<h1 id="InfiniBand（IB）网卡测试与性能调优"><a href="#InfiniBand（IB）网卡测试与性能调优" class="headerlink" title="InfiniBand（IB）网卡测试与性能调优"></a>InfiniBand（IB）网卡测试与性能调优</h1><h2 id="🔍-一、设备检测与初始连通"><a href="#🔍-一、设备检测与初始连通" class="headerlink" title="🔍 一、设备检测与初始连通"></a>🔍 一、设备检测与初始连通</h2><h3 id="1-查看设备状态"><a href="#1-查看设备状态" class="headerlink" title="1. 查看设备状态"></a>1. 查看设备状态</h3><ul><li>使用 <code>ibstat</code> 检查端口是否为 LinkUp、链路速率、LID、状态等</li><li>使用 <code>ibv_devinfo</code> 查看 HCA 的 MTU、GUID、设备能力等详细信息</li></ul><h3 id="2-启动子网管理器（必要时）"><a href="#2-启动子网管理器（必要时）" class="headerlink" title="2. 启动子网管理器（必要时）"></a>2. 启动子网管理器（必要时）</h3><ul><li>启动命令：<code>sudo systemctl start opensm</code> 或 <code>sudo /etc/init.d/opensmd start</code></li><li>若服务未运行，可能导致节点互通失败或性能异常</li></ul><h3 id="3-配置-IPoIB-接口（用于-IP-测试模式）"><a href="#3-配置-IPoIB-接口（用于-IP-测试模式）" class="headerlink" title="3. 配置 IPoIB 接口（用于 IP 测试模式）"></a>3. 配置 IPoIB 接口（用于 IP 测试模式）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe ib_ipoib</span><br><span class="line"><span class="built_in">echo</span> connected | sudo <span class="built_in">tee</span> /sys/class/net/ib0/mode</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> ib0 mtu 65520 up</span><br><span class="line">sudo ip addr add 10.0.0.1/24 dev ib0</span><br></pre></td></tr></table></figure><p>然后使用 <code>ping</code> 测试连通性，或用 <code>ibdev2netdev</code> 确认 ib0 已映射到物理设备</p><hr><h2 id="🧪-二、连通性测试：RDMA-Ping"><a href="#🧪-二、连通性测试：RDMA-Ping" class="headerlink" title="🧪 二、连通性测试：RDMA Ping"></a>🧪 二、连通性测试：RDMA Ping</h2><ul><li><p>安装 <code>infiniband-diags</code> 包</p></li><li><p>启动服务端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ibv_devinfo</span><br><span class="line">ibstat</span><br><span class="line">ibping -S</span><br></pre></td></tr></table></figure></li><li><p>客户端运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibping -C -P &lt;port&gt; &lt;server-LID&gt;</span><br></pre></td></tr></table></figure></li></ul><p>用于验证 RDMA 通道是否可达，以及每跳最基础的往返延迟</p><hr><h2 id="📈-三、带宽与延迟性能测试"><a href="#📈-三、带宽与延迟性能测试" class="headerlink" title="📈 三、带宽与延迟性能测试"></a>📈 三、带宽与延迟性能测试</h2><h3 id="A-使用-Perftest-套件（推荐此方法全面测试-RDMA-性能）"><a href="#A-使用-Perftest-套件（推荐此方法全面测试-RDMA-性能）" class="headerlink" title="A. 使用 Perftest 套件（推荐此方法全面测试 RDMA 性能）"></a>A. 使用 <strong>Perftest 套件</strong>（推荐此方法全面测试 RDMA 性能）</h3><p>Perftest 包括多个工具：</p><ul><li><code>ib_send_bw</code>, <code>ib_send_lat</code>（Send&#x2F;Recv）</li><li><code>ib_read_bw</code>, <code>ib_read_lat</code>（RDMA Read）</li><li><code>ib_write_bw</code>, <code>ib_write_lat</code>（RDMA Write）</li><li><code>ib_atomic_bw</code>, <code>ib_atomic_lat</code>（Atomic 操作）</li><li><code>raw_ethernet_bw/lat</code>（以太网测试，通过 OFED 支持）</li></ul><h4 id="示例命令："><a href="#示例命令：" class="headerlink" title="示例命令："></a>示例命令：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line">ib_write_bw -a -d mlx5_0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端</span></span><br><span class="line">ib_write_bw -a -d mlx5_0 10.0.0.2</span><br></pre></td></tr></table></figure><p>结果包含带宽 (MB&#x2F;s 或 Gbps)、消息率、延迟统计等，多个消息大小与测试时间可调整参数如 <code>-m</code>, <code>-t</code> </p><h3 id="B-IPoIB-模式下的带宽-延迟测试"><a href="#B-IPoIB-模式下的带宽-延迟测试" class="headerlink" title="B. IPoIB 模式下的带宽&#x2F;延迟测试"></a>B. IPoIB 模式下的带宽&#x2F;延迟测试</h3><p>可使用 <code>iperf3</code> 或 <code>qperf</code> 测试 IP over InfiniBand 接口性能。</p><ul><li>qperf 能报告带宽、延迟、CPU 使用率等</li><li>示例：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在服务器端</span></span><br><span class="line">qperf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在客户端</span></span><br><span class="line">qperf -v -i mlx4_0:1 192.0.2.1 conf</span><br><span class="line">qperf 192.0.2.1 tcp_bw udp_bw tcp_lat</span><br></pre></td></tr></table></figure><hr><h2 id="🚀-四、GPUDirect-RDMA-与-MPI-测试"><a href="#🚀-四、GPUDirect-RDMA-与-MPI-测试" class="headerlink" title="🚀 四、GPUDirect RDMA 与 MPI 测试"></a>🚀 四、GPUDirect RDMA 与 MPI 测试</h2><p>若你使用 NVIDIA GPU 并启用 GPUDirect RDMA，可组合 Perftest 与 MPI benchmark（如 OSU Microbenchmarks）进行测试。</p><ul><li>安装 MVAPICH2‑GDR，可运行 OSU 的 MPI‑CUDA 带宽测试：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mpirun -np 2 host1 host2 \</span><br><span class="line">  -genv MV2_USE_GPUDIRECT=1 \</span><br><span class="line">  /opt/mvapich2/gdr/.../osu_bw -d cuda D D</span><br></pre></td></tr></table></figure><ul><li>注意绑定 GPU 所在 NUMA socket 的 CPU 核心和网卡路径，以优化性能</li></ul><hr><h2 id="🛠️-五、系统调优建议"><a href="#🛠️-五、系统调优建议" class="headerlink" title="🛠️ 五、系统调优建议"></a>🛠️ 五、系统调优建议</h2><h3 id="1-IRQ-与-CPU-亲和绑定"><a href="#1-IRQ-与-CPU-亲和绑定" class="headerlink" title="1. IRQ 与 CPU 亲和绑定"></a>1. IRQ 与 CPU 亲和绑定</h3><ul><li>禁用 <code>irqbalance</code> 服务，避免中断分配到多个 CPU 核心</li><li>把 IB 网卡中断绑定到指定 CPU 上，确保压力不会集中某个核以避免性能瓶颈</li><li>Iperf 或 qperf 也可绑定到特定 CPU&#x2F;core 来同步整体资源分配</li></ul><h3 id="2-NUMA-亲和性配置"><a href="#2-NUMA-亲和性配置" class="headerlink" title="2. NUMA 亲和性配置"></a>2. NUMA 亲和性配置</h3><ul><li>将进程&#x2F;中断与网卡所在 NUMA 节点绑定，提高 LL&#x2F;DRAM 访问效率及吞吐性能</li></ul><h3 id="3-IPoIB-模式切换"><a href="#3-IPoIB-模式切换" class="headerlink" title="3. IPoIB 模式切换"></a>3. IPoIB 模式切换</h3><p>使用 “connected” 模式通常带来更高吞吐和更低延迟，而默认的 datagram 模式性能较差 </p><h3 id="4-软件栈与驱动"><a href="#4-软件栈与驱动" class="headerlink" title="4. 软件栈与驱动"></a>4. 软件栈与驱动</h3><ul><li>安装最新 OFED&#x2F;Mellanox 驱动以获得性能优化与新特性支持</li><li>使用 <code>mlnx_tune</code> 或 Mellanox 提供的系统调优脚本配置最佳设置（MTU、缓冲区、各种系统参数等）</li></ul><hr><h2 id="⚠️-六、排查常见问题"><a href="#⚠️-六、排查常见问题" class="headerlink" title="⚠️ 六、排查常见问题"></a>⚠️ 六、排查常见问题</h2><ul><li><p>若性能远低于硬件规格（例如 40&#x2F;56&#x2F;100 Gbps），请检查：</p><ul><li>链路状态是否为完整带速（LinkUp + 正确速率）</li><li>MTU 是否设置为最高（如 65520）</li><li>是否使用 connected 模式 IPoIB</li><li>CPU 使用率是否太高（结合 <code>top</code>, <code>mpstat</code> 检查）</li><li>中断和进程是否正确绑定至 NUMA node</li><li>是否禁用 irqbalance</li></ul></li><li><p>注意 RDMA scenario 并发冲突问题：当多个应用共用 RDMA 通道（如 MPI + 文件系统），可能造成性能不稳定。可参考 Justitia 等隔离方法改善性能隔离，但一般用于大规模多任务情况</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
            <tag> InfiniBand </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PsExec 访问被拒绝问题排查和解决</title>
      <link href="/2025/07/30/psexec_access_is_denied/"/>
      <url>/2025/07/30/psexec_access_is_denied/</url>
      
        <content type="html"><![CDATA[<h1 id="PsExec-访问被拒绝问题排查和解决"><a href="#PsExec-访问被拒绝问题排查和解决" class="headerlink" title="PsExec 访问被拒绝问题排查和解决"></a>PsExec 访问被拒绝问题排查和解决</h1><h2 id="使用-PsExec（来自-Sysinternals-套件）执行远程命令时，如果没有管理员权限，默认情况下会失败，尤其是当目标命令需要提升权限（如写注册表、操作系统服务、访问系统目录等）时。"><a href="#使用-PsExec（来自-Sysinternals-套件）执行远程命令时，如果没有管理员权限，默认情况下会失败，尤其是当目标命令需要提升权限（如写注册表、操作系统服务、访问系统目录等）时。" class="headerlink" title="使用 PsExec（来自 Sysinternals 套件）执行远程命令时，如果没有管理员权限，默认情况下会失败，尤其是当目标命令需要提升权限（如写注册表、操作系统服务、访问系统目录等）时。"></a>使用 <code>PsExec</code>（来自 Sysinternals 套件）执行远程命令时，如果没有管理员权限，默认情况下会失败，尤其是当目标命令需要提升权限（如写注册表、操作系统服务、访问系统目录等）时。</h2><h2 id="✅-1-PsExec-的权限需求"><a href="#✅-1-PsExec-的权限需求" class="headerlink" title="✅ 1. PsExec 的权限需求"></a>✅ 1. PsExec 的权限需求</h2><p><code>PsExec</code> 默认需要：</p><ul><li><strong>目标机器的管理员账号或管理员组成员</strong></li><li><strong>远程系统的“文件和打印机共享”开启</strong></li><li><strong>远程注册表服务开启</strong></li><li><strong>允许远程执行服务（PsExec 会在目标机器上临时安装并运行 <code>PSEXESVC.exe</code>）</strong></li></ul><p>如果你使用非管理员账号，比如普通用户，则会遇到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access is denied.</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error establishing communication with PsExec service on [目标主机]</span><br></pre></td></tr></table></figure><hr><h2 id="🚫-非管理员账号无法做的事情"><a href="#🚫-非管理员账号无法做的事情" class="headerlink" title="🚫 非管理员账号无法做的事情"></a>🚫 非管理员账号无法做的事情</h2><p>如果你不是管理员用户：</p><ul><li>无法安装 PsExec 的服务到远程主机</li><li>无法通过 SMB 建立 IPC 通道</li><li>无法启动目标服务进程</li></ul><p>所以 PsExec <strong>不支持用非管理员权限在远程主机执行命令</strong>。</p><hr><h2 id="✅-2-排查问题"><a href="#✅-2-排查问题" class="headerlink" title="✅ 2. 排查问题"></a>✅ 2. 排查问题</h2><p>使用管理员账号，但仍然无法通过 <code>PsExec</code> 成功执行远程命令</p><h3 id="1-访问-ADMIN-共享-被拒绝"><a href="#1-访问-ADMIN-共享-被拒绝" class="headerlink" title="1. 访问 ADMIN$ 共享 被拒绝"></a>1. 访问 <strong>ADMIN$ 共享</strong> 被拒绝</h3><ul><li><p><code>PsExec</code> 会先通过 SMB 连接 <code>\\目标主机\ADMIN$</code>（对应远程 Windows 的 <code>C:\Windows</code>）。</p></li><li><p>若该共享被禁用、网络防火墙拦截，或 UAC 远程安全策略干扰，就会拒绝访问。</p></li><li><p><strong>排查步骤</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net use \\目标主机\ipc<span class="variable">$</span> /user:目标主机\AdminUser 密码</span><br><span class="line"><span class="built_in">dir</span> \\目标主机\ADMIN<span class="variable">$</span></span><br></pre></td></tr></table></figure><p>若仍然 <code>Access is denied</code>，说明连接或凭据有问题。</p></li></ul><hr><h3 id="2-UAC-远程凭据过滤（导致管理员权限降级）"><a href="#2-UAC-远程凭据过滤（导致管理员权限降级）" class="headerlink" title="2. UAC 远程凭据过滤（导致管理员权限降级）"></a>2. UAC 远程凭据过滤（导致管理员权限降级）</h3><ul><li><p>Windows 默认会对远程登录的本地 Admin 账号进行权限剥离。</p></li><li><p>可在 <strong>目标机注册表</strong>中设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System</span><br><span class="line">  LocalAccountTokenFilterPolicy = 1 (DWORD)</span><br></pre></td></tr></table></figure></li><li><p>cmd命令:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d <span class="number">1</span> /f</span><br></pre></td></tr></table></figure><p>设置后重启目标 Windows，恢复完整管理员访问。</p></li></ul><hr><h3 id="3-防火墙或共享服务未启用"><a href="#3-防火墙或共享服务未启用" class="headerlink" title="3. 防火墙或共享服务未启用"></a>3. 防火墙或共享服务未启用</h3><ul><li>确保 <strong>目标主机启用了“文件和打印机共享”</strong>，端口 445 可用。</li><li>Windows 防火墙可能阻止 <code>psexecsvc.exe</code> 的执行，检查日志或临时关闭防火墙试试。</li></ul><hr><h3 id="4-提升权限-显示交互界面"><a href="#4-提升权限-显示交互界面" class="headerlink" title="4. 提升权限 &amp; 显示交互界面"></a>4. 提升权限 &amp; 显示交互界面</h3><ul><li><p>在 UAC 环境中（Vista 及以上系统），即便使用管理员账号也需手动提升：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec <span class="literal">-h</span> \\目标主机 cmd.exe</span><br></pre></td></tr></table></figure><p>参数 <code>-h</code> 会运行提升后的令牌。</p></li><li><p>若需在会话桌面交互，可加 <code>-i</code>（带上 <code>-h</code>):</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec <span class="literal">-h</span> <span class="literal">-i</span> \\目标 主机 cmd.exe</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="✅-综合实施步骤"><a href="#✅-综合实施步骤" class="headerlink" title="✅ 综合实施步骤"></a>✅ 综合实施步骤</h3><p>推荐按照以下顺序排查：</p><ol><li><p><strong>确认 Admin$ 共享正常访问</strong>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net use \\远程机\ipc<span class="variable">$</span> /user:远程机\Admin 密码</span><br><span class="line"><span class="built_in">dir</span> \\远程机\ADMIN<span class="variable">$</span></span><br></pre></td></tr></table></figure></li><li><p>若失败，检查 UAC 过滤是否生效，设置上述注册表。</p></li><li><p>确保防火墙、文件共享设置正确。</p></li><li><p>使用提升参数 <code>-h</code> 和&#x2F;或 <code>-i</code>。</p></li><li><p>完整执行示例：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psexec <span class="literal">-h</span> <span class="literal">-i</span> \\远程机 <span class="literal">-u</span> 域\用户名 <span class="literal">-p</span> 密码 cmd.exe</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows WQL 查询</title>
      <link href="/2025/07/30/windows_wql_query/"/>
      <url>/2025/07/30/windows_wql_query/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows-WQL-查询"><a href="#Windows-WQL-查询" class="headerlink" title="Windows WQL 查询"></a>Windows WQL 查询</h1><p>WQL（<strong>WMI Query Language</strong>）是 Windows Management Instrumentation（WMI）使用的一种 SQL 类语言，用于查询系统信息。</p><hr><h3 id="🧾-基本语法"><a href="#🧾-基本语法" class="headerlink" title="🧾 基本语法"></a>🧾 基本语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>属性<span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="operator">&lt;</span>WMI类<span class="operator">&gt;</span> [<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><hr><h3 id="🔍-示例查询"><a href="#🔍-示例查询" class="headerlink" title="🔍 示例查询"></a>🔍 示例查询</h3><h4 id="1-获取系统信息"><a href="#1-获取系统信息" class="headerlink" title="1. 获取系统信息"></a>1. 获取系统信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Win32_OperatingSystem</span><br></pre></td></tr></table></figure><h4 id="2-获取-CPU-信息"><a href="#2-获取-CPU-信息" class="headerlink" title="2. 获取 CPU 信息"></a>2. 获取 CPU 信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Win32_Processor</span><br></pre></td></tr></table></figure><h4 id="3-获取内存条信息"><a href="#3-获取内存条信息" class="headerlink" title="3. 获取内存条信息"></a>3. 获取内存条信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Win32_PhysicalMemory</span><br></pre></td></tr></table></figure><h4 id="4-获取硬盘信息"><a href="#4-获取硬盘信息" class="headerlink" title="4. 获取硬盘信息"></a>4. 获取硬盘信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Win32_DiskDrive</span><br></pre></td></tr></table></figure><h4 id="5-根据条件过滤（如查找-C-盘信息）"><a href="#5-根据条件过滤（如查找-C-盘信息）" class="headerlink" title="5. 根据条件过滤（如查找 C 盘信息）"></a>5. 根据条件过滤（如查找 C 盘信息）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Win32_LogicalDisk <span class="keyword">WHERE</span> DeviceID <span class="operator">=</span> <span class="string">&#x27;C:&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="6-查询特定网络适配器（启用状态）"><a href="#6-查询特定网络适配器（启用状态）" class="headerlink" title="6. 查询特定网络适配器（启用状态）"></a>6. 查询特定网络适配器（启用状态）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Win32_NetworkAdapter <span class="keyword">WHERE</span> NetEnabled <span class="operator">=</span> <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><h4 id="7-获取当前登录用户信息"><a href="#7-获取当前登录用户信息" class="headerlink" title="7. 获取当前登录用户信息"></a>7. 获取当前登录用户信息</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Win32_ComputerSystem</span><br></pre></td></tr></table></figure><hr><h3 id="💻-在命令行中执行（wmic）"><a href="#💻-在命令行中执行（wmic）" class="headerlink" title="💻 在命令行中执行（wmic）"></a>💻 在命令行中执行（<code>wmic</code>）</h3><p>虽然 <code>wmic</code> 正逐渐被废弃，但在旧系统中可以这样用：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wmic <span class="built_in">path</span> Win32_Processor get Name</span><br><span class="line">wmic <span class="built_in">path</span> Win32_LogicalDisk where &quot;DeviceID=&#x27;C:&#x27;&quot; get Size,FreeSpace</span><br></pre></td></tr></table></figure><hr><h3 id="✅-PowerShell-中使用-WQL-查询"><a href="#✅-PowerShell-中使用-WQL-查询" class="headerlink" title="✅ PowerShell 中使用 WQL 查询"></a>✅ PowerShell 中使用 WQL 查询</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-WmiObject</span> <span class="literal">-Query</span> <span class="string">&quot;SELECT * FROM Win32_BIOS&quot;</span></span><br></pre></td></tr></table></figure><p>或（新版 PowerShell 推荐）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-CimInstance</span> <span class="literal">-Query</span> <span class="string">&quot;SELECT * FROM Win32_Processor&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="🔧-高级用法：多条件查询"><a href="#🔧-高级用法：多条件查询" class="headerlink" title="🔧 高级用法：多条件查询"></a>🔧 高级用法：多条件查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Win32_LogicalDisk <span class="keyword">WHERE</span> DriveType <span class="operator">=</span> <span class="number">3</span> <span class="keyword">AND</span> FreeSpace <span class="operator">&lt;</span> <span class="number">1000000000</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows PXE 自动化部署环境搭建指南</title>
      <link href="/2025/06/03/Windows_PXE_environment/"/>
      <url>/2025/06/03/Windows_PXE_environment/</url>
      
        <content type="html"><![CDATA[<h1 id="🌐-Windows-PXE-自动化部署环境搭建指南"><a href="#🌐-Windows-PXE-自动化部署环境搭建指南" class="headerlink" title="🌐 Windows PXE 自动化部署环境搭建指南"></a>🌐 Windows PXE 自动化部署环境搭建指南</h1><hr><h2 id="✅-一、环境准备与网络配置"><a href="#✅-一、环境准备与网络配置" class="headerlink" title="✅ 一、环境准备与网络配置"></a>✅ 一、环境准备与网络配置</h2><hr><h3 id="🧾-步骤-1：配置服务器静态-IP（IPv4-和-IPv6）"><a href="#🧾-步骤-1：配置服务器静态-IP（IPv4-和-IPv6）" class="headerlink" title="🧾 步骤 1：配置服务器静态 IP（IPv4 和 IPv6）"></a>🧾 步骤 1：配置服务器静态 IP（IPv4 和 IPv6）</h3><ol><li><p>控制面板 → 网络和共享中心 → 更改适配器设置</p></li><li><p>右键网络 → 属性 → 选择 <code>IPv4</code> 和 <code>IPv6</code> → 属性</p></li><li><p>示例配置：</p><ul><li><p>IPv4：</p><ul><li>IP 地址：<code>192.168.10.1</code></li><li>子网掩码：<code>255.255.255.0</code></li><li>默认网关：<code>192.168.10.1</code></li></ul></li><li><p>IPv6：</p><ul><li>地址：<code>fd00:10::1</code></li><li>前缀长度：<code>64</code></li><li>网关：<code>fd00:10::1</code></li></ul></li></ul></li><li><p>点击”确定”保存</p></li></ol><hr><h3 id="🧾-步骤-2：安装-DHCP-和-DNS-服务"><a href="#🧾-步骤-2：安装-DHCP-和-DNS-服务" class="headerlink" title="🧾 步骤 2：安装 DHCP 和 DNS 服务"></a>🧾 步骤 2：安装 DHCP 和 DNS 服务</h3><ol><li><p>打开 <strong>服务器管理器</strong></p></li><li><p>点击”添加角色和功能”</p></li><li><p>选择：</p><ul><li>✅ DHCP Server（DHCP 服务器）</li><li>✅ DNS Server（DNS 服务器）</li></ul></li><li><p>一路”下一步”直到安装完成</p></li><li><p>安装完成后根据提示启动 DHCP 配置向导并完成设置</p></li></ol><hr><h2 id="✅-二、配置-DHCPv4-和-DHCPv6-服务"><a href="#✅-二、配置-DHCPv4-和-DHCPv6-服务" class="headerlink" title="✅ 二、配置 DHCPv4 和 DHCPv6 服务"></a>✅ 二、配置 DHCPv4 和 DHCPv6 服务</h2><hr><h3 id="📌-步骤-3：配置-DHCPv4-服务"><a href="#📌-步骤-3：配置-DHCPv4-服务" class="headerlink" title="📌 步骤 3：配置 DHCPv4 服务"></a>📌 步骤 3：配置 DHCPv4 服务</h3><ol><li><p>打开 <strong>DHCP 管理器</strong></p></li><li><p>右键 <code>IPv4</code> → 新建作用域</p></li><li><p>设置作用域信息：</p><ul><li>名称：<code>Internal-Network</code></li><li>范围：192.168.10.100 - 192.168.10.199</li><li>排除：192.168.10.120 - 192.168.10.129</li><li>子网掩码：255.255.255.0</li><li>网关：192.168.10.1</li><li>DNS：192.168.10.1</li></ul></li><li><p>激活作用域</p></li></ol><hr><h3 id="📌-步骤-4：配置-DHCPv6-服务"><a href="#📌-步骤-4：配置-DHCPv6-服务" class="headerlink" title="📌 步骤 4：配置 DHCPv6 服务"></a>📌 步骤 4：配置 DHCPv6 服务</h3><ol><li><p>DHCP 管理器中 → <code>IPv6</code> → 新建作用域</p></li><li><p>配置如下：</p><ul><li>名称：<code>Internal-IPv6</code></li><li>前缀：<code>fd00:10::</code></li><li>前缀长度：64</li><li>范围编号：1 - 9999</li></ul></li><li><p>完成并激活作用域</p></li></ol><hr><h3 id="📌-步骤-5：启用-IPv6-Router-Advertisement（RA）"><a href="#📌-步骤-5：启用-IPv6-Router-Advertisement（RA）" class="headerlink" title="📌 步骤 5：启用 IPv6 Router Advertisement（RA）"></a>📌 步骤 5：启用 IPv6 Router Advertisement（RA）</h3><h4 id="命令行方式："><a href="#命令行方式：" class="headerlink" title="命令行方式："></a>命令行方式：</h4><ol><li><p>查询interface id</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">netsh interface ipv6 show interface</span><br><span class="line"></span><br><span class="line">Idx     Met         MTU          State                Name</span><br><span class="line">---  ----------  ----------  ------------  ---------------------------</span><br><span class="line">&lt;interface id&gt;          <span class="number">15</span>        <span class="number">1500</span>  connected     Ethernet</span><br></pre></td></tr></table></figure></li><li><p>启用 IPv6 转发和 RA 广播</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">netsh interface ipv6 <span class="built_in">set</span> interface &lt;interface id&gt; forwarding=enabled</span><br><span class="line">netsh interface ipv6 <span class="built_in">set</span> interface &lt;interface id&gt; advertised=enabled</span><br><span class="line">netsh interface ipv6 <span class="built_in">set</span> interface &lt;interface id&gt; managedaddress=enabled</span><br><span class="line">netsh interface ipv6 <span class="built_in">set</span> interface &lt;interface id&gt; otherstateful=enabled</span><br><span class="line">netsh interface ipv6 add route fd00:<span class="number">10</span>::/<span class="number">64</span> &lt;interface id&gt; publish=enabled</span><br></pre></td></tr></table></figure></li><li><p>检查状态</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">netsh interface ipv6 show interface &lt;interface id&gt;</span><br><span class="line">Forwarding                         : enabled</span><br><span class="line">Advertising                        : enabled</span><br><span class="line">Managed Address Configuration      : enabled</span><br><span class="line">Other Stateful Configuration       : enabled</span><br><span class="line"></span><br><span class="line">netsh interface ipv6 show addresses &lt;interface id&gt;</span><br><span class="line">Public     Preferred  <span class="number">29</span>d23h56m28s <span class="number">6</span>d23h56m28s fd00:<span class="number">10</span>::<span class="number">100</span></span><br><span class="line">Dhcp       Preferred      <span class="number">6</span>d23h5m    <span class="number">2</span>d23h5m fd00:<span class="number">10</span>::<span class="number">101</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="图形界面-备用"><a href="#图形界面-备用" class="headerlink" title="图形界面(备用)"></a>图形界面(备用)</h4><blockquote><p>Windows DHCPv6 默认不广播前缀，需通过 RRAS 启用 RA</p></blockquote><ol><li><p>打开 <code>路由和远程访问（RRAS）</code></p></li><li><p>配置为”本地路由模式（LAN Routing）”</p></li><li><p>网卡 → 右键 → 属性 → IPv6 标签页，勾选：</p><ul><li>✅ 启用 Router Advertisement</li><li>✅ Managed Address Configuration（M 位）</li><li>✅ Other Stateful Configuration（O 位）</li><li>❌ 广播前缀（根据需求选择）</li></ul></li><li><p>重启 RRAS 服务</p></li></ol><h2 id="✅-三、配置-DNS-服务"><a href="#✅-三、配置-DNS-服务" class="headerlink" title="✅ 三、配置 DNS 服务"></a>✅ 三、配置 DNS 服务</h2><hr><h3 id="📌-步骤-6：添加正向查找区域"><a href="#📌-步骤-6：添加正向查找区域" class="headerlink" title="📌 步骤 6：添加正向查找区域"></a>📌 步骤 6：添加正向查找区域</h3><ol><li>打开 <code>DNS 管理器</code></li><li>右键”正向查找区域” → 新建区域</li><li>区域名：如 <code>internal.local</code></li><li>类型：主区域，存储在本地服务器</li><li>动态更新：选择”仅安全的”或”无”</li></ol><hr><h3 id="📌-步骤-7：添加反向查找区域（IPv4）"><a href="#📌-步骤-7：添加反向查找区域（IPv4）" class="headerlink" title="📌 步骤 7：添加反向查找区域（IPv4）"></a>📌 步骤 7：添加反向查找区域（IPv4）</h3><ol><li>DNS 管理器 → 右键”反向查找区域” → 新建区域</li><li>网络 ID：如 <code>10.168.192</code></li><li>完成命名：<code>10.168.192.in-addr.arpa</code></li></ol><hr><h2 id="✅-四、安装-PXE-所需组件"><a href="#✅-四、安装-PXE-所需组件" class="headerlink" title="✅ 四、安装 PXE 所需组件"></a>✅ 四、安装 PXE 所需组件</h2><hr><h3 id="📦-步骤-8：安装软件组件"><a href="#📦-步骤-8：安装软件组件" class="headerlink" title="📦 步骤 8：安装软件组件"></a>📦 步骤 8：安装软件组件</h3><ol><li><p><strong>安装 Windows 部署服务（WDS）</strong></p><ul><li><p>打开”服务器管理器” → 添加角色</p></li><li><p>勾选：</p><ul><li>部署服务器</li><li>传输服务器</li></ul></li></ul></li><li><p><strong>安装 Windows ADK + WinPE Add-ons</strong></p><ul><li><p>下载地址：<a href="https://learn.microsoft.com/en-us/windows-hardware/get-started/adk-install">Windows ADK 下载</a></p></li><li><p>选择组件：</p><ul><li>Deployment Tools</li><li>Windows Preinstallation Environment（需 WinPE Add-ons）</li></ul></li></ul></li><li><p><strong>安装 Microsoft Deployment Toolkit (MDT)</strong></p><ul><li>下载地址：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=54259">MDT 下载</a></li><li>安装完成后打开：<strong>Deployment Workbench</strong></li></ul></li></ol><hr><h2 id="✅-五、配置-MDT-部署服务"><a href="#✅-五、配置-MDT-部署服务" class="headerlink" title="✅ 五、配置 MDT 部署服务"></a>✅ 五、配置 MDT 部署服务</h2><hr><h3 id="⚙️-步骤-9：创建部署共享目录"><a href="#⚙️-步骤-9：创建部署共享目录" class="headerlink" title="⚙️ 步骤 9：创建部署共享目录"></a>⚙️ 步骤 9：创建部署共享目录</h3><ol><li>例如：<code>C:\DeploymentShare</code></li><li>Deployment Workbench → Deployment Shares → New Deployment Share</li><li>设置路径、共享名、描述</li></ol><hr><h3 id="⚙️-步骤-10：导入操作系统镜像"><a href="#⚙️-步骤-10：导入操作系统镜像" class="headerlink" title="⚙️ 步骤 10：导入操作系统镜像"></a>⚙️ 步骤 10：导入操作系统镜像</h3><ol><li>将 ISO 挂载或解压，导入其中的 <code>install.wim</code></li><li>Deployment Share → Operating Systems → Import Operating System</li></ol><hr><h3 id="⚙️-步骤-11：创建-Task-Sequence"><a href="#⚙️-步骤-11：创建-Task-Sequence" class="headerlink" title="⚙️ 步骤 11：创建 Task Sequence"></a>⚙️ 步骤 11：创建 Task Sequence</h3><ol><li><p>Deployment Share → Task Sequences → New Task Sequence</p></li><li><p>配置：</p><ul><li>Task ID：如 <code>WS2025</code></li><li>模板：Standard Client Task Sequence</li><li>操作系统：选择上一步导入的镜像</li></ul></li></ol><hr><h3 id="⚙️-步骤-12：配置无人值守部署（CustomSettings-ini-Bootstrap-ini-Task-Squences-Unattend-xml）"><a href="#⚙️-步骤-12：配置无人值守部署（CustomSettings-ini-Bootstrap-ini-Task-Squences-Unattend-xml）" class="headerlink" title="⚙️ 步骤 12：配置无人值守部署（CustomSettings.ini&#x2F;Bootstrap.ini&#x2F;Task Squences&#x2F;Unattend.xml）"></a>⚙️ 步骤 12：配置无人值守部署（CustomSettings.ini&#x2F;Bootstrap.ini&#x2F;Task Squences&#x2F;Unattend.xml）</h3><p><strong>CustomSettings.ini 示例：</strong></p><p>路径：<code>C:\DeploymentShare\Control\CustomSettings.ini</code></p><p>按照Model, Default的优先级顺序，如果client的Model型号匹配，则使用对应的设置，例如”Standard PC (Q35 + ICH9, 2009)”.</p><p>更多参数可以参考<a href="https://learn.microsoft.com/en-us/intune/configmgr/mdt/properties">MDT 文档</a>.</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Settings]</span></span><br><span class="line"><span class="attr">Priority</span>=Model, Default</span><br><span class="line"><span class="attr">Properties</span>=MyCustomProperty</span><br><span class="line"></span><br><span class="line"><span class="section">[Default]</span></span><br><span class="line"><span class="attr">OSInstall</span>=Y</span><br><span class="line"><span class="attr">SkipDeploymentComplete</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">SkipBDDWelcome</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">SkipTaskSequence</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">TaskSequenceID</span>=WS2025</span><br><span class="line"><span class="attr">SkipCapture</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">SkipComputerName</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">SkipUserData</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">SkipSummary</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">SkipFinalSummary</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">SkipAdminPassword</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">AdminPassword</span>=Passw0rd</span><br><span class="line"><span class="attr">SkipProductKey</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">SkipComputerBackup</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">SkipBitLocker</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">SkipDeploymentType</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">DeploymentType</span>=NEWCOMPUTER</span><br><span class="line"><span class="attr">KeyboardLocale</span>=<span class="number">0409</span>:<span class="number">00000409</span></span><br><span class="line"><span class="attr">UserLocale</span>=en-US</span><br><span class="line"><span class="attr">UILanguage</span>=en-US</span><br><span class="line"><span class="attr">TimeZone</span>=Eastern Standard Time</span><br><span class="line"><span class="attr">SkipLocaleSelection</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">JoinWorkgroup</span>=WORKGROUP</span><br><span class="line"><span class="attr">SkipDomainMembership</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">SkipTimeZone</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">SkipApplications</span>=<span class="literal">YES</span></span><br><span class="line"><span class="attr">Applications001</span>=&#123;<span class="number">2</span>ef0539b-<span class="number">5</span>ba0-<span class="number">4</span>dbc-b8d8-daa573151b3d&#125;</span><br><span class="line"><span class="attr">Applications002</span>=&#123;b174dc6e-c0da-<span class="number">409</span>a-b367-ca42fa541a18&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">[Standard PC (Q35 + ICH9, 2009)]</span></span><br><span class="line"><span class="attr">TaskSequenceID</span>=WS2019</span><br><span class="line"><span class="attr">OSDComputerName</span>=Q35-<span class="comment">#Right(Replace(&quot;%MACAddress001%&quot;,&quot;:&quot;,&quot;&quot;),4)#</span></span><br></pre></td></tr></table></figure><p><strong>Bootstrap.ini 示例：</strong></p><p>路径：<code>C:\DeploymentShare\Control\Bootstrap.ini</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Settings]</span></span><br><span class="line"><span class="attr">Priority</span>=Default</span><br><span class="line"></span><br><span class="line"><span class="section">[Default]</span></span><br><span class="line"><span class="attr">DeployRoot</span>=\\&lt;wds 主机名&gt;\DeploymentShare$</span><br><span class="line"><span class="attr">UserID</span>=administrator</span><br><span class="line"><span class="attr">UserDomain</span>=domain.com</span><br><span class="line"><span class="attr">UserPassword</span>=Password</span><br><span class="line"><span class="attr">SkipBDDWelcome</span>=<span class="literal">YES</span></span><br></pre></td></tr></table></figure><p><strong>Task Squences 示例：</strong></p><p>路径: <code>C:\DeploymentShare\Control\&lt;task squence id&gt;\ts.xml</code></p><p>启用OS的EMS，添加以下内容到<code>group name=&quot;Install&quot;</code>中的<code>name=&quot;Install Operating System&quot;</code> 之后.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">step</span> <span class="attr">type</span>=<span class="string">&quot;SMS_TaskSequence_RunCommandLineAction&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Enable EMS&quot;</span> <span class="attr">description</span>=<span class="string">&quot;&quot;</span> <span class="attr">disable</span>=<span class="string">&quot;false&quot;</span> <span class="attr">continueOnError</span>=<span class="string">&quot;false&quot;</span> <span class="attr">startIn</span>=<span class="string">&quot;&quot;</span> <span class="attr">successCodeList</span>=<span class="string">&quot;0 3010&quot;</span> <span class="attr">runIn</span>=<span class="string">&quot;WinPEandFullOS&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultVarList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;PackageID&quot;</span> <span class="attr">property</span>=<span class="string">&quot;PackageID&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;RunAsUser&quot;</span> <span class="attr">property</span>=<span class="string">&quot;RunAsUser&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;SMSTSRunCommandLineUserName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;SMSTSRunCommandLineUserName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;SMSTSRunCommandLineUserPassword&quot;</span> <span class="attr">property</span>=<span class="string">&quot;SMSTSRunCommandLineUserPassword&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;LoadProfile&quot;</span> <span class="attr">property</span>=<span class="string">&quot;LoadProfile&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defaultVarList</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">action</span>&gt;</span>bcdedit /set &#123;default&#125; ems yes<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">step</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">step</span> <span class="attr">type</span>=<span class="string">&quot;SMS_TaskSequence_RunCommandLineAction&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Set EMS settings&quot;</span> <span class="attr">description</span>=<span class="string">&quot;&quot;</span> <span class="attr">disable</span>=<span class="string">&quot;false&quot;</span> <span class="attr">continueOnError</span>=<span class="string">&quot;false&quot;</span> <span class="attr">startIn</span>=<span class="string">&quot;&quot;</span> <span class="attr">successCodeList</span>=<span class="string">&quot;0 3010&quot;</span> <span class="attr">runIn</span>=<span class="string">&quot;WinPEandFullOS&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultVarList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;PackageID&quot;</span> <span class="attr">property</span>=<span class="string">&quot;PackageID&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;RunAsUser&quot;</span> <span class="attr">property</span>=<span class="string">&quot;RunAsUser&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;SMSTSRunCommandLineUserName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;SMSTSRunCommandLineUserName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;SMSTSRunCommandLineUserPassword&quot;</span> <span class="attr">property</span>=<span class="string">&quot;SMSTSRunCommandLineUserPassword&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;LoadProfile&quot;</span> <span class="attr">property</span>=<span class="string">&quot;LoadProfile&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defaultVarList</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">action</span>&gt;</span>bcdedit /emssettings EMSPORT:1 EMSBAUDRATE:115200<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">step</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关闭OS防火墙，放到<code>group name=&quot;State Restore&quot;</code>中的<code>step type=&quot;BDD_Gather</code>之后</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">step</span> <span class="attr">type</span>=<span class="string">&quot;SMS_TaskSequence_RunCommandLineAction&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Disable firewall&quot;</span> <span class="attr">description</span>=<span class="string">&quot;&quot;</span> <span class="attr">disable</span>=<span class="string">&quot;false&quot;</span> <span class="attr">continueOnError</span>=<span class="string">&quot;false&quot;</span> <span class="attr">startIn</span>=<span class="string">&quot;&quot;</span> <span class="attr">successCodeList</span>=<span class="string">&quot;0 3010&quot;</span> <span class="attr">runIn</span>=<span class="string">&quot;WinPEandFullOS&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultVarList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;PackageID&quot;</span> <span class="attr">property</span>=<span class="string">&quot;PackageID&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;RunAsUser&quot;</span> <span class="attr">property</span>=<span class="string">&quot;RunAsUser&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;SMSTSRunCommandLineUserName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;SMSTSRunCommandLineUserName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;SMSTSRunCommandLineUserPassword&quot;</span> <span class="attr">property</span>=<span class="string">&quot;SMSTSRunCommandLineUserPassword&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;LoadProfile&quot;</span> <span class="attr">property</span>=<span class="string">&quot;LoadProfile&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defaultVarList</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">action</span>&gt;</span>netsh advfirewall set allprofiles state off<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">step</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启用RDP远程桌面，放到<code>group name=&quot;State Restore&quot;</code>中的<code>step type=&quot;BDD_Gather</code>之后</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">step</span> <span class="attr">type</span>=<span class="string">&quot;SMS_TaskSequence_RunCommandLineAction&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Enable RDP&quot;</span> <span class="attr">description</span>=<span class="string">&quot;&quot;</span> <span class="attr">disable</span>=<span class="string">&quot;false&quot;</span> <span class="attr">continueOnError</span>=<span class="string">&quot;false&quot;</span> <span class="attr">startIn</span>=<span class="string">&quot;&quot;</span> <span class="attr">successCodeList</span>=<span class="string">&quot;0 3010&quot;</span> <span class="attr">runIn</span>=<span class="string">&quot;WinPEandFullOS&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultVarList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;PackageID&quot;</span> <span class="attr">property</span>=<span class="string">&quot;PackageID&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;RunAsUser&quot;</span> <span class="attr">property</span>=<span class="string">&quot;RunAsUser&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;SMSTSRunCommandLineUserName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;SMSTSRunCommandLineUserName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;SMSTSRunCommandLineUserPassword&quot;</span> <span class="attr">property</span>=<span class="string">&quot;SMSTSRunCommandLineUserPassword&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;LoadProfile&quot;</span> <span class="attr">property</span>=<span class="string">&quot;LoadProfile&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defaultVarList</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">action</span>&gt;</span>reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 0 /f<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">step</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Unattend.xml 示例</strong></p><p>路径: <code>C:\DeploymentShare\Control\&lt;task squence id&gt;\unattend.xml</code></p><p>设置ProductKey, key可以参考<a href="https://learn.microsoft.com/en-us/windows-server/get-started/kms-client-activation-keys">https://learn.microsoft.com/en-us/windows-server/get-started/kms-client-activation-keys</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">name</span>=<span class="string">&quot;Microsoft-Windows-Shell-Setup&quot;</span> <span class="attr">processorArchitecture</span>=<span class="string">&quot;amd64&quot;</span> <span class="attr">publicKeyToken</span>=<span class="string">&quot;31bf3856ad364e35&quot;</span> <span class="attr">language</span>=<span class="string">&quot;neutral&quot;</span> <span class="attr">versionScope</span>=<span class="string">&quot;nonSxS&quot;</span> <span class="attr">xmlns:wcm</span>=<span class="string">&quot;http://schemas.microsoft.com/WMIConfig/2002/State&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ProductKey</span>&gt;</span>xxxxx-xxxxx-xxxxx-xxxxx-xxxxx<span class="tag">&lt;/<span class="name">ProductKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="⚙️-步骤-13：集成UltraVNC到WinPE"><a href="#⚙️-步骤-13：集成UltraVNC到WinPE" class="headerlink" title="⚙️ 步骤 13：集成UltraVNC到WinPE"></a>⚙️ 步骤 13：集成UltraVNC到WinPE</h3><ol><li>下载<a href="https://uvnc.com/downloads/ultravnc/163-ultravnc-1-6-1-00.html">UltraVNC</a> <code>UltraVNC x.x.x.x.zip</code></li><li>解压缩文件，并且将x64改名为VNC, 放到<code>C:\DeploymentShare\ExtraFiles</code>下面</li><li>编辑或创建<code>VNC\UltraVNC.ini</code>, 添加以下内容，为<code>111111</code> base64编码后的值<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[UltraVNC]</span></span><br><span class="line"><span class="attr">passwd</span>=<span class="number">9065</span>AD0D054101281E</span><br></pre></td></tr></table></figure></li><li>Deployment Share → 右键 → Properties → Windows PE → Platform → x64 → Exatra directory to add: → <code>C:\DeploymentShare\ExtraFiles</code> 然后保存</li><li>编辑<code>C:\DeploymentShare\Control\&lt;task squence id&gt;\ts.xml</code>, 添加以下内容到<code>group name=&quot;Initialization&quot;</code>, 关闭WinPE 防火墙并且运行UltraVNC<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">step</span> <span class="attr">type</span>=<span class="string">&quot;SMS_TaskSequence_RunCommandLineAction&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Disable firewall&quot;</span> <span class="attr">description</span>=<span class="string">&quot;&quot;</span> <span class="attr">disable</span>=<span class="string">&quot;false&quot;</span> <span class="attr">continueOnError</span>=<span class="string">&quot;false&quot;</span> <span class="attr">startIn</span>=<span class="string">&quot;&quot;</span> <span class="attr">successCodeList</span>=<span class="string">&quot;0 3010&quot;</span> <span class="attr">runIn</span>=<span class="string">&quot;WinPEandFullOS&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultVarList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;PackageID&quot;</span> <span class="attr">property</span>=<span class="string">&quot;PackageID&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;RunAsUser&quot;</span> <span class="attr">property</span>=<span class="string">&quot;RunAsUser&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;SMSTSRunCommandLineUserName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;SMSTSRunCommandLineUserName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;SMSTSRunCommandLineUserPassword&quot;</span> <span class="attr">property</span>=<span class="string">&quot;SMSTSRunCommandLineUserPassword&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;LoadProfile&quot;</span> <span class="attr">property</span>=<span class="string">&quot;LoadProfile&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defaultVarList</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">action</span>&gt;</span>Wpeutil DisableFirewall<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">step</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">step</span> <span class="attr">type</span>=<span class="string">&quot;SMS_TaskSequence_RunCommandLineAction&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Start VNC&quot;</span> <span class="attr">description</span>=<span class="string">&quot;&quot;</span> <span class="attr">disable</span>=<span class="string">&quot;false&quot;</span> <span class="attr">continueOnError</span>=<span class="string">&quot;false&quot;</span> <span class="attr">startIn</span>=<span class="string">&quot;&quot;</span> <span class="attr">successCodeList</span>=<span class="string">&quot;0 3010&quot;</span> <span class="attr">runIn</span>=<span class="string">&quot;WinPEandFullOS&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defaultVarList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;PackageID&quot;</span> <span class="attr">property</span>=<span class="string">&quot;PackageID&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;RunAsUser&quot;</span> <span class="attr">property</span>=<span class="string">&quot;RunAsUser&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;SMSTSRunCommandLineUserName&quot;</span> <span class="attr">property</span>=<span class="string">&quot;SMSTSRunCommandLineUserName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;SMSTSRunCommandLineUserPassword&quot;</span> <span class="attr">property</span>=<span class="string">&quot;SMSTSRunCommandLineUserPassword&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">variable</span> <span class="attr">name</span>=<span class="string">&quot;LoadProfile&quot;</span> <span class="attr">property</span>=<span class="string">&quot;LoadProfile&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">variable</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defaultVarList</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">action</span>&gt;</span>cmd.exe /c start &quot;&quot; X:\VNC\winvnc.exe -run<span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">step</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>在启动WinPE之后，可以使用UltraVNC连接PXE分配的IP打开VNC窗口，密码为设置的<code>111111</code></li></ol><hr><hr><h3 id="⚙️-步骤-14：生成-LiteTouchPE-引导镜像"><a href="#⚙️-步骤-14：生成-LiteTouchPE-引导镜像" class="headerlink" title="⚙️ 步骤 14：生成 LiteTouchPE 引导镜像"></a>⚙️ 步骤 14：生成 LiteTouchPE 引导镜像</h3><ol><li>Deployment Share → 右键 → Update Deployment Share</li><li>自动生成 <code>LiteTouchPE_x64.wim</code>，路径如下：<br><code>C:\DeploymentShare\Boot\LiteTouchPE_x64.wim</code></li></ol><hr><h2 id="✅-六、配置-WDS（PXE-启动服务）"><a href="#✅-六、配置-WDS（PXE-启动服务）" class="headerlink" title="✅ 六、配置 WDS（PXE 启动服务）"></a>✅ 六、配置 WDS（PXE 启动服务）</h2><hr><h3 id="🧩-步骤-15：配置-WDS-基础设置"><a href="#🧩-步骤-15：配置-WDS-基础设置" class="headerlink" title="🧩 步骤 15：配置 WDS 基础设置"></a>🧩 步骤 15：配置 WDS 基础设置</h3><ol><li>打开”Windows 部署服务”管理器</li><li>设置 RemoteInstall 路径（如：<code>C:\RemoteInstall</code>）</li><li>设置响应所有客户端（包括未知客户端）</li></ol><hr><h3 id="🧩-步骤-16：添加引导镜像"><a href="#🧩-步骤-16：添加引导镜像" class="headerlink" title="🧩 步骤 16：添加引导镜像"></a>🧩 步骤 16：添加引导镜像</h3><ol><li>WDS → Boot Images → Add Boot Image</li><li>选择前面生成的 <code>LiteTouchPE_x64.wim</code></li></ol><hr><h3 id="🧩-步骤-17：可选安装镜像导入"><a href="#🧩-步骤-17：可选安装镜像导入" class="headerlink" title="🧩 步骤 17：可选安装镜像导入"></a>🧩 步骤 17：可选安装镜像导入</h3><ol><li>从 ISO 中提取 <code>install.wim</code></li><li>WDS → Install Images → Add Image Group → 导入 <code>install.wim</code></li></ol><hr><h2 id="✅-七、串口控制台（EMS）可选配置"><a href="#✅-七、串口控制台（EMS）可选配置" class="headerlink" title="✅ 七、串口控制台（EMS）可选配置"></a>✅ 七、串口控制台（EMS）可选配置</h2><hr><h3 id="🧵-步骤-18：启用-EMS（串口控制）"><a href="#🧵-步骤-18：启用-EMS（串口控制）" class="headerlink" title="🧵 步骤 18：启用 EMS（串口控制）"></a>🧵 步骤 18：启用 EMS（串口控制）</h3><ol><li><p>查询BCD中bootload 的identifier</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /store &quot;C:\RemoteInstall\Boot\x64\Images\LiteTouchPE_x64.wim.bcd&quot; /enum</span><br></pre></td></tr></table></figure></li><li><p>设置指定identifier的EMS ON</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /store &quot;C:\RemoteInstall\Boot\x64\Images\LiteTouchPE_x64.wim.bcd&quot; /ems &#123;&lt;identifier&gt;&#125; ON</span><br></pre></td></tr></table></figure></li><li><p>再次检查BCD是否包含 <code>ems Yes</code></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /store &quot;C:\RemoteInstall\Boot\x64\Images\LiteTouchPE_x64.wim.bcd&quot; /enum</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>⚠️ 注意：务必使用 <code>/store</code> 指定 <code>.bcd</code> 文件路径，否则可能更改当前系统引导配置。</p></blockquote><hr><h2 id="✅-八、客户端部署测试与验证"><a href="#✅-八、客户端部署测试与验证" class="headerlink" title="✅ 八、客户端部署测试与验证"></a>✅ 八、客户端部署测试与验证</h2><hr><h3 id="🧪-步骤-19：客户端启动配置"><a href="#🧪-步骤-19：客户端启动配置" class="headerlink" title="🧪 步骤 19：客户端启动配置"></a>🧪 步骤 19：客户端启动配置</h3><ol><li>BIOS&#x2F;UEFI 中设置 PXE 启动优先</li><li>启动后应进入 MDT LiteTouch PE 环境</li><li>自动执行无人值守部署任务序列</li></ol><hr><h3 id="🧪-步骤-20：验证-DHCP-和-DNS-正常工作"><a href="#🧪-步骤-20：验证-DHCP-和-DNS-正常工作" class="headerlink" title="🧪 步骤 20：验证 DHCP 和 DNS 正常工作"></a>🧪 步骤 20：验证 DHCP 和 DNS 正常工作</h3><p>客户端设置为自动获取 IP<br>执行命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ipconfig</span> /release</span><br><span class="line"><span class="built_in">ipconfig</span> /renew</span><br><span class="line"><span class="built_in">ipconfig</span> /all</span><br><span class="line">nslookup internal.local</span><br></pre></td></tr></table></figure><hr><h2 id="✅-九、静态地址分配（保留地址）"><a href="#✅-九、静态地址分配（保留地址）" class="headerlink" title="✅ 九、静态地址分配（保留地址）"></a>✅ 九、静态地址分配（保留地址）</h2><hr><h3 id="📌-DHCPv4-保留地址"><a href="#📌-DHCPv4-保留地址" class="headerlink" title="📌 DHCPv4 保留地址"></a>📌 DHCPv4 保留地址</h3><ol><li>DHCP 管理器 → IPv4 → Reservations</li><li>新建 → 输入 MAC 地址与 IP 进行保留</li></ol><hr><h3 id="📌-DHCPv6-保留地址"><a href="#📌-DHCPv6-保留地址" class="headerlink" title="📌 DHCPv6 保留地址"></a>📌 DHCPv6 保留地址</h3><ol><li>客户端执行 <code>ipconfig /all</code> 获取 <strong>DUID</strong></li><li>DHCP 管理器 → IPv6 → Reservations → 新建保留地址并输入 DUID</li></ol><hr><h2 id="✅-十、故障排查与日志定位"><a href="#✅-十、故障排查与日志定位" class="headerlink" title="✅ 十、故障排查与日志定位"></a>✅ 十、故障排查与日志定位</h2><hr><h3 id="🔧-常见日志路径"><a href="#🔧-常见日志路径" class="headerlink" title="🔧 常见日志路径"></a>🔧 常见日志路径</h3><table><thead><tr><th>阶段</th><th>日志路径</th></tr></thead><tbody><tr><td>WinPE 阶段</td><td><code>X:\MININT\SMSOSD\OSDLOGS\</code></td></tr><tr><td>安装中</td><td><code>C:\MININT\SMSOSD\OSDLOGS\</code></td></tr><tr><td>安装后</td><td><code>C:\Windows\Temp\DeploymentLogs\</code></td></tr></tbody></table><hr><h3 id="🧹-清除失败部署缓存（避免”in-progress”错误）"><a href="#🧹-清除失败部署缓存（避免”in-progress”错误）" class="headerlink" title="🧹 清除失败部署缓存（避免”in-progress”错误）"></a>🧹 清除失败部署缓存（避免”in-progress”错误）</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rd</span> /s /q C:\MININT</span><br><span class="line"><span class="built_in">rd</span> /s /q C:\_SMSTaskSequence</span><br><span class="line"><span class="built_in">del</span> /f /q C:\*.xml</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PXE </tag>
            
            <tag> Windows </tag>
            
            <tag> DHCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intel和AMD服务器处理器路线图</title>
      <link href="/2025/06/03/amd_intel_processor_roadmap/"/>
      <url>/2025/06/03/amd_intel_processor_roadmap/</url>
      
        <content type="html"><![CDATA[<h1 id="Intel和AMD服务器处理器路线图"><a href="#Intel和AMD服务器处理器路线图" class="headerlink" title="Intel和AMD服务器处理器路线图"></a>Intel和AMD服务器处理器路线图</h1><p>英特尔（Intel）和超威（AMD）服务器处理器路线图，涵盖2010年至2025年间的关键产品、技术演进以及对比分析。</p><hr><h2 id="🧩-英特尔-Xeon-处理器路线图（2010–2025）"><a href="#🧩-英特尔-Xeon-处理器路线图（2010–2025）" class="headerlink" title="🧩 英特尔 Xeon 处理器路线图（2010–2025）"></a>🧩 英特尔 Xeon 处理器路线图（2010–2025）</h2><table><thead><tr><th>年份</th><th>架构代号</th><th>制程工艺</th><th>核心数</th><th>插槽&#x2F;平台</th><th>主要特性</th><th></th></tr></thead><tbody><tr><td>2010</td><td>Westmere-EP</td><td>32nm</td><td>6</td><td>LGA 1366</td><td>基于 Nehalem 架构，支持超线程和 Turbo Boost 技术。</td><td></td></tr><tr><td>2011</td><td>Sandy Bridge-EP</td><td>32nm</td><td>8</td><td>LGA 2011</td><td>引入 AVX 指令集，提升浮点性能。</td><td></td></tr><tr><td>2012</td><td>Ivy Bridge-EP</td><td>22nm</td><td>12</td><td>LGA 2011</td><td>首次采用 3D 晶体管技术，提升能效比。</td><td></td></tr><tr><td>2014</td><td>Haswell-EP</td><td>22nm</td><td>18</td><td>LGA 2011-v3</td><td>引入 AVX2 指令集，提升整数和浮点性能。</td><td></td></tr><tr><td>2015</td><td>Broadwell-EP</td><td>14nm</td><td>22</td><td>LGA 2011-v3</td><td>制程升级至 14nm，提升能效和性能。</td><td></td></tr><tr><td>2017</td><td>Skylake-SP</td><td>14nm</td><td>28</td><td>LGA 3647</td><td>引入 Xeon Scalable 命名，支持 AVX-512 指令集。</td><td></td></tr><tr><td>2019</td><td>Cascade Lake-SP</td><td>14nm</td><td>28</td><td>LGA 3647</td><td>支持 Optane DC 持久内存，提升内存容量和带宽。</td><td></td></tr><tr><td>2020</td><td>Cooper Lake</td><td>14nm</td><td>28</td><td>LGA 4189</td><td>首次支持 bfloat16 指令，优化 AI 性能。</td><td></td></tr><tr><td>2021</td><td>Ice Lake-SP</td><td>10nm</td><td>40</td><td>LGA 4189</td><td>首次采用 10nm 制程，支持 PCIe 4.0 和 DDR4。</td><td></td></tr><tr><td>2022</td><td>Sapphire Rapids</td><td>Intel 7</td><td>60</td><td>LGA 4677</td><td>引入模块化设计，支持 DDR5 和 PCIe 5.0。</td><td></td></tr><tr><td>2023</td><td>Emerald Rapids</td><td>Intel 7</td><td>64</td><td>LGA 4677</td><td>增加 L3 缓存，提升能效比，兼容 LGA 4677 插槽。</td><td></td></tr><tr><td>2024</td><td>Sierra Forest (E-Core)</td><td>Intel 3</td><td>144–288</td><td>LGA 7529</td><td>首款纯 E-Core 设计，面向云计算，支持 DDR5 和 PCIe 5.0。</td><td></td></tr><tr><td>2024</td><td>Granite Rapids (P-Core)</td><td>Intel 3</td><td>128</td><td>LGA 7529</td><td>基于 P-Core 设计，面向高性能计算，支持 DDR5-8800。</td><td></td></tr><tr><td>2025</td><td>Clearwater Forest (E-Core)</td><td>Intel 18A</td><td>待定</td><td>LGA 7529</td><td>采用 RibbonFET 晶体管技术，进一步提升能效和核心密度。</td><td></td></tr><tr><td>2025</td><td>Diamond Rapids (P-Core)</td><td>Intel 18A</td><td>待定</td><td>LGA 9324</td><td>预计采用 Panther Cove-X 架构，支持 APX 指令集，提升 IPC 性能。</td><td></td></tr></tbody></table><hr><h2 id="🧩-AMD-EPYC-处理器路线图（2010–2025）"><a href="#🧩-AMD-EPYC-处理器路线图（2010–2025）" class="headerlink" title="🧩 AMD EPYC 处理器路线图（2010–2025）"></a>🧩 AMD EPYC 处理器路线图（2010–2025）</h2><h3 id="2010-2016"><a href="#2010-2016" class="headerlink" title="2010-2016"></a>2010-2016</h3><hr><table><thead><tr><th>年份</th><th>架构代号</th><th>制程</th><th>核心数</th><th>主要特性</th></tr></thead><tbody><tr><td>2010</td><td>Magny-Cours</td><td>45nm</td><td>8–12</td><td>基于 K10 架构，支持 DDR3 内存，采用 Socket G34 插槽。</td></tr><tr><td>2011</td><td>Interlagos</td><td>32nm</td><td>8–16</td><td>首次引入 Bulldozer 架构，支持 AVX 指令集，提升浮点性能。</td></tr><tr><td>2012</td><td>Abu Dhabi</td><td>32nm</td><td>8–16</td><td>基于 Piledriver 架构，优化能效比，提升时钟频率。</td></tr><tr><td>2014</td><td>Warsaw</td><td>32nm</td><td>8–16</td><td>针对 2P&#x2F;4P 服务器优化，提升性能和能效。</td></tr><tr><td>2016</td><td>Opteron A1100</td><td>28nm</td><td>4–8</td><td>基于 ARM Cortex-A57 架构，首款 ARM 架构的 Opteron 处理器。</td></tr></tbody></table><h3 id="2017-2025"><a href="#2017-2025" class="headerlink" title="2017-2025"></a>2017-2025</h3><hr><table><thead><tr><th>年份</th><th>架构代号</th><th>制程工艺</th><th>核心数</th><th>插槽&#x2F;平台</th><th>主要特性</th><th></th></tr></thead><tbody><tr><td>2017</td><td>Naples</td><td>14nm</td><td>32</td><td>SP3</td><td>首款 EPYC 处理器，基于 Zen 架构，支持 8 通道 DDR4 内存和 128 条 PCIe 3.0 通道。</td><td></td></tr><tr><td>2019</td><td>Rome</td><td>7nm</td><td>64</td><td>SP3</td><td>基于 Zen 2 架构，采用 Chiplet 设计，支持 PCIe 4.0，提升内存带宽和 I&#x2F;O 性能。</td><td></td></tr><tr><td>2021</td><td>Milan</td><td>7nm</td><td>64</td><td>SP3</td><td>基于 Zen 3 架构，提升每核心性能，优化缓存架构。</td><td></td></tr><tr><td>2022</td><td>Milan-X</td><td>7nm</td><td>64</td><td>SP3</td><td>在 Milan 基础上引入 3D V-Cache 技术，L3 缓存高达 768MB，提升特定工作负载性能。</td><td></td></tr><tr><td>2022</td><td>Genoa</td><td>5nm</td><td>96</td><td>SP5</td><td>基于 Zen 4 架构，支持 DDR5 内存和 PCIe 5.0，采用 SP5 插槽。</td><td></td></tr><tr><td>2023</td><td>Bergamo (Zen 4c)</td><td>5nm</td><td>128</td><td>SP5</td><td>基于 Zen 4c 架构，针对云计算优化，提升核心密度和能效比。</td><td></td></tr><tr><td>2023</td><td>Siena</td><td>5nm</td><td>16–64</td><td>SP6</td><td>面向边缘计算和电信市场，优化功耗和成本，采用 SP6 插槽。</td><td></td></tr><tr><td>2024</td><td>Turin</td><td>4nm&#x2F;3nm</td><td>192</td><td>SP5</td><td>基于 Zen 5 架构，支持 DDR5 和 PCIe 5.0，进一步提升性能和能效。</td><td></td></tr><tr><td>2025</td><td>Venice (Zen 6&#x2F;6c)</td><td>3nm&#x2F;2nm</td><td>96–256</td><td>SP7&#x2F;SP8</td><td>基于 Zen 6 架构，采用先进封装技术，支持更高核心数和缓存容量，预计在 2026 年发布。</td><td></td></tr></tbody></table><hr><h2 id="⚔️-技术对比分析（Intel-vs-AMD）"><a href="#⚔️-技术对比分析（Intel-vs-AMD）" class="headerlink" title="⚔️ 技术对比分析（Intel vs AMD）"></a>⚔️ 技术对比分析（Intel vs AMD）</h2><h3 id="核心数与架构"><a href="#核心数与架构" class="headerlink" title="核心数与架构"></a>核心数与架构</h3><ul><li><p><strong>Intel</strong>：通过引入 E-Core（如 Sierra Forest）和 P-Core（如 Granite Rapids）架构，实现了核心数的显著提升，Sierra Forest 高达 288 核心，Granite Rapids 达到 128 核心。</p></li><li><p><strong>AMD</strong>：采用 Chiplet 设计和 Zen 架构的持续优化，核心数从 Naples 的 32 核心提升至 Venice 的最高 256 核心，特别是在 Bergamo 和 Turin 中展现出高核心密度的优势。</p></li></ul><h3 id="制程工艺"><a href="#制程工艺" class="headerlink" title="制程工艺"></a>制程工艺</h3><ul><li><p><strong>Intel</strong>：从 32nm 逐步过渡到 Intel 18A 制程，计划在 2025 年的 Clearwater Forest 和 Diamond Rapids 中采用。</p></li><li><p><strong>AMD</strong>：依赖台积电（TSMC）的先进制程，从 14nm 过渡到 2nm，预计在 Venice 中采用，提升晶体管密度和能效比。</p></li></ul><h3 id="平台与内存支持"><a href="#平台与内存支持" class="headerlink" title="平台与内存支持"></a>平台与内存支持</h3><ul><li><p><strong>Intel</strong>：从 LGA 1366 过渡到 LGA 9324，支持 DDR5 内存和 PCIe 5.0&#x2F;5.0+，提升内存带宽和 I&#x2F;O 性能。</p></li><li><p><strong>AMD</strong>：从 SP3 过渡到 SP7&#x2F;SP8，支持 DDR5 内存和 PCIe 5.0，进一步提升内存带宽和 I&#x2F;O 性能。</p></li></ul><h3 id="能效与性能优化"><a href="#能效与性能优化" class="headerlink" title="能效与性能优化"></a>能效与性能优化</h3><ul><li><p><strong>Intel</strong>：通过引入 E-Core 架构（如 Sierra Forest）和先进制程，提升性能每瓦比，特别适用于云计算和高密度部署。</p></li><li><p><strong>AMD</strong>：通过 Zen 架构的持续优化和 3D V-Cache 技术，提升每核心性能和缓存容量，适用于高性能计算和数据密集型工作负载。</p></li></ul><hr><h2 id="📊-总结对比表"><a href="#📊-总结对比表" class="headerlink" title="📊 总结对比表"></a>📊 总结对比表</h2><table><thead><tr><th>项目</th><th>Intel Xeon 系列</th><th>AMD EPYC 系列</th><th></th></tr></thead><tbody><tr><td>架构</td><td>P-Core &#x2F; E-Core 分离设计</td><td>Zen 系列架构（Zen 至 Zen 6）</td><td></td></tr><tr><td>核心数范围</td><td>6 – 288</td><td>8 – 256</td><td></td></tr><tr><td>制程工艺</td><td>32nm → Intel 18A</td><td>14nm → TSMC 2nm</td><td></td></tr><tr><td>插槽平台</td><td>LGA 1366 → LGA 9324</td><td>SP3 → SP7&#x2F;SP8</td><td></td></tr><tr><td>内存支持</td><td>DDR3 → DDR5</td><td>DDR4 → DDR5</td><td></td></tr><tr><td>PCIe 支持</td><td>PCIe 3.0 → PCIe 5.0</td><td>PCIe 3.0 → PCIe 5.0</td><td></td></tr><tr><td>能效优化</td><td>引入 E-Core 架构，提升性能每瓦比</td><td>Zen 架构优化，采用 3D V-Cache 技术</td><td></td></tr><tr><td>代表产品</td><td>Sierra Forest, Granite Rapids</td><td>Bergamo, Turin, Venice</td><td></td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPU </tag>
            
            <tag> Intel </tag>
            
            <tag> AMD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TigerVNC Server 搭建指南（适用于 RHEL 9，使用 root 用户）</title>
      <link href="/2025/06/03/rhel9_tigervnc_server/"/>
      <url>/2025/06/03/rhel9_tigervnc_server/</url>
      
        <content type="html"><![CDATA[<h1 id="🐯-TigerVNC-Server-搭建指南（适用于-RHEL-9，使用-root-用户）"><a href="#🐯-TigerVNC-Server-搭建指南（适用于-RHEL-9，使用-root-用户）" class="headerlink" title="🐯 TigerVNC Server 搭建指南（适用于 RHEL 9，使用 root 用户）"></a>🐯 TigerVNC Server 搭建指南（适用于 RHEL 9，使用 root 用户）</h1><hr><h2 id="📦-第一步：安装-TigerVNC-Server"><a href="#📦-第一步：安装-TigerVNC-Server" class="headerlink" title="📦 第一步：安装 TigerVNC Server"></a>📦 第一步：安装 TigerVNC Server</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install tigervnc-server -y</span><br></pre></td></tr></table></figure><hr><h2 id="👤-第二步：设置-root-的-VNC-登录密码"><a href="#👤-第二步：设置-root-的-VNC-登录密码" class="headerlink" title="👤 第二步：设置 root 的 VNC 登录密码"></a>👤 第二步：设置 root 的 VNC 登录密码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vncpasswd</span><br></pre></td></tr></table></figure><p>设置完成后会生成 <code>/root/.vnc/passwd</code> 文件。</p><hr><h2 id="🧾-第三步：配置用户和显示号映射"><a href="#🧾-第三步：配置用户和显示号映射" class="headerlink" title="🧾 第三步：配置用户和显示号映射"></a>🧾 第三步：配置用户和显示号映射</h2><p>编辑 <code>/etc/tigervnc/vncserver.users</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/tigervnc/vncserver.users</span><br></pre></td></tr></table></figure><p>添加内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1=root</span><br></pre></td></tr></table></figure><blockquote><p>这表示 <code>root</code> 用户绑定到 VNC 显示号 <code>:1</code>，对应端口 5901。</p></blockquote><hr><h2 id="🧠-第四步：配置桌面环境（默认-GNOME）"><a href="#🧠-第四步：配置桌面环境（默认-GNOME）" class="headerlink" title="🧠 第四步：配置桌面环境（默认 GNOME）"></a>🧠 第四步：配置桌面环境（默认 GNOME）</h2><p>确认 root 目录中存在 VNC 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /root/.vnc</span><br><span class="line">vi /root/.vnc/config</span><br></pre></td></tr></table></figure><p>内容如下（默认 GNOME 桌面）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session=gnome</span><br></pre></td></tr></table></figure><p>如果你使用 KDE 或 XFCE，可修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session=plasma</span><br><span class="line">session=xfce</span><br></pre></td></tr></table></figure><hr><h2 id="⚙️-第五步：创建-Systemd-服务文件"><a href="#⚙️-第五步：创建-Systemd-服务文件" class="headerlink" title="⚙️ 第五步：创建 Systemd 服务文件"></a>⚙️ 第五步：创建 Systemd 服务文件</h2><p>复制模板并命名为 <code>vncserver@.service</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@.service</span><br></pre></td></tr></table></figure><p>可选检查或修改服务文件（一般无需改）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/vncserver@.service</span><br></pre></td></tr></table></figure><p>确认如下字段存在：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">User</span>=root</span><br><span class="line"><span class="attr">ExecStartPre</span>=/usr/libexec/vncsession-restore %i</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/libexec/vncsession-start %i</span><br><span class="line"><span class="attr">PIDFile</span>=/run/vncsession-%i.pid</span><br><span class="line"><span class="attr">SELinuxContext</span>=system_u:system_r:vnc_session_t:s0</span><br></pre></td></tr></table></figure><hr><h2 id="🚀-第六步：启动-VNC-服务"><a href="#🚀-第六步：启动-VNC-服务" class="headerlink" title="🚀 第六步：启动 VNC 服务"></a>🚀 第六步：启动 VNC 服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> --now vncserver@root.service</span><br></pre></td></tr></table></figure><p>如果报错<code>No user configured for display root</code>，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> --now vncserver@:1.service</span><br></pre></td></tr></table></figure><hr><h2 id="🔍-第七步：验证服务状态"><a href="#🔍-第七步：验证服务状态" class="headerlink" title="🔍 第七步：验证服务状态"></a>🔍 第七步：验证服务状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status vncserver@root.service</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status vncserver@:1.service</span><br></pre></td></tr></table></figure><p>查看是否显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Active: active (running)</span><br></pre></td></tr></table></figure><hr><h2 id="🔥-第八步：开放防火墙端口（如启用了-firewalld）"><a href="#🔥-第八步：开放防火墙端口（如启用了-firewalld）" class="headerlink" title="🔥 第八步：开放防火墙端口（如启用了 firewalld）"></a>🔥 第八步：开放防火墙端口（如启用了 firewalld）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=5901/tcp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><hr><h2 id="💻-第九步：客户端连接"><a href="#💻-第九步：客户端连接" class="headerlink" title="💻 第九步：客户端连接"></a>💻 第九步：客户端连接</h2><p>使用 VNC 客户端工具（如 RealVNC、TigerVNC Viewer）连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;服务器IP&gt;:1</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;服务器IP&gt;:5901</span><br></pre></td></tr></table></figure><p>输入你设置的 VNC 密码，即可连接。</p><hr><h2 id="📌-补充说明"><a href="#📌-补充说明" class="headerlink" title="📌 补充说明"></a>📌 补充说明</h2><table><thead><tr><th>内容</th><th>默认值</th></tr></thead><tbody><tr><td>默认桌面环境</td><td>GNOME</td></tr><tr><td>默认端口</td><td>5900 + 显示号（:1 → 5901）</td></tr><tr><td>显示日志</td><td><code>/root/.vnc/*.log</code></td></tr><tr><td>密码文件</td><td><code>/root/.vnc/passwd</code></td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RHEL9 </tag>
            
            <tag> VNC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nmap 使用介绍</title>
      <link href="/2025/02/11/namp_scan/"/>
      <url>/2025/02/11/namp_scan/</url>
      
        <content type="html"><![CDATA[<h1 id="Nmap-使用介绍"><a href="#Nmap-使用介绍" class="headerlink" title="Nmap 使用介绍"></a>Nmap 使用介绍</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Nmap（Network Mapper）是一款开源的网络扫描和安全审计工具。它主要用于发现网络主机、检测开放端口、识别操作系统及服务等。本文档详细说明了 Nmap 的使用方法，确保用户能够有效、安全地进行网络扫描。</p><hr><h2 id="2-先决条件"><a href="#2-先决条件" class="headerlink" title="2. 先决条件"></a>2. 先决条件</h2><ul><li>已安装 Nmap（适用于 Linux、Windows 和 macOS）。</li><li>具备基本的网络和安全知识。</li><li>具备适当的权限（某些扫描模式需要 root 或管理员权限）。</li></ul><h3 id="2-1-安装-Nmap"><a href="#2-1-安装-Nmap" class="headerlink" title="2.1 安装 Nmap"></a>2.1 安装 Nmap</h3><h4 id="Linux（Debian-Ubuntu）"><a href="#Linux（Debian-Ubuntu）" class="headerlink" title="Linux（Debian&#x2F;Ubuntu）"></a>Linux（Debian&#x2F;Ubuntu）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install nmap -y</span><br></pre></td></tr></table></figure><h4 id="Linux（CentOS-RHEL）"><a href="#Linux（CentOS-RHEL）" class="headerlink" title="Linux（CentOS&#x2F;RHEL）"></a>Linux（CentOS&#x2F;RHEL）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install nmap -y</span><br></pre></td></tr></table></figure><h4 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nmap</span><br></pre></td></tr></table></figure><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>下载并安装 Nmap：<a href="https://nmap.org/download.html">官方下载页面</a></p><hr><h2 id="3-操作流程"><a href="#3-操作流程" class="headerlink" title="3. 操作流程"></a>3. 操作流程</h2><h3 id="3-1-目标主机发现"><a href="#3-1-目标主机发现" class="headerlink" title="3.1 目标主机发现"></a>3.1 目标主机发现</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sn 192.168.1.0/24</span><br></pre></td></tr></table></figure><ul><li><code>-sn</code>：仅检测在线主机（不扫描端口）。</li></ul><h3 id="3-2-端口扫描"><a href="#3-2-端口扫描" class="headerlink" title="3.2 端口扫描"></a>3.2 端口扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 22,80,443 192.168.1.100</span><br></pre></td></tr></table></figure><ul><li><code>-p</code>：指定端口（可输入单个端口或端口范围，如 <code>1-65535</code>）。</li></ul><h4 id="常见公认端口（0-1023）"><a href="#常见公认端口（0-1023）" class="headerlink" title="常见公认端口（0-1023）"></a><strong>常见公认端口（0-1023）</strong></h4><table><thead><tr><th>端口号</th><th>协议</th><th>说明</th></tr></thead><tbody><tr><td>20</td><td>TCP</td><td>FTP 数据传输</td></tr><tr><td>21</td><td>TCP</td><td>FTP 控制连接</td></tr><tr><td>22</td><td>TCP</td><td>SSH 远程登录</td></tr><tr><td>23</td><td>TCP</td><td>Telnet 远程登录（不安全）</td></tr><tr><td>25</td><td>TCP</td><td>SMTP（发送邮件）</td></tr><tr><td>53</td><td>TCP&#x2F;UDP</td><td>DNS（域名解析）</td></tr><tr><td>67</td><td>UDP</td><td>DHCP 服务器端</td></tr><tr><td>68</td><td>UDP</td><td>DHCP 客户端</td></tr><tr><td>69</td><td>UDP</td><td>TFTP（简单文件传输）</td></tr><tr><td>80</td><td>TCP</td><td>HTTP（网页访问）</td></tr><tr><td>443</td><td>TCP</td><td>HTTPS（加密网页访问）</td></tr></tbody></table><h4 id="常见注册端口（1024-49151）"><a href="#常见注册端口（1024-49151）" class="headerlink" title="常见注册端口（1024-49151）"></a><strong>常见注册端口（1024-49151）</strong></h4><table><thead><tr><th>端口号</th><th>协议</th><th>说明</th></tr></thead><tbody><tr><td>1080</td><td>TCP</td><td>SOCKS 代理</td></tr><tr><td>1433</td><td>TCP</td><td>Microsoft SQL Server</td></tr><tr><td>1521</td><td>TCP</td><td>Oracle 数据库</td></tr><tr><td>3306</td><td>TCP</td><td>MySQL 数据库</td></tr><tr><td>3389</td><td>TCP</td><td>RDP（远程桌面协议）</td></tr><tr><td>5900</td><td>TCP</td><td>VNC 远程控制</td></tr><tr><td>8080</td><td>TCP</td><td>HTTP 备用端口</td></tr><tr><td>9200</td><td>TCP</td><td>Elasticsearch</td></tr></tbody></table><h4 id="IPMI-相关端口"><a href="#IPMI-相关端口" class="headerlink" title="IPMI 相关端口"></a><strong>IPMI 相关端口</strong></h4><table><thead><tr><th>端口号</th><th>协议</th><th>说明</th></tr></thead><tbody><tr><td>623</td><td>UDP</td><td>IPMI RMCP（远程管理控制协议）</td></tr><tr><td>664</td><td>UDP</td><td>IPMI RMCP+（增强版远程管理控制协议）</td></tr><tr><td>22</td><td>TCP</td><td>IPMI 远程 SSH 访问（基于 BMC）</td></tr><tr><td>80</td><td>TCP</td><td>IPMI Web 界面（HTTP）</td></tr><tr><td>443</td><td>TCP</td><td>IPMI Web 界面（HTTPS）</td></tr></tbody></table><p>如果需要检查 IPMI 端口是否开放，可使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 623,664,22,80,443 &lt;BMC_IP&gt;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -zv &lt;BMC_IP&gt; 623</span><br></pre></td></tr></table></figure><h3 id="3-3-服务与版本检测"><a href="#3-3-服务与版本检测" class="headerlink" title="3.3 服务与版本检测"></a>3.3 服务与版本检测</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV 192.168.1.100</span><br></pre></td></tr></table></figure><ul><li><code>-sV</code>：探测端口对应的服务及版本信息。</li></ul><h3 id="3-4-操作系统检测（需要-root-权限）"><a href="#3-4-操作系统检测（需要-root-权限）" class="headerlink" title="3.4 操作系统检测（需要 root 权限）"></a>3.4 操作系统检测（需要 root 权限）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -O 192.168.1.100</span><br></pre></td></tr></table></figure><ul><li><code>-O</code>：尝试识别远程主机操作系统。</li></ul><h3 id="3-5-全端口扫描（可能耗时较长）"><a href="#3-5-全端口扫描（可能耗时较长）" class="headerlink" title="3.5 全端口扫描（可能耗时较长）"></a>3.5 全端口扫描（可能耗时较长）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p- 192.168.1.100</span><br></pre></td></tr></table></figure><ul><li><code>-p-</code>：扫描所有 65535 个端口。</li></ul><h3 id="3-6-运行默认安全脚本扫描"><a href="#3-6-运行默认安全脚本扫描" class="headerlink" title="3.6 运行默认安全脚本扫描"></a>3.6 运行默认安全脚本扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sC 192.168.1.100</span><br></pre></td></tr></table></figure><ul><li><code>-sC</code>：运行默认 Nmap 脚本扫描，检测常见安全问题。</li></ul><h3 id="3-7-执行深度漏洞扫描（需要-root-权限）"><a href="#3-7-执行深度漏洞扫描（需要-root-权限）" class="headerlink" title="3.7 执行深度漏洞扫描（需要 root 权限）"></a>3.7 执行深度漏洞扫描（需要 root 权限）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap --script=vuln 192.168.1.100</span><br></pre></td></tr></table></figure><ul><li><code>--script=vuln</code>：运行漏洞扫描脚本。</li></ul><h3 id="3-8-结果导出"><a href="#3-8-结果导出" class="headerlink" title="3.8 结果导出"></a>3.8 结果导出</h3><h4 id="导出为文本文件"><a href="#导出为文本文件" class="headerlink" title="导出为文本文件"></a>导出为文本文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -oN scan_results.txt 192.168.1.100</span><br></pre></td></tr></table></figure><h4 id="导出为-XML-文件"><a href="#导出为-XML-文件" class="headerlink" title="导出为 XML 文件"></a>导出为 XML 文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -oX scan_results.xml 192.168.1.100</span><br></pre></td></tr></table></figure><hr><h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ul><li><a href="https://nmap.org/">Nmap 官方网站</a></li><li><a href="https://nmap.org/book/man.html">Nmap 命令手册</a></li><li><a href="https://nmap.org/nsedoc/">Nmap 脚本库</a></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> Nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Bash 中隐藏路径以简化提示符</title>
      <link href="/2024/12/25/bash_directory_config/"/>
      <url>/2024/12/25/bash_directory_config/</url>
      
        <content type="html"><![CDATA[<h1 id="在-Bash-中隐藏路径以简化提示符"><a href="#在-Bash-中隐藏路径以简化提示符" class="headerlink" title="在 Bash 中隐藏路径以简化提示符"></a>在 Bash 中隐藏路径以简化提示符</h1><p>在 Bash 中，可以通过以下方法隐藏路径或调整提示符以简化显示，并保持高亮效果：</p><hr><h3 id="方法一：自定义-PS1（Prompt-String-1）"><a href="#方法一：自定义-PS1（Prompt-String-1）" class="headerlink" title="方法一：自定义 PS1（Prompt String 1）"></a>方法一：自定义 <code>PS1</code>（Prompt String 1）</h3><p><code>PS1</code> 是 Bash 的提示符变量，你可以通过设置它来定制显示内容。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;\u@\h:~\$ &#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>\u</code>：显示用户名。</li><li><code>\h</code>：显示主机名。</li><li><code>~</code>：始终显示为 <code>~</code>，而不是完整路径。</li></ul><p>此时，提示符将变成类似这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user@localhost:~$</span><br></pre></td></tr></table></figure><p>如果希望添加高亮效果，可以加入颜色代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;\[\033[1;32m\]\u@\h:\[\033[1;34m\]~\[\033[0m\]\$ &#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>\[\033[1;32m\]</code>：设置绿色高亮（用户名和主机名）。</li><li><code>\[\033[1;34m\]</code>：设置蓝色高亮（路径）。</li><li><code>\[\033[0m\]</code>：重置颜色，避免影响后续输出。</li></ul><hr><h3 id="方法二：显示相对路径"><a href="#方法二：显示相对路径" class="headerlink" title="方法二：显示相对路径"></a>方法二：显示相对路径</h3><p>让路径只显示相对于主目录的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;\u@\h:\w\$ &#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>\w</code>：显示当前路径，但用 <code>~</code> 替代主目录路径。</li></ul><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user@localhost:~/log$</span><br></pre></td></tr></table></figure><p>如果希望保持高亮，可以使用以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;\[\033[1;32m\]\u@\h:\[\033[1;34m\]\w\[\033[0m\]\$ &#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="方法三：完全隐藏路径"><a href="#方法三：完全隐藏路径" class="headerlink" title="方法三：完全隐藏路径"></a>方法三：完全隐藏路径</h3><p>如果你想完全隐藏路径，只显示用户名和主机名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;\u@\h\$ &#x27;</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user@localhost$</span><br></pre></td></tr></table></figure><p>为恢复高亮，可以这样设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;\[\033[1;32m\]\u@\h\[\033[0m\]\$ &#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="方法四：设置为简短路径"><a href="#方法四：设置为简短路径" class="headerlink" title="方法四：设置为简短路径"></a>方法四：设置为简短路径</h3><p>如果你只想显示目录名，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;\u@\h:\W\$ &#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>\W</code>：仅显示当前目录名。</li></ul><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user@localhost:stress$</span><br></pre></td></tr></table></figure><p>为添加高亮：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;\[\033[1;32m\]\u@\h:\[\033[1;34m\]\W\[\033[0m\]\$ &#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="方法五：使用系统默认高亮提示符"><a href="#方法五：使用系统默认高亮提示符" class="headerlink" title="方法五：使用系统默认高亮提示符"></a>方法五：使用系统默认高亮提示符</h3><p>如果不想手动设置颜色，可以使用系统默认提示符样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;\[\e]0;\u@\h: \w\a\]\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\W\[\033[00m\]\$ &#x27;</span></span><br></pre></td></tr></table></figure><hr><h3 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h3><p>如果需要每次启动 Bash 都应用设置，可以将上述命令加入 <code>~/.bashrc</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PS1=&#x27;\[\033[1;32m\]\u@\h:\[\033[1;34m\]\W\[\033[0m\]\$ &#x27;&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><hr><h3 id="测试终端颜色支持"><a href="#测试终端颜色支持" class="headerlink" title="测试终端颜色支持"></a>测试终端颜色支持</h3><p>确保你的终端支持 ANSI 转义序列（大多数现代终端都支持，例如 GNOME Terminal、Konsole 等）。</p><p>测试颜色支持的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\033[1;32m绿色高亮\033[0m 和 \033[1;34m蓝色高亮\033[0m&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> BASH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决RHEL9 Home 分区丢失导致进入emergency mode</title>
      <link href="/2024/12/23/RHEL9_home_partition_lost_solution/"/>
      <url>/2024/12/23/RHEL9_home_partition_lost_solution/</url>
      
        <content type="html"><![CDATA[<h1 id="解决RHEL9-Home-分区丢失导致进入emergency-mode"><a href="#解决RHEL9-Home-分区丢失导致进入emergency-mode" class="headerlink" title="解决RHEL9 Home 分区丢失导致进入emergency mode"></a>解决RHEL9 Home 分区丢失导致进入emergency mode</h1><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul><li>系统进入紧急模式。  </li><li>需要修复LVM设备配置文件问题，E.g. &#x2F;home 分区丢失。</li></ul><h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a><strong>操作步骤</strong></h4><ol><li>删除损坏的设备文件：  <pre><code class="bash">rm /etc/lvm/devices/system.devices  </code></pre></li><li>创建新的设备文件：  <pre><code class="bash">vgimportdevices -a  </code></pre></li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ul><li>执行操作前确保有系统备份。  </li><li>适用于LVM相关配置问题。</li></ul><p>更多详情参考原文：<a href="https://portal.nutanix.com/page/documents/kbs/details?targetId=kA07V000000LaGrSAK">Nutanix知识库</a>。  </p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> RHEL9 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RHEL9 启用OS串口(Serial Port)信息输出</title>
      <link href="/2024/12/22/enable_rhel9_os_serial_output/"/>
      <url>/2024/12/22/enable_rhel9_os_serial_output/</url>
      
        <content type="html"><![CDATA[<h1 id="RHEL9-启用OS串口信息输出"><a href="#RHEL9-启用OS串口信息输出" class="headerlink" title="RHEL9 启用OS串口信息输出"></a>RHEL9 启用OS串口信息输出</h1><p>基于 RHEL 的系统上修改 GRUB 配置以调整内核启动参数：</p><ol><li><p><strong>备份现有的 GRUB 配置文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /etc/default/grub /etc/default/grub.bak</span><br></pre></td></tr></table></figure><p>将原始的 GRUB 配置文件 <code>/etc/default/grub</code> 备份为 <code>/etc/default/grub.bak</code>。</p></li><li><p><strong>修改 GRUB 配置</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&quot;s/quiet/loglevel=8 console=tty1 console=ttyS1,115200n8/g&quot;</span> /etc/default/grub</span><br></pre></td></tr></table></figure><p>使用 <code>sed</code> 命令查找并替换文件中的内容：</p><ul><li>将 <code>quiet</code> 参数替换为 <code>loglevel=8 console=tty1 console=ttyS1,115200n8</code>。</li><li>这会启用详细日志输出 (<code>loglevel=8</code>)，并将输出同时发送到 <code>tty1</code> 和串口 <code>ttyS1</code>，速率为 115200 波特率，8 个数据位，无校验位，1 个停止位。</li></ul></li><li><p><strong>重新生成 GRUB 配置文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg --update-bls-cmdline</span><br></pre></td></tr></table></figure><p>使用 <code>grub2-mkconfig</code> 生成新的 GRUB 配置文件，并保存到指定路径 <code>/boot/efi/EFI/redhat/grub.cfg</code>。  </p><ul><li>选项 <code>--update-bls-cmdline</code> 用于更新 Boot Loader Specification (BLS) 条目。</li></ul></li></ol><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li><strong>路径正确性</strong>：确保你的 GRUB 配置路径是 <code>/boot/efi/EFI/redhat/grub.cfg</code>。如果你的系统路径不同，需要调整为适合你的实际环境。</li><li><strong>BIOS 或 UEFI</strong>：此路径适用于 UEFI 引导。如果是传统 BIOS 引导，可能需要将配置文件路径修改为 <code>/boot/grub2/grub.cfg</code>。</li><li><strong>备份</strong>：在修改配置前一定要备份，以防止配置错误导致无法启动。</li><li><strong>验证</strong>：修改完成后建议通过以下命令验证是否生效：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&quot;loglevel|console&quot;</span> /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure></li></ul><p>完成以上步骤后，重启系统验证新参数是否生效即可。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> Serial </tag>
            
            <tag> RHEL </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux bridge 与device对应关系</title>
      <link href="/2024/11/24/lspci_bridge_devices/"/>
      <url>/2024/11/24/lspci_bridge_devices/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-bridge-与device对应关系"><a href="#Linux-bridge-与device对应关系" class="headerlink" title="Linux bridge 与device对应关系"></a>Linux bridge 与device对应关系</h1><p><code>lspci</code> 是 Linux 系统中用于列出所有 PCI 设备信息的命令。<code>-t</code> 和 <code>-t -v</code> 是 <code>lspci</code> 命令的两种不同参数组合，它们分别提供不同级别的设备树信息和详细描述。</p><h3 id="1-lspci-t-命令"><a href="#1-lspci-t-命令" class="headerlink" title="1. lspci -t 命令"></a>1. <code>lspci -t</code> 命令</h3><p><code>lspci -t</code> 命令以树状结构的方式显示所有 PCI 设备的层次关系。这种格式有助于了解设备之间的父子关系，例如哪个设备是哪个设备的从属设备。它不显示设备的详细信息，而仅显示设备的层次结构。</p><p><strong>示例输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@DMIT-tigyEICHBB:~# lspci -t</span><br><span class="line">-[0000:00]-+-00.0</span><br><span class="line">           +-01.0</span><br><span class="line">           +-1a.0</span><br><span class="line">           +-1a.1</span><br><span class="line">           +-1a.2</span><br><span class="line">           +-1a.7</span><br><span class="line">           +-1b.0</span><br><span class="line">           +-1c.0-[01]--</span><br><span class="line">           +-1c.1-[02]--</span><br><span class="line">           +-1c.2-[03]--</span><br><span class="line">           +-1c.3-[04]--</span><br><span class="line">           +-1d.0</span><br><span class="line">           +-1d.1</span><br><span class="line">           +-1d.2</span><br><span class="line">           +-1d.7</span><br><span class="line">           +-1e.0-[05-09]--+-01.0-[06]--+-03.0</span><br><span class="line">           |               |            +-04.0</span><br><span class="line">           |               |            +-07.0</span><br><span class="line">           |               |            +-08.0</span><br><span class="line">           |               |            +-0a.0</span><br><span class="line">           |               |            \-12.0</span><br><span class="line">           |               +-02.0-[07]--</span><br><span class="line">           |               +-03.0-[08]--</span><br><span class="line">           |               \-04.0-[09]--</span><br><span class="line">           +-1f.0</span><br><span class="line">           +-1f.2</span><br><span class="line">           \-1f.3</span><br></pre></td></tr></table></figure><p>该输出显示了一个 PCI 设备树的层次结构，其中：</p><ul><li>每个节点代表一个 PCI 设备。</li><li>各级节点之间的连接表示父子设备关系，例如 <code>-[0000:00]-+-00.0</code> 表示设备 <code>00.0</code> 是根设备 <code>0000:00</code> 的子设备。</li></ul><h3 id="2-lspci-t-v-命令"><a href="#2-lspci-t-v-命令" class="headerlink" title="2. lspci -t -v 命令"></a>2. <code>lspci -t -v</code> 命令</h3><p><code>lspci -t -v</code> 命令在显示设备树结构的同时，还提供了更多的详细信息，通常包括每个 PCI 设备的型号、厂商、驱动信息等。这些详细信息有助于进一步了解设备的配置和属性。</p><p><strong>示例输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@DMIT-tigyEICHBB:~# lspci -t -v</span><br><span class="line">-[0000:00]-+-00.0  Intel Corporation 82G33/G31/P35/P31 Express DRAM Controller</span><br><span class="line">           +-01.0  Device 1234:1111</span><br><span class="line">           +-1a.0  Intel Corporation 82801I (ICH9 Family) USB UHCI Controller #4</span><br><span class="line">           +-1a.1  Intel Corporation 82801I (ICH9 Family) USB UHCI Controller #5</span><br><span class="line">           +-1a.2  Intel Corporation 82801I (ICH9 Family) USB UHCI Controller #6</span><br><span class="line">           +-1a.7  Intel Corporation 82801I (ICH9 Family) USB2 EHCI Controller #2</span><br><span class="line">           +-1b.0  Intel Corporation 82801I (ICH9 Family) HD Audio Controller</span><br><span class="line">           +-1c.0-[01]--</span><br><span class="line">           +-1c.1-[02]--</span><br><span class="line">           +-1c.2-[03]--</span><br><span class="line">           +-1c.3-[04]--</span><br><span class="line">           +-1d.0  Intel Corporation 82801I (ICH9 Family) USB UHCI Controller #1</span><br><span class="line">           +-1d.1  Intel Corporation 82801I (ICH9 Family) USB UHCI Controller #2</span><br><span class="line">           +-1d.2  Intel Corporation 82801I (ICH9 Family) USB UHCI Controller #3</span><br><span class="line">           +-1d.7  Intel Corporation 82801I (ICH9 Family) USB2 EHCI Controller #1</span><br><span class="line">           +-1e.0-[05-09]--+-01.0-[06]--+-03.0  Red Hat, Inc. Virtio memory balloon</span><br><span class="line">           |               |            +-04.0  Intel Corporation 6300ESB Watchdog Timer</span><br><span class="line">           |               |            +-07.0  Intel Corporation 82801IR/IO/IH (ICH9R/DO/DH) 6 port SATA Controller [AHCI mode]</span><br><span class="line">           |               |            +-08.0  Red Hat, Inc. Virtio console</span><br><span class="line">           |               |            +-0a.0  Red Hat, Inc. Virtio block device</span><br><span class="line">           |               |            \-12.0  Red Hat, Inc. Virtio network device</span><br><span class="line">           |               +-02.0-[07]--</span><br><span class="line">           |               +-03.0-[08]--</span><br><span class="line">           |               \-04.0-[09]--</span><br><span class="line">           +-1f.0  Intel Corporation 82801IB (ICH9) LPC Interface Controller</span><br><span class="line">           +-1f.2  Intel Corporation 82801IR/IO/IH (ICH9R/DO/DH) 6 port SATA Controller [AHCI mode]</span><br><span class="line">           \-1f.3  Intel Corporation 82801I (ICH9 Family) SMBus Controller</span><br></pre></td></tr></table></figure><p>该输出除了显示设备的树状结构外，还提供了每个 PCI 设备的详细信息，如：</p><ul><li><code>00.0  Intel Corporation 82G33/G31/P35/P31 Express DRAM Controller</code> 表示该设备是 Intel 的 DRAM 控制器。</li><li><code>Device 1234:1111</code> 表示该设备的 PCI 设备和供应商 ID。</li><li><code>Red Hat, Inc. Virtio memory balloon</code> 则显示了虚拟化相关的设备信息。</li></ul><p><code>lspci -t -v -s 06:03.0</code> 这个命令在原有 <code>lspci -t -v</code> 的基础上，加入了 <code>-s</code> 选项，它会显示指定设备的信息。<code>-s</code> 后面跟的是设备的 PCI 地址。具体来说，<code>06:03.0</code> 是一个 PCI 设备的地址，表示该设备位于总线 06 上，设备编号为 03（即 <code>06:03.0</code>）。我们可以通过这个命令来获取该设备的详细信息。</p><h3 id="3-lspci-t-v-s-命令"><a href="#3-lspci-t-v-s-命令" class="headerlink" title="3. lspci -t -v -s 命令"></a>3. <code>lspci -t -v -s</code> 命令</h3><p>这个命令会先展示 PCI 树的层级结构，然后显示设备 的详细信息。具体扩展如下：</p><ol><li><p><strong>树形结构</strong>：<br>在 <code>lspci -t</code> 命令中，每个设备的层级关系是通过 PCI 总线地址来表示的。树形结构帮助我们了解设备在 PCI 总线上的层级和依赖关系。</p></li><li><p><strong><code>-s</code> 选项</strong>：<br><code>-s</code> 选项用于筛选和指定某个设备。它后面跟的是 PCI 地址（如 <code>06:03.0</code>），表示我们只查看这个具体设备的详细信息。</p></li><li><p><strong>设备详细信息</strong>：<br>在使用 <code>-v</code> 选项时，输出会显示设备的详细信息，例如厂商 ID、设备 ID、设备功能、资源分配等。</p></li></ol><h4 id="举个例子，假设我们运行命令："><a href="#举个例子，假设我们运行命令：" class="headerlink" title="举个例子，假设我们运行命令："></a>举个例子，假设我们运行命令：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -t -v -s 06:03.0</span><br></pre></td></tr></table></figure><p>输出可能类似于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[0000:06]--+-03.0  Red Hat, Inc. Virtio network device</span><br><span class="line">           +-03.1  Intel Corporation 82801IR/IO/IH (ICH9R/DO/DH) 6 port SATA Controller [AHCI mode]</span><br></pre></td></tr></table></figure><ul><li><code>-[0000:06]</code> 表示 PCI 总线 06。</li><li><code>+-03.0</code> 设备位于总线 06 上，编号为 03，设备是 Red Hat 的 Virtio 网络设备。</li><li><code>-03.1</code> 表示另外一个设备，也是 PCI 总线 06 上的一个设备，设备编号为 03.1。</li><li><strong><code>lspci -t -v -s &lt;address&gt;</code></strong> 命令可以让你查看 PCI 设备树的层级结构并获取指定设备的详细信息。</li><li>使用 <code>-v</code> 选项时，可以看到每个设备的详细属性，比如设备类型、资源分配、驱动程序等。</li><li><code>-s</code> 选项用于指定设备地址，从而查看该设备的具体信息。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TPM数据封存与解封</title>
      <link href="/2024/11/07/tpm_seal_and_unseal/"/>
      <url>/2024/11/07/tpm_seal_and_unseal/</url>
      
        <content type="html"><![CDATA[<h1 id="TPM-数据封存与解封"><a href="#TPM-数据封存与解封" class="headerlink" title="TPM 数据封存与解封"></a>TPM 数据封存与解封</h1><hr><p>以下是两种使用 TPM 封存和解封数据的方法，一种是使用自定义的 Primary Key 作为父密钥，另一种是使用 Endorsement Key (EK) 和 Storage Root Key (SRK) 的组合。可以根据需求选择合适的方式。</p><h2 id="方式一：使用-Primary-Key-进行封存和解封"><a href="#方式一：使用-Primary-Key-进行封存和解封" class="headerlink" title="方式一：使用 Primary Key 进行封存和解封"></a>方式一：使用 Primary Key 进行封存和解封</h2><h3 id="1-清除-TPM-并设置密码（如果尚未设置）"><a href="#1-清除-TPM-并设置密码（如果尚未设置）" class="headerlink" title="1. 清除 TPM 并设置密码（如果尚未设置）"></a>1. 清除 TPM 并设置密码（如果尚未设置）</h3><p>确保 TPM 的状态是清除的，并设置 Owner 密码（例如 <code>111111</code>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tpm2_clear</span><br><span class="line">tpm2_changeauth -c o 111111</span><br></pre></td></tr></table></figure><h3 id="2-创建-Primary-Key"><a href="#2-创建-Primary-Key" class="headerlink" title="2. 创建 Primary Key"></a>2. 创建 Primary Key</h3><p>在 TPM 中创建一个 Primary Key，作为封存对象的父密钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tpm2_createprimary -C o -c primary.ctx -P 111111</span><br></pre></td></tr></table></figure><ul><li><code>-C o</code>：指定使用 Owner 层级。</li><li><code>-c primary.ctx</code>：将 Primary Key 的上下文保存到 <code>primary.ctx</code> 文件中。</li><li><code>-P 111111</code>：设置 Primary Key 的密码。</li></ul><h3 id="3-封存（Seal）数据到-TPM"><a href="#3-封存（Seal）数据到-TPM" class="headerlink" title="3. 封存（Seal）数据到 TPM"></a>3. 封存（Seal）数据到 TPM</h3><p>将要封存的数据（如 <code>secret.txt</code> 文件中的内容）存储到 TPM 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;my_secret_data&quot;</span> &gt; secret.txt</span><br><span class="line">tpm2_create -C primary.ctx -u seal.pub -r seal.priv -i secret.txt</span><br></pre></td></tr></table></figure><ul><li><code>-C primary.ctx</code>：指定使用 Primary Key 作为父密钥。</li><li><code>-u seal.pub</code> 和 <code>-r seal.priv</code>：分别保存生成的公钥和私钥。</li><li><code>-i secret.txt</code>：将 <code>secret.txt</code> 文件中的数据封存到 TPM 中。</li></ul><h3 id="4-加载密钥上下文到-TPM"><a href="#4-加载密钥上下文到-TPM" class="headerlink" title="4. 加载密钥上下文到 TPM"></a>4. 加载密钥上下文到 TPM</h3><p>将封存对象加载到 TPM，以便后续可以进行解封操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tpm2_load -C primary.ctx -u seal.pub -r seal.priv -c seal.ctx</span><br></pre></td></tr></table></figure><ul><li><code>-C primary.ctx</code>：指定使用 Primary Key 作为父密钥。</li><li><code>-u seal.pub</code> 和 <code>-r seal.priv</code>：加载封存对象的公私钥。</li><li><code>-c seal.ctx</code>：生成密钥的上下文文件 <code>seal.ctx</code>。</li></ul><h3 id="5-解封（Unseal）数据"><a href="#5-解封（Unseal）数据" class="headerlink" title="5. 解封（Unseal）数据"></a>5. 解封（Unseal）数据</h3><p>从 TPM 中解封数据并输出到文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tpm2_unseal -c seal.ctx &gt; unsealed_data.txt</span><br></pre></td></tr></table></figure><ul><li><code>-c seal.ctx</code>：指定封存对象的上下文文件。</li><li><code>&gt; unsealed_data.txt</code>：将解封的数据保存到 <code>unsealed_data.txt</code> 文件中。</li></ul><hr><h1 id="方式二：使用-Endorsement-Key-EK-和-Storage-Root-Key-SRK-进行封存和解封"><a href="#方式二：使用-Endorsement-Key-EK-和-Storage-Root-Key-SRK-进行封存和解封" class="headerlink" title="方式二：使用 Endorsement Key (EK) 和 Storage Root Key (SRK) 进行封存和解封"></a>方式二：使用 Endorsement Key (EK) 和 Storage Root Key (SRK) 进行封存和解封</h1><h3 id="1-清除-TPM-并设置密码"><a href="#1-清除-TPM-并设置密码" class="headerlink" title="1. 清除 TPM 并设置密码"></a>1. 清除 TPM 并设置密码</h3><p>清除 TPM，确保 TPM 的状态是干净的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tpm2_clear</span><br><span class="line">tpm2_changeauth -c o 111111</span><br><span class="line">tpm2_changeauth -c e 111111</span><br></pre></td></tr></table></figure><ul><li><code>tpm2_clear</code>：清除 TPM。</li><li><code>tpm2_changeauth -c o 111111</code>：设置 Owner 密码为 <code>111111</code>。</li><li><code>tpm2_changeauth -c e 111111</code>：设置 Endorsement 密码为 <code>111111</code>。</li></ul><h3 id="2-创建-Endorsement-Key-EK"><a href="#2-创建-Endorsement-Key-EK" class="headerlink" title="2. 创建 Endorsement Key (EK)"></a>2. 创建 Endorsement Key (EK)</h3><p>生成 Endorsement Key (EK) 并保存其上下文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tpm2_createek --ek-context ek.ctx --key-algorithm rsa -P 111111</span><br></pre></td></tr></table></figure><ul><li><code>--ek-context ek.ctx</code>：将 EK 上下文保存到 <code>ek.ctx</code> 文件中。</li><li><code>--key-algorithm rsa</code>：指定密钥算法为 RSA。</li><li><code>-P 111111</code>：为 EK 设置密码。</li></ul><h3 id="3-创建-Storage-Root-Key-SRK"><a href="#3-创建-Storage-Root-Key-SRK" class="headerlink" title="3. 创建 Storage Root Key (SRK)"></a>3. 创建 Storage Root Key (SRK)</h3><p>基于 EK 创建 Storage Root Key (SRK)，将其上下文保存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tpm2_createprimary -C e -c srk.ctx -P 111111</span><br></pre></td></tr></table></figure><ul><li><code>-C e</code>：指定使用 EK（Endorsement）作为父密钥。</li><li><code>-c srk.ctx</code>：将 SRK 的上下文保存到 <code>srk.ctx</code> 文件中。</li><li><code>-P 111111</code>：设置 SRK 的密码。</li></ul><h3 id="4-封存（Seal）数据"><a href="#4-封存（Seal）数据" class="headerlink" title="4. 封存（Seal）数据"></a>4. 封存（Seal）数据</h3><p>将要封存的数据（如 <code>secret.txt</code> 文件中的内容）存储到 TPM 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;my_secret_data&quot;</span> &gt; secret.txt</span><br><span class="line">tpm2_create -C srk.ctx -u seal.pub -r seal.priv -i secret.txt</span><br></pre></td></tr></table></figure><ul><li><code>-C srk.ctx</code>：指定 SRK 作为父密钥。</li><li><code>-u seal.pub</code> 和 <code>-r seal.priv</code>：分别保存生成的公钥和私钥。</li><li><code>-i secret.txt</code>：将 <code>secret.txt</code> 文件中的数据封存到 TPM 中。</li></ul><h3 id="5-加载密钥上下文"><a href="#5-加载密钥上下文" class="headerlink" title="5. 加载密钥上下文"></a>5. 加载密钥上下文</h3><p>将封存对象加载到 TPM，以便后续解封操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tpm2_load -C srk.ctx -u seal.pub -r seal.priv -c seal.ctx</span><br></pre></td></tr></table></figure><ul><li><code>-C srk.ctx</code>：指定 SRK 作为父密钥。</li><li><code>-u seal.pub</code> 和 <code>-r seal.priv</code>：加载封存对象的公私钥。</li><li><code>-c seal.ctx</code>：生成密钥的上下文文件 <code>seal.ctx</code>。</li></ul><h3 id="6-解封（Unseal）数据"><a href="#6-解封（Unseal）数据" class="headerlink" title="6. 解封（Unseal）数据"></a>6. 解封（Unseal）数据</h3><p>从 TPM 中解封数据并输出到文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tpm2_unseal -c seal.ctx &gt; unsealed_data.txt</span><br></pre></td></tr></table></figure><ul><li><code>-c seal.ctx</code>：指定封存对象的上下文文件。</li><li><code>&gt; unsealed_data.txt</code>：将解封的数据保存到 <code>unsealed_data.txt</code> 文件中。</li></ul><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><strong>方式一</strong> 使用自定义的 Primary Key 进行封存和解封，适合自定义管理密钥层级。</li><li><strong>方式二</strong> 使用 EK 和 SRK 进行封存和解封，适合 TPM 内部的密钥管理流程。</li></ul><p>根据应用需求选择其中一种方式即可实现 TPM 的数据封存与解封操作。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> TPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NVIDIA 交换机快速配置 - Cumulus Linux</title>
      <link href="/2024/10/31/nvidia_switch_quick_start/"/>
      <url>/2024/10/31/nvidia_switch_quick_start/</url>
      
        <content type="html"><![CDATA[<h1 id="NVIDIA-交换机快速配置-Cumulus-Linux"><a href="#NVIDIA-交换机快速配置-Cumulus-Linux" class="headerlink" title="NVIDIA 交换机快速配置 - Cumulus Linux"></a>NVIDIA 交换机快速配置 - Cumulus Linux</h1><ol><li><p><strong>设置接口到桥接域</strong>：</p><ul><li><p>查看端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Brctl show</span><br></pre></td></tr></table></figure></li><li><p>查看交接机端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net show interface all</span><br></pre></td></tr></table></figure></li><li><p>将接口 <code>swp1</code> 到 <code>swp3</code> 添加到桥接域 <code>br_default</code> 中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nv <span class="built_in">set</span> interface swp1-3 bridge domain br_default</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>设置桥接域中的VLAN</strong>：</p><ul><li>为桥接域 <code>br_default</code> 配置 VLAN 10 和 VLAN 20。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nv <span class="built_in">set</span> bridge domain br_default vlan 10,20</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>设置无标签VLAN（untagged VLAN）</strong>：</p><ul><li>将 VLAN 1 设为无标签 VLAN，适用于默认VLAN不打标签的情况。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nv <span class="built_in">set</span> bridge domain br_default untagged 1</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>为单个接口设置VLAN</strong>：</p><ul><li>将接口 <code>swp3</code> 添加到桥接域 <code>br_default</code> 中，并指定为 VLAN 20。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nv <span class="built_in">set</span> interface swp3 bridge domain br_default vlan 20</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>应用并保存配置</strong>：</p><ul><li>应用以上配置，确保配置生效。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nv config apply</span><br><span class="line">nv config save</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> CumulusLinux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCIe高级错误报告</title>
      <link href="/2024/10/31/pcie_aer/"/>
      <url>/2024/10/31/pcie_aer/</url>
      
        <content type="html"><![CDATA[<h1 id="PCIe高级错误报告（AER）"><a href="#PCIe高级错误报告（AER）" class="headerlink" title="PCIe高级错误报告（AER）"></a>PCIe高级错误报告（AER）</h1><p>PCIe（Peripheral Component Interconnect Express）高级错误报告（AER）是一种机制，用于监控和报告在PCIe设备和链路上发生的错误。AER旨在提供更详细的错误信息，从而帮助工程师快速识别和解决问题。</p><h2 id="AER-的主要功能"><a href="#AER-的主要功能" class="headerlink" title="AER 的主要功能"></a>AER 的主要功能</h2><ol><li><strong>错误检测</strong>：实时监测PCIe设备中的错误情况。</li><li><strong>错误报告</strong>：通过状态寄存器报告不同类型的错误。</li><li><strong>错误处理</strong>：支持自动或手动错误恢复机制。</li></ol><h2 id="AER-寄存器"><a href="#AER-寄存器" class="headerlink" title="AER 寄存器"></a>AER 寄存器</h2><p>AER通过几个关键寄存器来实现其功能：</p><ol><li><p><strong>UESta（不可校正错误状态寄存器）</strong>：</p><ul><li><p>指示发生的不可校正错误类型，包括多个错误类型的位域。</p></li><li><p><strong>功能</strong>：用于指示不可校正错误的状态。</p></li><li><p><strong>寄存器字段</strong>：</p><ul><li><strong>Bit 0</strong>：<strong>不可校正错误检测</strong>。设置为1表示检测到不可校正错误。</li><li><strong>Bit 1</strong>：<strong>事务层超时</strong>。表示事务层操作超时。</li><li><strong>Bit 2</strong>：<strong>接收器溢出</strong>。指示接收器缓冲区溢出。</li><li><strong>Bit 3</strong>：<strong>格式错误的TLP</strong>。表示收到格式错误的事务层包（TLP）。</li><li><strong>Bit 4</strong>：<strong>ECRC错误</strong>。指示外部循环冗余校验失败。</li><li><strong>Bit 5</strong>：<strong>不支持的请求</strong>。表示收到不支持的请求类型。</li><li><strong>Bit 6</strong>：<strong>AER不可校正错误</strong>。通过AER报告的不可校正错误。</li></ul></li><li><p>示例：<code>UESta: DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-</code> 表示当前没有检测到不可校正错误。</p></li></ul></li><li><p><strong>UEMsk（不可校正错误掩码寄存器）</strong>：</p><ul><li><p>控制哪些不可校正错误被掩码（忽略）。</p></li><li><p><strong>功能</strong>：控制哪些不可校正错误可以被报告。</p></li><li><p><strong>寄存器字段</strong>：</p><ul><li><strong>Bit 0</strong>：<strong>不可校正错误掩码</strong>。设置为1表示掩码此类错误。</li><li><strong>Bit 1</strong>：<strong>事务层超时掩码</strong>。</li><li><strong>Bit 2</strong>：<strong>接收器溢出掩码</strong>。</li><li><strong>Bit 3</strong>：<strong>格式错误的TLP掩码</strong>。</li><li><strong>Bit 4</strong>：<strong>ECRC错误掩码</strong>。</li><li><strong>Bit 5</strong>：<strong>不支持的请求错误掩码</strong>。</li></ul></li><li><p>示例：<code>UEMsk: DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-</code> 表示没有错误被掩码，所有不可校正错误均可报告。</p></li></ul></li><li><p><strong>UESvrt（不可校正错误服务寄存器）</strong>：</p><ul><li>指示哪些不可校正错误已被处理。</li><li>示例：<code>UESvrt: DLP+ SDES+ TLP- FCP+</code> 表示DLP和FCP错误已被处理。</li></ul></li><li><p><strong>CESta（可校正错误状态寄存器）</strong>：</p><ul><li><p>指示发生的可校正错误类型。</p></li><li><p><strong>功能</strong>：用于报告可校正错误的状态。</p></li><li><p><strong>寄存器字段</strong>：</p><ul><li><strong>Bit 0</strong>：<strong>可校正错误检测</strong>。设置为1表示检测到可校正错误。</li><li><strong>Bit 1</strong>：<strong>数据链路层可校正错误</strong>。</li><li><strong>Bit 2</strong>：<strong>重播超时错误</strong>。</li><li><strong>Bit 3</strong>：<strong>接收错误</strong>。</li><li><strong>Bit 4</strong>：<strong>格式错误的TLP</strong>。</li><li><strong>Bit 5</strong>：<strong>ECRC错误</strong>。</li><li><strong>Bit 6</strong>：<strong>不支持的请求错误</strong>。</li></ul></li><li><p>示例：<code>CESta: RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr-</code> 表示当前没有可校正错误被检测到。</p></li></ul></li><li><p><strong>CEMsk（可校正错误掩码寄存器）</strong>：</p><ul><li><p>控制哪些可校正错误被掩码。</p></li><li><p><strong>功能</strong>：控制哪些可校正错误可以被报告。</p></li><li><p><strong>寄存器字段</strong>：</p><ul><li><strong>Bit 0</strong>：<strong>可校正错误掩码</strong>。设置为1表示掩码此类错误。</li><li><strong>Bit 1</strong>：<strong>数据链路层错误掩码</strong>。</li><li><strong>Bit 2</strong>：<strong>重播超时错误掩码</strong>。</li><li><strong>Bit 3</strong>：<strong>接收错误掩码</strong>。</li><li><strong>Bit 4</strong>：<strong>格式错误的TLP掩码</strong>。</li><li><strong>Bit 5</strong>：<strong>ECRC错误掩码</strong>。</li></ul></li><li><p>示例：<code>CEMsk: RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+</code> 表示所有可校正错误均可报告，但<code>AdvNonFatalErr</code>将被掩码。</p></li></ul></li><li><p><strong>AERCap（AER能力寄存器）</strong>：</p><ul><li>提供设备支持的AER功能的详细信息，如ECRC生成和检查能力。</li><li>示例：<code>AERCap: First Error Pointer: 00, ECRCGenCap+ ECRCGenEn-</code> 表示设备支持ECRC生成但未启用。</li></ul></li><li><p><strong>HeaderLog（头部日志）</strong>：</p><ul><li>用于记录错误的日志，帮助故障排查。</li><li>示例：<code>HeaderLog: 00000000 00000000 00000000 00000000</code> 表示当前没有错误日志。</li></ul></li><li><p><strong>RootCmd（根命令寄存器）</strong>：</p><ul><li>控制根复杂设备的错误报告功能。</li><li>示例：<code>RootCmd: CERptEn+ NFERptEn+ FERptEn+</code> 表示所有错误报告功能已启用。</li></ul></li><li><p><strong>RootSta（根状态寄存器）</strong>：</p><ul><li>显示接收到的错误消息的状态。</li><li>示例：<code>RootSta: CERcvd- MultCERcvd- UERcvd-</code> 表示没有接收到错误消息。</li></ul></li><li><p><strong>ErrorSrc（错误源寄存器）</strong>：</p><ul><li>指示当前的错误来源，包括可校正和不可校正错误。</li><li>示例：<code>ErrorSrc: ERR_COR: 0000 ERR_FATAL/NONFATAL: 0000</code> 表示没有检测到可校正或不可校正错误来源。</li></ul></li></ol><h2 id="常见错误类型"><a href="#常见错误类型" class="headerlink" title="常见错误类型"></a>常见错误类型</h2><p>在AER报告中，错误类型通常以缩写形式列出，具体包括：</p><ol><li><p><strong>DLP</strong> (Data Link Protocol Error)</p><ul><li>指数据链路层协议错误，这类错误通常是由于数据包在传输过程中未能成功到达目标。</li></ul></li><li><p><strong>SDES</strong> (Surprise Down Error Status)</p><ul><li>表示突发断开错误状态，通常是由于设备突然失去连接或出现故障引起的。</li></ul></li><li><p><strong>TLP</strong> (Transaction Layer Protocol Error)</p><ul><li>指事务层协议错误，通常涉及到数据包的事务处理过程中的错误。</li></ul></li><li><p><strong>FCP</strong> (Flow Control Protocol Error)</p><ul><li>指流控制协议错误，这种错误可能发生在流控制机制出现问题时，例如未能正确地发送或接收流控制信号。</li></ul></li><li><p><strong>CmpltTO</strong> (Completion Timeout)</p><ul><li>表示完成超时，通常是指在规定时间内未能收到请求的操作的完成响应。</li></ul></li><li><p><strong>CmpltAbrt</strong> (Completion Aborted)</p><ul><li>指完成操作被中止，可能由于设备错误或其他原因导致请求未能成功完成。</li></ul></li><li><p><strong>UnxCmplt</strong> (Unexpected Completion)</p><ul><li>表示意外的完成，通常是指收到的完成包与发出的请求不匹配。</li></ul></li><li><p><strong>RxOF</strong> (Receive Overflow)</p><ul><li>表示接收溢出，通常发生在接收缓冲区已满但仍尝试接收更多数据时。</li></ul></li><li><p><strong>MalfTLP</strong> (Malformed TLP)</p><ul><li>指格式错误的事务层包（TLP），这通常意味着包的结构不符合协议规范。</li></ul></li><li><p><strong>ECRC</strong> (ECRC Error)</p><ul><li>指ECRC（End-to-End CRC）错误，这是数据完整性检查的一部分，当发现数据传输错误时会触发。</li></ul></li><li><p><strong>UnsupReq</strong> (Unsupported Request)</p><ul><li>表示收到不支持的请求，可能是因为设备不支持该请求的类型或参数。</li></ul></li><li><p><strong>ACSViol</strong> (Access Control Service Violation)</p><ul><li>指访问控制服务违规，通常涉及安全或权限问题，表示某个操作未能遵循预定义的访问控制规则。</li></ul></li></ol><h2 id="错误处理流程"><a href="#错误处理流程" class="headerlink" title="错误处理流程"></a>错误处理流程</h2><p>AER机制的有效性依赖于对寄存器的监控与响应，以下是一个典型的错误处理流程：</p><h3 id="步骤-1：检测错误"><a href="#步骤-1：检测错误" class="headerlink" title="步骤 1：检测错误"></a>步骤 1：检测错误</h3><p>使用<code>lspci</code>命令查看设备的错误状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -vvv -s &lt;device_id&gt;</span><br></pre></td></tr></table></figure><p>在输出中，查找<code>CESta</code>和<code>CEMsk</code>、<code>UESta</code>和<code>UEMsk</code>部分。</p><h3 id="步骤-2：分析寄存器状态"><a href="#步骤-2：分析寄存器状态" class="headerlink" title="步骤 2：分析寄存器状态"></a>步骤 2：分析寄存器状态</h3><ul><li><strong>CESta</strong>：检查哪些可校正错误被检测到。</li><li><strong>CEMsk</strong>：检查哪些可校正错误被掩码。</li><li><strong>UESta</strong>：检查哪些不可校正错误被检测到。</li><li><strong>UEMsk</strong>：检查哪些不可校正错误被掩码。</li></ul><h3 id="步骤-3：判断和响应"><a href="#步骤-3：判断和响应" class="headerlink" title="步骤 3：判断和响应"></a>步骤 3：判断和响应</h3><ul><li><p><strong>对于可校正错误</strong>：</p><ul><li>如果<code>CESta</code>中的位为1且<code>CEMsk</code>中的对应位为0，表示该可校正错误被检测到并会被报告。可以考虑记录该错误并分析原因。</li><li>如果<code>CEMsk</code>中的位为1，表示该错误被掩码，主机不会报告。可以根据需求决定是否解除掩码。</li></ul></li><li><p><strong>对于不可校正错误</strong>：</p><ul><li>如果<code>UESta</code>中的位为1且<code>UEMsk</code>中的对应位为0，表示检测到不可校正错误并将被报告。这通常需要更紧急的响应，例如设备重置或硬件检查。</li><li>如果<code>UEMsk</code>中的位为1，表示该错误被掩码，不会被报告。此时可以考虑是否需要调整掩码设置以捕获重要的错误信息。</li></ul></li></ul><h2 id="使用-lspci-检查-AER-状态"><a href="#使用-lspci-检查-AER-状态" class="headerlink" title="使用 lspci 检查 AER 状态"></a>使用 <code>lspci</code> 检查 AER 状态</h2><p>可以使用<code>lspci</code>命令来查看PCIe设备的AER状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -vvv -s &lt;device_id&gt;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="AER-状态分析"><a href="#AER-状态分析" class="headerlink" title="AER 状态分析"></a>AER 状态分析</h3><h4 id="1-AER-能力（Capabilities）"><a href="#1-AER-能力（Capabilities）" class="headerlink" title="1. AER 能力（Capabilities）"></a>1. AER 能力（Capabilities）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Capabilities: [100 v2] Advanced Error Reporting</span><br></pre></td></tr></table></figure><ul><li>这表示设备支持AER，并且是版本2。</li></ul><h4 id="2-不可校正错误状态寄存器（UESta）"><a href="#2-不可校正错误状态寄存器（UESta）" class="headerlink" title="2. 不可校正错误状态寄存器（UESta）"></a>2. 不可校正错误状态寄存器（UESta）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UESta:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-</span><br></pre></td></tr></table></figure><ul><li>此寄存器用于指示是否检测到不可校正错误。</li><li><code>DLP-</code>、<code>SDES-</code>等前面的<code>-</code>表示这些错误类型未被检测到。</li><li>所有项均未设置，表示当前没有不可校正错误。</li></ul><h4 id="3-不可校正错误掩码寄存器（UEMsk）"><a href="#3-不可校正错误掩码寄存器（UEMsk）" class="headerlink" title="3. 不可校正错误掩码寄存器（UEMsk）"></a>3. 不可校正错误掩码寄存器（UEMsk）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UEMsk:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-</span><br></pre></td></tr></table></figure><ul><li>此寄存器控制哪些不可校正错误被掩码。</li><li>同样，所有项前的<code>-</code>表示没有错误被掩码，所有不可校正错误均可报告。</li></ul><h4 id="4-不可校正错误源寄存器（UESvrt）"><a href="#4-不可校正错误源寄存器（UESvrt）" class="headerlink" title="4. 不可校正错误源寄存器（UESvrt）"></a>4. 不可校正错误源寄存器（UESvrt）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UESvrt: DLP+ SDES+ TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol-</span><br></pre></td></tr></table></figure><ul><li>此寄存器表示哪些不可校正错误被服务。</li><li><code>DLP+</code>、<code>FCP+</code>、<code>RxOF+</code>、<code>MalfTLP+</code>表示这些错误类型已被服务（即被处理）。</li><li>其他项未被服务，表示没有检测到这些类型的错误。</li></ul><h4 id="5-可校正错误状态寄存器（CESta）"><a href="#5-可校正错误状态寄存器（CESta）" class="headerlink" title="5. 可校正错误状态寄存器（CESta）"></a>5. 可校正错误状态寄存器（CESta）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CESta:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr-</span><br></pre></td></tr></table></figure><ul><li>该寄存器显示检测到的可校正错误状态。</li><li>所有项均为<code>-</code>，表示当前没有可校正错误被检测到。</li></ul><h4 id="6-可校正错误掩码寄存器（CEMsk）"><a href="#6-可校正错误掩码寄存器（CEMsk）" class="headerlink" title="6. 可校正错误掩码寄存器（CEMsk）"></a>6. 可校正错误掩码寄存器（CEMsk）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CEMsk:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+</span><br></pre></td></tr></table></figure><ul><li>此寄存器控制哪些可校正错误被掩码。</li><li>除了<code>AdvNonFatalErr+</code>外，其他项均为<code>-</code>，表示所有其他类型的可校正错误将被报告。</li></ul><h4 id="7-AER-能力寄存器（AERCap）"><a href="#7-AER-能力寄存器（AERCap）" class="headerlink" title="7. AER 能力寄存器（AERCap）"></a>7. AER 能力寄存器（AERCap）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AERCap: First Error Pointer: 00, ECRCGenCap+ ECRCGenEn- ECRCChkCap+ ECRCChkEn-</span><br><span class="line">        MultHdrRecCap+ MultHdrRecEn- TLPPfxPres- HdrLogCap-</span><br></pre></td></tr></table></figure><ul><li><strong>First Error Pointer</strong>: 00 — 表示最近的错误指针位置。</li><li><strong>ECRCGenCap+</strong>: 支持生成ECRC。</li><li><strong>ECRCGenEn-</strong>: 生成ECRC功能未启用。</li><li><strong>ECRCChkCap+</strong>: 支持ECRC检查。</li><li><strong>ECRCChkEn-</strong>: ECRC检查功能未启用。</li><li><strong>MultHdrRecCap+</strong>: 支持多个头部接收。</li><li><strong>MultHdrRecEn-</strong>: 多个头部接收功能未启用。</li><li><strong>TLPPfxPres</strong>: 事务层前缀保留功能。</li><li><strong>HdrLogCap-</strong>: 头部日志能力未启用。</li></ul><h4 id="8-头部日志（HeaderLog）"><a href="#8-头部日志（HeaderLog）" class="headerlink" title="8. 头部日志（HeaderLog）"></a>8. 头部日志（HeaderLog）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HeaderLog: 00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure><ul><li>头部日志显示为零，表示没有错误日志可用。</li></ul><h4 id="9-根命令（RootCmd）"><a href="#9-根命令（RootCmd）" class="headerlink" title="9. 根命令（RootCmd）"></a>9. 根命令（RootCmd）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RootCmd: CERptEn+ NFERptEn+ FERptEn+</span><br></pre></td></tr></table></figure><ul><li>指示根命令的错误报告功能均已启用（CERptEn、NFERptEn、FERptEn）。</li></ul><h4 id="10-根状态（RootSta）"><a href="#10-根状态（RootSta）" class="headerlink" title="10. 根状态（RootSta）"></a>10. 根状态（RootSta）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RootSta: CERcvd- MultCERcvd- UERcvd- MultUERcvd-</span><br><span class="line">         FirstFatal- NonFatalMsg- FatalMsg- IntMsg 0</span><br></pre></td></tr></table></figure><ul><li>这些字段指示各种错误状态。当前无错误被接收（CERcvd-、UERcvd-）。</li></ul><h4 id="11-错误源（ErrorSrc）"><a href="#11-错误源（ErrorSrc）" class="headerlink" title="11. 错误源（ErrorSrc）"></a>11. 错误源（ErrorSrc）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ErrorSrc: ERR_COR: 0000 ERR_FATAL/NONFATAL: 0000</span><br></pre></td></tr></table></figure><ul><li>表示当前没有可校正错误和不可校正错误来源。</li></ul><h3 id="示例分析1"><a href="#示例分析1" class="headerlink" title="示例分析1"></a>示例分析1</h3><p>假设读取到的寄存器状态如下：</p><ul><li><code>CESta</code>: <code>00000111</code>（可校正错误位0、1和2被设置）</li><li><code>CEMsk</code>: <code>00000001</code>（可校正错误掩码位0被设置）</li><li><code>UESta</code>: <code>00000001</code>（不可校正错误位0被设置）</li><li><code>UEMsk</code>: <code>00000000</code>（不可校正错误掩码位0未设置）</li></ul><p><strong>分析</strong>：</p><ul><li><p><strong>可校正错误</strong>：</p><ul><li><code>CESta</code>中的Bit 0（可校正错误检测）为1，表示检测到可校正错误，但由于<code>CEMsk</code>中对应位为1，因此不会报告。</li><li><code>CESta</code>中的Bit 1和2为1，表示数据链路层可校正错误和重播超时错误被检测到，且<code>CEMsk</code>中的对应位均为0，这些错误将被报告。</li></ul></li><li><p><strong>不可校正错误</strong>：</p><ul><li><code>UESta</code>中的Bit 0（不可校正错误检测）为1且<code>UEMsk</code>中对应位为0，表示检测到不可校正错误并将被报告。这需要立即关注和处理。</li></ul></li></ul><h3 id="示例分析2"><a href="#示例分析2" class="headerlink" title="示例分析2"></a>示例分析2</h3><p>假设运行<code>lspci -vvv -s 00:1f.6</code>，得到以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Capabilities: [100 v2] Advanced Error Reporting</span><br><span class="line">    UESta:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-</span><br><span class="line">    UEMsk:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-</span><br><span class="line">    CESta:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr-</span><br><span class="line">    CEMsk:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+</span><br><span class="line">    AERCap: First Error Pointer: 00, ECRCGenCap+ ECRCGenEn- ECRCChkCap+ ECRCChkEn-</span><br><span class="line">            MultHdrRecCap+ MultHdrRecEn- TLPPfxPres- HdrLogCap-</span><br><span class="line">    HeaderLog: 00000000 00000000 00000000 00000000</span><br><span class="line">    RootCmd: CERptEn+ NFERptEn+ FERptEn+</span><br><span class="line">    RootSta: CERcvd- MultCERcvd- UERcvd- MultUERcvd-</span><br><span class="line">             FirstFatal- NonFatalMsg- FatalMsg- IntMsg 0</span><br><span class="line">    ErrorSrc: ERR_COR: 0000 ERR_FATAL/NONFATAL: 0000</span><br></pre></td></tr></table></figure><ul><li><strong>UESta</strong>：无不可校正错误。</li><li><strong>UEMsk</strong>：所有不可校正错误可报告。</li><li><strong>CESta</strong>：无可校正错误。</li><li><strong>CEMsk</strong>：大部分可校正错误可报告。</li><li><strong>AERCap</strong>：显示支持的AER功能，如ECRC。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PCIe AER是一个强大的工具，用于检测和报告PCIe设备的错误。通过监控AER寄存器，能够及时发现和处理潜在的问题，确保系统的稳定性和性能。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> AER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux搭建HTTP代理服务器</title>
      <link href="/2024/10/31/proxy_server_setup/"/>
      <url>/2024/10/31/proxy_server_setup/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux搭建HTTP代理服务器"><a href="#Linux搭建HTTP代理服务器" class="headerlink" title="Linux搭建HTTP代理服务器"></a>Linux搭建HTTP代理服务器</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在 Ubuntu 和 RHEL 系统上搭建代理服务器并配置防火墙，以确保网络安全和访问控制。本文主要使用 Squid 作为代理服务器软件，并使用 UFW（Ubuntu）和 firewalld（RHEL）来管理防火墙。</p><h2 id="2-范围"><a href="#2-范围" class="headerlink" title="2. 范围"></a>2. 范围</h2><p>适用于希望通过代理服务器安全地访问互联网的用户和组织，适合 Ubuntu 和 RHEL 系统。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>系统管理员</strong>：负责安装和配置代理服务器及防火墙，确保其安全性和正常运行。</li><li><strong>用户</strong>：负责通过代理服务器访问互联网，并遵循公司网络安全政策。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>具备 Ubuntu 或 RHEL 操作系统的服务器或计算机。</li><li>具备管理员权限。</li></ul><h2 id="5-过程"><a href="#5-过程" class="headerlink" title="5. 过程"></a>5. 过程</h2><h3 id="步骤-1-更新系统"><a href="#步骤-1-更新系统" class="headerlink" title="步骤 1: 更新系统"></a>步骤 1: 更新系统</h3><p>在终端中运行以下命令以确保系统软件包是最新的：</p><ul><li><p><strong>Ubuntu</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade -y</span><br></pre></td></tr></table></figure></li><li><p><strong>RHEL</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update -y</span><br></pre></td></tr></table></figure></li></ul><h3 id="步骤-2-安装-Squid"><a href="#步骤-2-安装-Squid" class="headerlink" title="步骤 2: 安装 Squid"></a>步骤 2: 安装 Squid</h3><p>在终端中运行以下命令以安装 Squid：</p><ul><li><p><strong>Ubuntu</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install squid -y</span><br></pre></td></tr></table></figure></li><li><p><strong>RHEL</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install squid -y</span><br></pre></td></tr></table></figure></li></ul><h3 id="步骤-3-配置-Squid"><a href="#步骤-3-配置-Squid" class="headerlink" title="步骤 3: 配置 Squid"></a>步骤 3: 配置 Squid</h3><ol><li>编辑 Squid 配置文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/squid/squid.conf</span><br></pre></td></tr></table></figure></li><li>配置访问控制列表（ACL）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acl localnet src 192.168.1.0/24  # 适配局域网IP段</span><br><span class="line">http_access allow localnet</span><br><span class="line">http_access deny all</span><br></pre></td></tr></table></figure></li><li>设置代理端口（默认为 3128）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_port 3128</span><br></pre></td></tr></table></figure></li></ol><h3 id="步骤-4-安装和配置防火墙"><a href="#步骤-4-安装和配置防火墙" class="headerlink" title="步骤 4: 安装和配置防火墙"></a>步骤 4: 安装和配置防火墙</h3><ul><li><p><strong>Ubuntu 使用 UFW</strong>:</p><ol><li>安装 UFW（如果未安装）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ufw -y</span><br></pre></td></tr></table></figure></li><li>允许通过代理端口访问：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 3128/tcp</span><br></pre></td></tr></table></figure></li><li>启用 UFW：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure></li><li>检查 UFW 状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>RHEL 使用 firewalld</strong>:</p><ol><li>启用 firewalld：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start firewalld</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> firewalld</span><br></pre></td></tr></table></figure></li><li>允许通过代理端口访问：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=3128/tcp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li>检查 firewalld 状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --state</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="步骤-5-重启-Squid-服务"><a href="#步骤-5-重启-Squid-服务" class="headerlink" title="步骤 5: 重启 Squid 服务"></a>步骤 5: 重启 Squid 服务</h3><p>在修改配置后，重启 Squid 以应用更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart squid</span><br></pre></td></tr></table></figure><h3 id="步骤-6-检查-Squid-状态"><a href="#步骤-6-检查-Squid-状态" class="headerlink" title="步骤 6: 检查 Squid 状态"></a>步骤 6: 检查 Squid 状态</h3><p>确保 Squid 正在运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status squid</span><br></pre></td></tr></table></figure><h3 id="步骤-7-配置客户端"><a href="#步骤-7-配置客户端" class="headerlink" title="步骤 7: 配置客户端"></a>步骤 7: 配置客户端</h3><p>在客户端计算机上，将网络代理设置为服务器的 IP 地址和配置的端口（例如，<code>http://&lt;server-ip&gt;:3128</code>）。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cybrix.ai/workflow_diagrams/static/a444ca81-4fd1-4550-8fa9-876bb5205063.png" alt="代理服务器搭建流程图"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Proxy </tag>
            
            <tag> Squid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Linux上使用 `grep`</title>
      <link href="/2024/10/21/linux_grep_command/"/>
      <url>/2024/10/21/linux_grep_command/</url>
      
        <content type="html"><![CDATA[<h1 id="在Linux上使用-grep"><a href="#在Linux上使用-grep" class="headerlink" title="在Linux上使用 grep"></a>在Linux上使用 <code>grep</code></h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>grep</code> 是一个强大的命令行工具，用于搜索文件中的文本模式。通过使用正则表达式，用户可以高效地查找和过滤数据。</p><h2 id="2-范围"><a href="#2-范围" class="headerlink" title="2. 范围"></a>2. 范围</h2><p>适用于需要处理和分析文本数据的用户，包括系统管理员、开发人员和数据分析师。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>用户</strong>：进行 <code>grep</code> 的使用和操作。</li><li><strong>系统管理员</strong>：负责维护系统环境，确保 <code>grep</code> 工具可用。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>系统需安装 Unix&#x2F;Linux 或者支持 <code>grep</code> 命令的环境。</li><li>基础的命令行操作知识。</li></ul><h2 id="5-过程"><a href="#5-过程" class="headerlink" title="5. 过程"></a>5. 过程</h2><h3 id="5-1-基本用法"><a href="#5-1-基本用法" class="headerlink" title="5.1 基本用法"></a>5.1 基本用法</h3><p>使用 <code>grep</code> 命令的基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] <span class="string">&#x27;模式&#x27;</span> 文件名</span><br></pre></td></tr></table></figure><h3 id="5-2-常见选项及示例"><a href="#5-2-常见选项及示例" class="headerlink" title="5.2 常见选项及示例"></a>5.2 常见选项及示例</h3><ol><li><p><strong>忽略大小写</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i <span class="string">&#x27;hello&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>反向匹配</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v <span class="string">&#x27;hello&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>递归搜索</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r <span class="string">&#x27;hello&#x27;</span> /path/to/directory/</span><br></pre></td></tr></table></figure></li><li><p><strong>显示行号</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="string">&#x27;hello&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>列出文件名</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -l <span class="string">&#x27;hello&#x27;</span> *.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>统计匹配行数</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -c <span class="string">&#x27;hello&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>仅显示匹配部分</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -o <span class="string">&#x27;hello&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>高亮匹配部分</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep --color <span class="string">&#x27;hello&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>使用扩展正则表达式</strong>：<br>使用 <code>-E</code> 选项可启用扩展正则表达式，支持更复杂的匹配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;hello|world&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><p><code>-E</code> 参数用于启用扩展正则表达式（ERE），使得可以使用更多复杂的匹配模式。与基本正则表达式（BRE）相比，扩展正则表达式支持更多的元字符和语法简化。</p><p>9.1. <strong>扩展正则表达式的特点</strong></p><ul><li><strong>无需转义的元字符</strong>：在扩展正则表达式中，一些元字符（如 <code>+</code>, <code>?</code>, <code>|</code>, <code>&#123;&#125;</code>）可以直接使用，而不需要用 <code>\</code> 转义。</li></ul><p>9.2. 常见的元字符</p><ul><li><code>|</code>：表示“或”操作符。</li><li><code>+</code>：表示前面的字符可以出现一次或多次。</li><li><code>?</code>：表示前面的字符可以出现零次或一次。</li><li><code>&#123;n&#125;</code>：表示前面的字符出现精确的 n 次。</li><li><code>&#123;n,&#125;</code>：表示前面的字符出现至少 n 次。</li><li><code>&#123;n,m&#125;</code>：表示前面的字符出现 n 次到 m 次。</li></ul><p>9.3. 使用示例</p><ol><li><p><strong>匹配多个词</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;cat|dog&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><p>这将匹配文件中包含“cat”或“dog”的行。</p></li><li><p><strong>匹配一个或多个字符</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;he+llo&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><p>这将匹配“hello”， “heeeeeello”等。</p></li><li><p><strong>匹配可选字符</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;colou?r&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><p>这将匹配“color”或“colour”。</p></li><li><p><strong>使用花括号指定数量</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;a&#123;2,5&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><p>这将匹配包含两个到五个连续“a”的行，如“aa”，“aaa”，“aaaa”，“aaaaa”。</p></li><li><p><strong>组合使用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;^[A-Z]+|[0-9]&#123;3&#125;$&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><p>这将匹配以大写字母开头的行或以三个数字结尾的行。</p></li></ol></li></ol><h3 id="5-3-使用正则表达式"><a href="#5-3-使用正则表达式" class="headerlink" title="5.3 使用正则表达式"></a>5.3 使用正则表达式</h3><p><code>grep</code> 支持基本和扩展的正则表达式，可以进行复杂的匹配：</p><ul><li><strong>匹配任意单个字符</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;h.llo&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><strong>匹配零个或多个字符</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;he*llo&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><strong>匹配行的开头</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;^hello&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><strong>匹配行的结尾</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;hello$&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-4-管道与-grep"><a href="#5-4-管道与-grep" class="headerlink" title="5.4 管道与 grep"></a>5.4 管道与 <code>grep</code></h3><p>可以将其他命令的输出传递给 <code>grep</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep <span class="string">&#x27;nginx&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="5-5-实际应用示例"><a href="#5-5-实际应用示例" class="headerlink" title="5.5 实际应用示例"></a>5.5 实际应用示例</h3><ol><li><p><strong>查找进程</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep <span class="string">&#x27;nginx&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>过滤日志文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f /var/log/syslog | grep <span class="string">&#x27;error&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查看配置文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i <span class="string">&#x27;listen&#x27;</span> /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul><li><a href="https://www.gnu.org/software/grep/manual/grep.html">GNU Grep Manual</a></li><li><a href="https://linuxcommand.org/">Linux Command Line</a></li></ul><p><img src="https://cybrix.ai/workflow_diagrams/static/8e5d225f-1873-4bc3-a9ef-98f192d1f01d.png" alt="grep 使用流程图"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Memory Rank/Channel/DPC</title>
      <link href="/2024/09/25/memory_dpc_rank_channel/"/>
      <url>/2024/09/25/memory_dpc_rank_channel/</url>
      
        <content type="html"><![CDATA[<h1 id="Memory-Rank-Channel-DPC"><a href="#Memory-Rank-Channel-DPC" class="headerlink" title="Memory Rank&#x2F;Channel&#x2F;DPC"></a>Memory Rank&#x2F;Channel&#x2F;DPC</h1><p>内存 <strong>Rank</strong>、<strong>Channel</strong> 和 <strong>DPC（DIMMs per Channel）</strong> 这三个概念一起决定了系统的内存配置、性能和带宽。让我们从各自的定义和相互关系来讨论它们：</p><h3 id="1-Memory-Rank（内存Rank）"><a href="#1-Memory-Rank（内存Rank）" class="headerlink" title="1. Memory Rank（内存Rank）"></a>1. <strong>Memory Rank（内存Rank）</strong></h3><p>内存 Rank 指的是一条内存条上有多少组内存芯片，这些组可以独立访问。Rank 决定了内存条的内部组织结构。</p><ul><li>**Single Rank (单Rank)**：一条内存条中的内存芯片被划分为一个逻辑组，所有芯片可以同时被访问。</li><li>**Dual Rank (双Rank)**：一条内存条中的内存芯片分为两个逻辑组，内存控制器一次只能访问一个组。双Rank内存一般比单Rank内存的性能稍好，但对系统的支持要求较高。</li><li>**Quad Rank (四Rank)**：内存条中的内存芯片分为四个逻辑组，通常用于大容量内存条。</li></ul><p><strong>Rank的影响</strong>：更多的Rank通常意味着内存容量更大，能够提升内存带宽，但也可能导致系统延迟增加，兼容性变差。某些主板限制了支持的 Rank 数量。</p><p><img src="https://www.oempcworld.com/wordpress/wp-content/uploads/2020/02/SinglevsDualvsQuadRAM.jpg" alt="Memory Rank"></p><p><img src="https://i0.wp.com/blog.memory4less.com/wp-content/uploads/2022/09/single-rank-vs-dual-rank-memory.jpg" alt="Memory Rank"></p><h3 id="2-Memory-Channel（内存通道）"><a href="#2-Memory-Channel（内存通道）" class="headerlink" title="2. Memory Channel（内存通道）"></a>2. <strong>Memory Channel（内存通道）</strong></h3><p>Memory Channel 指的是主板与内存之间的数据通道数量，决定了主板与内存通信的并行能力。</p><ul><li><strong>单通道（Single Channel）</strong>：只有一个通道用于与内存通信，带宽较低。</li><li><strong>双通道（Dual Channel）</strong>：两个通道用于与内存通信，带宽是单通道的两倍。</li><li><strong>四通道（Quad Channel）</strong>：四个通道同时工作，大幅提高内存带宽，多用于高性能的工作站和服务器。</li></ul><p><strong>Channel的影响</strong>：更多的通道可以增加内存带宽，提升数据传输效率，降低瓶颈。现代主板通常支持双通道甚至四通道配置。<br><img src="https://infohub.delltechnologies.com/static/media/9198938f-8c47-5a0e-82d9-6db6a62cd3f7/DAM-df9ef174-c6d7-41d7-9876-fd664ccd00e2/out/1856.009.png" alt="Memory Channel"></p><h3 id="3-DPC-DIMMs-per-Channel"><a href="#3-DPC-DIMMs-per-Channel" class="headerlink" title="3. DPC (DIMMs per Channel)"></a>3. <strong>DPC (DIMMs per Channel)</strong></h3><p>DPC 是指每个内存通道上安装的内存条数量。常见的配置有：</p><ul><li>**1DPC (One DIMM per Channel)**：每个内存通道只有一条内存条。这种配置下内存频率较高，系统的性能和稳定性通常更好。</li><li>**2DPC (Two DIMMs per Channel)**：每个内存通道上有两条内存条。这种配置可以增加系统的内存容量，但由于多个内存条共享同一个通道，内存频率可能会下降，延迟增加。</li><li><strong>更多的DPC</strong>：一些高端服务器主板支持每个通道上多达 3DPC 或 4DPC 的配置，但这样的配置更常用于需要超大内存容量的系统。</li></ul><p><strong>DPC的影响</strong>：1DPC 配置通常性能最好，频率较高；2DPC 增加了容量，但频率和性能可能会受到影响，特别是在高频内存配置下。</p><p><img src="https://www.intel.com/content/dam/support/us/en/images/processors/88926_image1.png" alt="Memory DPC"></p><h3 id="内存-Rank、Channel-和-DPC-之间的关系"><a href="#内存-Rank、Channel-和-DPC-之间的关系" class="headerlink" title="内存 Rank、Channel 和 DPC 之间的关系"></a><strong>内存 Rank、Channel 和 DPC 之间的关系</strong></h3><p>这三个概念在内存系统中相互作用，影响着整体的内存性能、容量和带宽。</p><ol><li><p><strong>Rank 和 Channel 的关系</strong>：</p><ul><li><strong>Rank</strong> 和 <strong>Channel</strong> 是独立的概念。你可以在单通道配置中使用多Rank内存条，或在双通道配置中使用单Rank内存条。更多的通道通常意味着更高的带宽，而更多的Rank可以提升内存控制器的访问效率。</li><li>例如，双通道 + 双Rank配置可以同时使用两条内存条中的多个Rank，提高数据传输的并行性。</li></ul></li><li><p><strong>Rank 和 DPC 的关系</strong>：</p><ul><li><strong>Rank</strong> 决定了每条内存条的逻辑分组，而 <strong>DPC</strong> 则决定了每个通道上有多少条内存。如果一个通道上有两条双Rank内存条（即2DPC+双Rank），系统会处理多个Rank和多个内存条，这种配置可能会增加延迟，但也能带来更大的内存容量。</li><li>使用多Rank内存条的同时增加DPC数量，系统在处理多个Rank时需要更复杂的控制机制，频率可能下降，稳定性也可能受到影响。</li></ul></li><li><p><strong>Channel 和 DPC 的关系</strong>：</p><ul><li><strong>Channel</strong> 决定了并行传输的能力，而 <strong>DPC</strong> 决定了每个通道上有多少内存条。比如，在双通道配置中，每个通道上都可以有一条（1DPC）或两条（2DPC）内存条。如果你在双通道上使用2DPC，那么系统中将有4条内存条，并且带宽会增加，但频率可能会下降。</li></ul></li></ol><h3 id="示例配置："><a href="#示例配置：" class="headerlink" title="示例配置："></a><strong>示例配置</strong>：</h3><ul><li><strong>双通道 + 1DPC + 单Rank</strong>：两个内存通道，每个通道上有一条单Rank内存。这种配置具有高带宽和高频率，适合追求性能的系统。</li><li><strong>双通道 + 2DPC + 双Rank</strong>：两个内存通道，每个通道上有两条双Rank内存。这种配置提供更大的内存容量，但可能会导致内存频率下降，延迟增加。</li><li><strong>四通道 + 1DPC + Quad Rank</strong>：四个内存通道，每个通道上有一条四Rank内存条，常见于需要超大内存容量的高端服务器。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>Memory Rank</strong>：决定了单条内存条的内部结构和容量，影响性能。</li><li><strong>Memory Channel</strong>：决定了系统与内存之间的并行通信路径数量，更多的通道提高了内存带宽。</li><li>**DPC (DIMMs per Channel)**：决定了每个通道上有多少条内存条，增加DPC数量通常能提高内存容量，但可能降低频率和性能。</li></ul><p>这三个因素共同作用，影响内存的容量、带宽、延迟和整体系统性能。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RHEL9 切换默认启动内核</title>
      <link href="/2024/09/25/rhel9_kernel_switch/"/>
      <url>/2024/09/25/rhel9_kernel_switch/</url>
      
        <content type="html"><![CDATA[<h1 id="RHEL9-切换默认启动内核"><a href="#RHEL9-切换默认启动内核" class="headerlink" title="RHEL9 切换默认启动内核"></a>RHEL9 切换默认启动内核</h1><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 Red Hat Enterprise Linux 9 (RHEL9) 中切换默认启动内核的详细操作步骤。在某些情况下，切换默认内核可能是必要的，比如为了测试、提高性能或增强安全性。</p><hr><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>适用于负责管理和维护 RHEL9 系统的系统管理员。</p><hr><h2 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h2><ul><li>系统管理员需要确保在切换默认内核后，系统的稳定性和功能性。</li><li>执行这些命令需要 root 权限或管理员权限。</li><li>在修改启动设置之前，建议进行备份以防止系统故障。</li></ul><hr><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>RHEL9 系统</li><li>root 或管理员权限</li><li>已安装的所有内核版本信息</li><li>基本的 Linux 启动流程知识</li></ul><hr><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li><p><strong>查看所有已安装的内核</strong></p><ul><li>在设置默认内核之前，首先需要查看系统中已安装的内核列表。</li><li>执行以下命令来查看所有可用的内核：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grubby --info=ALL</span><br></pre></td></tr></table></figure></li><li>示例输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index=0</span><br><span class="line">kernel=&quot;/boot/vmlinuz-5.14.0-70.17.1.el9_0.x86_64&quot;</span><br><span class="line">...</span><br><span class="line">index=1</span><br><span class="line">kernel=&quot;/boot/vmlinuz-5.14.0-50.12.2.el9.x86_64&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>设置默认启动内核</strong></p><ul><li>从上一步输出中，找到所需设置为默认的内核的完整路径，通常类似于 <code>/boot/vmlinuz-&lt;版本号&gt;</code> 的形式。</li><li>使用以下命令设置默认启动内核：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grubby --set-default /boot/vmlinuz-&lt;版本号&gt;</span><br></pre></td></tr></table></figure></li><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grubby --set-default /boot/vmlinuz-5.14.0-70.17.1.el9_0.x86_64</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>验证默认启动内核</strong></p><ul><li>设置完成后，可以通过以下命令验证默认启动的内核：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-editenv list</span><br></pre></td></tr></table></figure></li><li>示例输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saved_entry=5.14.0-70.17.1.el9_0.x86_64</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="其他示例"><a href="#其他示例" class="headerlink" title="其他示例"></a>其他示例</h2><ul><li><p><strong>查看当前正在运行的内核</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.14.0-70.17.1.el9_0.x86_64</span><br></pre></td></tr></table></figure></li><li><p><strong>列出所有已安装的内核（带详细信息）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep kernel</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel-5.14.0-50.12.2.el9.x86_64</span><br><span class="line">kernel-5.14.0-70.17.1.el9_0.x86_64</span><br></pre></td></tr></table></figure></li><li><p><strong>删除旧内核（保持两个内核版本）</strong><br>在确保新的内核可以正常工作后，可以删除旧的内核来节省磁盘空间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf remove kernel-&lt;旧版本号&gt;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/">Red Hat 官方文档：GRUB2 启动加载器</a></li><li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/">RHEL9 内核管理指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> RHEL </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字证书、证书颁发机构 (CA)、私钥、公钥和数字签名</title>
      <link href="/2024/08/14/Digital_Certificate_SOP/"/>
      <url>/2024/08/14/Digital_Certificate_SOP/</url>
      
        <content type="html"><![CDATA[<h1 id="数字证书、证书颁发机构-CA-、私钥、公钥和数字签名"><a href="#数字证书、证书颁发机构-CA-、私钥、公钥和数字签名" class="headerlink" title="数字证书、证书颁发机构 (CA)、私钥、公钥和数字签名"></a>数字证书、证书颁发机构 (CA)、私钥、公钥和数字签名</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>概述了使用数字证书、证书颁发机构 (CA)、私钥、公钥和数字签名的基本概念和程序。这些组件对于确保通信安全、验证数字数据的真实性和完整性至关重要。</p><h2 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="2. 适用范围"></a>2. 适用范围</h2><p>适用于组织内负责管理、部署和使用数字证书和加密技术的IT安全专业人员、系统管理员和开发人员。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>IT安全团队</strong>：管理数字证书的生命周期，包括颁发、更新和吊销，确保符合安全策略。</li><li><strong>系统管理员</strong>：配置系统以使用数字证书，并管理私钥的安全存储。</li><li><strong>开发人员</strong>：在应用程序中集成公钥和私钥，以实现安全通信协议。</li><li><strong>终端用户</strong>：使用配置了有效和可信证书的系统。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>可信的证书颁发机构 (CA) 或内部CA设置。</li><li>生成加密密钥对的工具（例如OpenSSL）。</li><li>私钥的安全存储机制，如硬件安全模块 (HSM) 或加密文件。</li><li>配置为支持TLS&#x2F;SSL协议的应用程序或系统，用于安全的数据传输。</li></ul><h2 id="5-流程"><a href="#5-流程" class="headerlink" title="5. 流程"></a>5. 流程</h2><p><img src="https://lilinth.github.io/picx-images-hosting/8740f369-7073-4439-9658-d2729bdfb355[1].13lp5jsm8r.webp" alt="8740f369-7073-4439-9658-d2729bdfb355[1]"></p><h3 id="5-1-生成密钥对"><a href="#5-1-生成密钥对" class="headerlink" title="5.1 生成密钥对"></a>5.1 生成密钥对</h3><ol><li><p><strong>生成私钥</strong>：</p><ul><li>使用加密工具（如OpenSSL）创建私钥。</li><li>示例命令：<code>openssl genpkey -algorithm RSA -out private_key.pem -aes256</code></li><li>私钥必须安全存储，因为它对于加密和签名创建至关重要。</li></ul></li><li><p><strong>派生公钥</strong>：</p><ul><li>从私钥中提取公钥，可与他人共享。</li><li>示例命令：<code>openssl rsa -pubout -in private_key.pem -out public_key.pem</code></li><li>公钥用于加密和验证数字签名。</li></ul></li></ol><h3 id="5-2-创建证书签名请求-CSR"><a href="#5-2-创建证书签名请求-CSR" class="headerlink" title="5.2 创建证书签名请求 (CSR)"></a>5.2 创建证书签名请求 (CSR)</h3><ol><li><strong>生成CSR</strong>：<ul><li>使用私钥创建包含公钥和组织信息的CSR。</li><li>示例命令：<code>openssl req -new -key private_key.pem -out csr.pem</code></li><li>将CSR提交给CA进行验证和证书颁发。</li></ul></li></ol><h3 id="5-3-证书颁发机构-CA-操作"><a href="#5-3-证书颁发机构-CA-操作" class="headerlink" title="5.3 证书颁发机构 (CA) 操作"></a>5.3 证书颁发机构 (CA) 操作</h3><ol><li><p><strong>签署CSR</strong>：</p><ul><li>CA审核CSR，验证后进行签名并颁发数字证书。</li><li>该证书用于服务器在安全通信中验证其身份。</li><li>内部CA的示例命令：<code>openssl x509 -req -days 365 -in csr.pem -signkey ca_private_key.pem -out certificate.pem</code></li></ul></li><li><p><strong>证书更新</strong>：</p><ul><li>在证书过期之前，生成新的CSR并提交给CA。</li><li>CA颁发新的证书，并更新有效期。</li></ul></li></ol><h3 id="5-4-数字签名和验证"><a href="#5-4-数字签名和验证" class="headerlink" title="5.4 数字签名和验证"></a>5.4 数字签名和验证</h3><ol><li><p><strong>创建数字签名</strong>：</p><ul><li>通过对消息或文档进行哈希处理并使用私钥加密哈希值来签名。</li><li>这可确保消息的完整性和真实性。</li><li>示例：<code>openssl dgst -sha256 -sign private_key.pem -out signature.sig file_to_sign.txt</code></li></ul></li><li><p><strong>验证数字签名</strong>：</p><ul><li>使用发送方的公钥解密哈希值，并将其与根据收到的文档计算的哈希值进行比较，以验证签名的真实性。</li><li>示例：<code>openssl dgst -sha256 -verify public_key.pem -signature signature.sig file_to_verify.txt</code></li></ul></li></ol><h3 id="5-5-管理证书吊销"><a href="#5-5-管理证书吊销" class="headerlink" title="5.5 管理证书吊销"></a>5.5 管理证书吊销</h3><ol><li><strong>吊销证书</strong>：<ul><li>如果证书被泄露，应立即通过CA吊销。</li><li>CA会将证书添加到证书吊销列表 (CRL) 中，系统会检查CRL以避免使用被泄露的证书。</li><li>创建CRL的示例命令：<code>openssl ca -gencrl -out crl.pem</code></li></ul></li></ol><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul><li><a href="https://www.openssl.org/docs/">OpenSSL文档</a></li><li><a href="https://www.digicert.com/ssl/">理解数字证书</a></li><li><a href="https://www.globalsign.com/en/blog/what-is-a-certificate-authority">证书颁发机构概述</a></li><li><a href="https://www.cloudflare.com/learning/ssl/what-is-public-key-infrastructure-pki/">PKI和数字签名</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Certificate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Fio 工具进行性能测试</title>
      <link href="/2024/08/14/fio_test/"/>
      <url>/2024/08/14/fio_test/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Fio-工具进行性能测试"><a href="#使用-Fio-工具进行性能测试" class="headerlink" title="使用 Fio 工具进行性能测试"></a>使用 Fio 工具进行性能测试</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>详细介绍如何使用Fio（Flexible I&#x2F;O Tester）工具进行存储性能测试。Fio是一款广泛应用的工具，能够测试块设备和文件系统的读写性能。本文将结合多个实际示例，逐步说明如何配置和运行Fio测试，并解析每个测试结果。</p><h2 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="2. 适用范围"></a>2. 适用范围</h2><p>适用于系统管理员、存储工程师和开发人员，他们需要对各种存储设备（如HDD、SSD、RAID阵列、SAN和NAS设备）进行性能评估。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>系统管理员</strong>: 负责安装和配置Fio工具，确保测试环境的稳定性和一致性。</li><li><strong>存储工程师</strong>: 设计测试参数和负载模型，以模拟实际使用场景。</li><li><strong>开发人员</strong>: 使用Fio生成性能数据，帮助优化应用程序的I&#x2F;O操作。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>安装了Fio工具的系统。</li><li>对目标存储设备的完全访问权限。</li><li>理解存储设备和文件系统的基本原理。</li><li>适当的权限执行性能测试，以避免影响生产环境。</li></ul><h2 id="5-流程和示例"><a href="#5-流程和示例" class="headerlink" title="5. 流程和示例"></a>5. 流程和示例</h2><h3 id="5-1-安装-Fio"><a href="#5-1-安装-Fio" class="headerlink" title="5.1 安装 Fio"></a>5.1 安装 Fio</h3><ol><li><p><strong>在Linux上安装Fio</strong>:</p><ul><li>大多数Linux发行版可以通过包管理器安装Fio。</li><li>使用以下命令安装Fio:<ul><li><strong>Debian&#x2F;Ubuntu</strong>: <code>sudo apt-get install fio</code></li><li><strong>CentOS&#x2F;RHEL</strong>: <code>sudo yum install fio</code></li><li><strong>Fedora</strong>: <code>sudo dnf install fio</code></li></ul></li></ul></li><li><p><strong>验证安装</strong>:</p><ul><li>使用命令 <code>fio --version</code> 验证Fio是否成功安装。</li></ul></li></ol><h3 id="5-2-基本测试命令"><a href="#5-2-基本测试命令" class="headerlink" title="5.2 基本测试命令"></a>5.2 基本测试命令</h3><ol><li><strong>运行简单的读写测试</strong>:<ul><li>以下命令将在指定的文件或设备上运行基本的顺序写入和读取测试。</li><li>示例命令: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=basic_test --filename=/path/to/testfile --size=1G --rw=readwrite --bs=4k --ioengine=libaio --numjobs=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure></li><li>参数说明:<ul><li><code>--name=basic_test</code>: 测试任务的名称。</li><li><code>--filename=/path/to/testfile</code>: 测试的目标文件或设备。</li><li><code>--size=1G</code>: 文件大小为1GB。</li><li><code>--rw=readwrite</code>: 读写混合测试。</li><li><code>--bs=4k</code>: 块大小为4KB。</li><li><code>--ioengine=libaio</code>: 使用Linux异步I&#x2F;O引擎。</li><li><code>--numjobs=1</code>: 使用单个工作线程。</li><li><code>--runtime=60</code>: 运行时间为60秒。</li><li><code>--group_reporting</code>: 汇总报告输出。</li></ul></li></ul></li></ol><h3 id="5-3-复杂测试"><a href="#5-3-复杂测试" class="headerlink" title="5.3 复杂测试"></a>5.3 复杂测试</h3><ol><li><p><strong>运行随机读写测试</strong>:</p><ul><li>对存储设备进行随机读写测试，以模拟实际工作负载。</li><li>示例命令:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=random_test --filename=/path/to/testfile --size=2G --rw=randrw --bs=4k --ioengine=libaio --numjobs=4 --runtime=120 --rwmixread=70 --group_reporting</span><br></pre></td></tr></table></figure></li><li>额外参数:<ul><li><code>--rw=randrw</code>: 随机读写测试。</li><li><code>--rwmixread=70</code>: 设置读操作占比为70%。</li></ul></li></ul></li><li><p><strong>测试多线程性能</strong>:</p><ul><li>使用多个工作线程同时对设备进行读写，以测试多线程性能。</li><li>示例命令:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=multithread_test --filename=/path/to/testfile --size=4G --rw=randwrite --bs=8k --ioengine=libaio --numjobs=8 --runtime=180 --group_reporting</span><br></pre></td></tr></table></figure></li><li>该命令使用8个线程，每个线程执行随机写操作。</li></ul></li></ol><h3 id="5-4-分析结果"><a href="#5-4-分析结果" class="headerlink" title="5.4 分析结果"></a>5.4 分析结果</h3><ol><li><p><strong>查看测试报告</strong>:</p><ul><li>Fio的输出会包含每个测试的详细报告，包括吞吐量、IOPS、延迟等指标。</li><li>示例输出分析:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Run status group 0 (all jobs):</span><br><span class="line">  READ: io=1048576KB, bw=17496KB/s, iops=4374, runt= 60001msec</span><br><span class="line">  WRITE: io=1048576KB, bw=17496KB/s, iops=4374, runt= 60001msec</span><br></pre></td></tr></table></figure></li><li><code>bw</code>表示带宽（吞吐量），<code>iops</code>表示每秒I&#x2F;O操作次数，<code>runt</code>表示测试运行时间。</li></ul></li><li><p><strong>保存结果</strong>:</p><ul><li>可以将结果输出保存到文件中进行进一步分析。</li><li>使用 <code>--output=&lt;filename&gt;</code> 参数保存报告，例如:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=basic_test --filename=/path/to/testfile --size=1G --rw=readwrite --bs=4k --ioengine=libaio --numjobs=1 --runtime=60 --group_reporting --output=fio_report.txt</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="6-更多示例"><a href="#6-更多示例" class="headerlink" title="6. 更多示例"></a>6. 更多示例</h2><h3 id="6-1-基本顺序读写测试"><a href="#6-1-基本顺序读写测试" class="headerlink" title="6.1 基本顺序读写测试"></a>6.1 基本顺序读写测试</h3><ol><li><p><strong>顺序写入测试</strong></p><ul><li><strong>目的</strong>: 测试存储设备在顺序写入数据时的性能，这对数据仓库或视频存储系统等大文件顺序写入场景非常重要。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=seq_write --filename=/path/to/testfile --size=10G --rw=write --bs=1M --direct=1 --ioengine=libaio --numjobs=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>bw</code>: 测试期间的平均带宽，反映了设备的顺序写入速度。</li><li><code>iops</code>: 每秒I&#x2F;O操作次数，通常用于衡量设备的响应能力。</li><li>例如，如果 <code>bw=500MB/s</code> 和 <code>iops=500</code>，这表明设备在此测试中能够维持500MB&#x2F;s的顺序写入速度。</li></ul></li></ul></li><li><p><strong>顺序读取测试</strong></p><ul><li><strong>目的</strong>: 测试存储设备在顺序读取数据时的性能，适用于需要大量顺序读取操作的场景，如视频播放或数据分析。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=seq_read --filename=/path/to/testfile --size=10G --rw=<span class="built_in">read</span> --bs=1M --direct=1 --ioengine=libaio --numjobs=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>bw</code>: 测试期间的平均读取带宽。</li><li>例如，<code>bw=600MB/s</code> 表示设备能够以600MB&#x2F;s的速度顺序读取数据，这对于顺序数据访问模式的应用非常理想。</li></ul></li></ul></li></ol><h3 id="6-2-随机读写测试"><a href="#6-2-随机读写测试" class="headerlink" title="6.2 随机读写测试"></a>6.2 随机读写测试</h3><ol><li><p><strong>随机写入测试</strong></p><ul><li><strong>目的</strong>: 测试设备在随机写入数据时的性能，模拟数据库写入、日志记录等需要频繁写入小块数据的场景。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=rand_write --filename=/path/to/testfile --size=5G --rw=randwrite --bs=4k --direct=1 --ioengine=libaio --numjobs=4 --runtime=120 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>iops</code>: 随机写入操作的IOPS通常是关注的重点，反映了设备在处理小块随机写入时的能力。</li><li><code>lat</code>: 延迟时间，表示每次I&#x2F;O操作的平均时间，延迟越低越好。</li><li>例如，<code>iops=20000</code> 和 <code>lat=0.1ms</code> 表示设备在随机写入小块数据时表现良好。</li></ul></li></ul></li><li><p><strong>随机读取测试</strong></p><ul><li><strong>目的</strong>: 测试存储设备在随机读取数据时的性能，适用于OLTP数据库或高并发读取的应用场景。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=rand_read --filename=/path/to/testfile --size=5G --rw=randread --bs=4k --direct=1 --ioengine=libaio --numjobs=4 --runtime=120 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>iops</code> 和 <code>lat</code> 是评估设备随机读取性能的重要指标。</li><li>例如，如果 <code>iops=50000</code> 和 <code>lat=0.08ms</code>，这表明设备在高负载下也能快速响应随机读取请求。</li></ul></li></ul></li><li><p><strong>随机读写混合测试</strong></p><ul><li><strong>目的</strong>: 测试读写混合场景下的存储性能，常见于需要同时处理读取和写入请求的系统，如文件服务器或虚拟化环境。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=rand_rw_mix --filename=/path/to/testfile --size=5G --rw=randrw --bs=4k --direct=1 --ioengine=libaio --numjobs=4 --runtime=120 --rwmixread=70 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>rwmixread=70</code> 设置读写比例为70%读和30%写，这能测试出设备在读写混合负载下的表现。</li><li>观察 <code>iops</code> 和 <code>lat</code> 来评估在这种混合场景下的性能。</li></ul></li></ul></li></ol><h3 id="6-3-多线程和多进程测试"><a href="#6-3-多线程和多进程测试" class="headerlink" title="6.3 多线程和多进程测试"></a>6.3 多线程和多进程测试</h3><ol><li><p><strong>多线程顺序读写测试</strong></p><ul><li><strong>目的</strong>: 评估存储设备在多线程情况下的顺序读写性能，模拟多用户并发访问的场景。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=multithread_seq --filename=/path/to/testfile --size=10G --rw=write --bs=1M --direct=1 --ioengine=libaio --numjobs=8 --runtime=180 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>bw</code> 和 <code>iops</code> 在多线程情况下可能会有所增加，但也可能因锁争用或I&#x2F;O调度影响而下降。</li><li>对比单线程和多线程结果，可以评估设备在并发负载下的扩展性。</li></ul></li></ul></li><li><p><strong>多进程随机写入测试</strong></p><ul><li><strong>目的</strong>: 测试在多个进程同时进行随机写入时的性能，适用于模拟数据库集群或并行计算环境。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=multiprocess_rand_write --filename=/path/to/testfile --size=10G --rw=randwrite --bs=4k --direct=1 --ioengine=libaio --numjobs=8 --runtime=180 --group_reporting --gtod_reduce=1</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li>多进程下的 <code>iops</code> 和 <code>lat</code> 是关键指标，注意观察是否有瓶颈产生。</li><li>例如，如果 <code>iops=45000</code> 和 <code>lat=0.15ms</code>，则表示设备在高并发写入场景下表现较为稳定。</li></ul></li></ul></li></ol><h3 id="6-4-文件系统缓存的影响"><a href="#6-4-文件系统缓存的影响" class="headerlink" title="6.4 文件系统缓存的影响"></a>6.4 文件系统缓存的影响</h3><ol><li><p><strong>开启缓存的随机写入测试</strong></p><ul><li><strong>目的</strong>: 测试文件系统缓存对写操作的影响，模拟常规写入操作。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=cached_rand_write --filename=/path/to/testfile --size=2G --rw=randwrite --bs=4k --ioengine=<span class="built_in">sync</span> --numjobs=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>iops</code> 可能会因为缓存的作用而显著提高，<code>lat</code> 也可能减少。</li><li>例如，如果 <code>iops=35000</code> 和 <code>lat=0.05ms</code>，这表明文件系统缓存对性能有积极影响。</li></ul></li></ul></li><li><p><strong>禁用缓存的随机写入测试</strong></p><ul><li><strong>目的</strong>: 禁用缓存直接写入到磁盘，评估纯粹的硬件性能。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=direct_rand_write --filename=/path/to/testfile --size=2G --rw=randwrite --bs=4k --direct=1 --ioengine=libaio --numjobs=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li>禁用缓存后，<code>iops</code> 和 <code>lat</code> 反映了设备的实际性能。</li><li>例如，<code>iops=15000</code> 和 <code>lat=0.3ms</code> 表示在无缓存情况下，设备的硬件性能。</li></ul></li></ul></li></ol><h3 id="6-5-RAID阵列性能测试"><a href="#6-5-RAID阵列性能测试" class="headerlink" title="6.5 RAID阵列性能测试"></a>6.5 RAID阵列性能测试</h3><ol><li><p><strong>顺序读取RAID性能</strong></p><ul><li><strong>目的</strong>: 评估RAID阵列的顺序读取性能，适用于高吞吐量需求的应用，如视频编辑或数据备份。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=raid_seq_read --filename=/dev/md0 --size=10G --rw=<span class="built_in">read</span> --bs=1M --direct=1 --ioengine=libaio --numjobs=1 --runtime=300 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>bw</code> 是主要关注点，反映了RAID阵列在顺序读取任务中的吞吐能力。</li><li>例如，<code>bw=800MB/s</code> 表示RAID阵列在该测试中表现良好。</li></ul></li></ul></li><li><p><strong>随机写入RAID性能</strong></p><ul><li><strong>目的</strong>: 测试RAID阵列的随机写入性能，适用于需要高I&#x2F;O吞吐的环境，如虚拟化平台。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=raid_rand_write --filename=/dev/md0 --size=5G --rw=randwrite --bs=4k --direct=1 --ioengine=libaio --numjobs=4 --runtime=300 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li>关注 <code>iops</code> 和 <code>lat</code> 指标，评估RAID在并发随机写入下的性能。</li><li>例如，如果 <code>iops=30000</code> 和 <code>lat=0.2ms</code>，则表示RAID阵列能够在随机写入场景下保持较高的性能。</li></ul></li></ul></li></ol><h2 id="7-一些Tips"><a href="#7-一些Tips" class="headerlink" title="7. 一些Tips"></a>7. 一些Tips</h2><ul><li>Q: 指定运行FIO的时间，但是提前就结束了。</li><li>A: 加上参数 <code>-time_base</code>即可</li></ul><h2 id="8-参考文献"><a href="#8-参考文献" class="headerlink" title="8. 参考文献"></a>8. 参考文献</h2><ul><li><a href="https://fio.readthedocs.io/">Fio官方文档</a></li><li><a href="https://www.redhat.com/en/resources/storage-performance-testing-best-practices">存储性能测试最佳实践</a></li><li><a href="https://www.intel.com/content/www/us/en/support/articles/000005791/memory-and-storage.html">RAID性能优化指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 RHEL 9.4 上配置 ARM64 虚拟机</title>
      <link href="/2024/08/14/rhel9.4_arm_vm/"/>
      <url>/2024/08/14/rhel9.4_arm_vm/</url>
      
        <content type="html"><![CDATA[<h1 id="在-RHEL-9-4-上配置-ARM64-虚拟机"><a href="#在-RHEL-9-4-上配置-ARM64-虚拟机" class="headerlink" title="在 RHEL 9.4 上配置 ARM64 虚拟机"></a>在 RHEL 9.4 上配置 ARM64 虚拟机</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>在 RHEL 9.4 上配置 ARM64 虚拟机可以帮助用户在物理服务器上模拟 ARM64 环境，用于测试和开发适用于 ARM64 架构的软件。详细介绍了如何在 RHEL 9.4 系统上配置和运行 ARM64 虚拟机的过程。</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h2><p>适用于在 RHEL 9.4 系统上需要模拟 ARM64 虚拟机环境的技术人员。主要涉及 QEMU、KVM 和相关工具的安装与配置。</p><h2 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h2><ul><li><strong>系统管理员</strong>：负责确保系统已安装必要的软件包，并具备运行虚拟机的权限。</li><li><strong>操作员</strong>：按照正确配置和运行 ARM64 虚拟机。</li></ul><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h2><ul><li>运行 RHEL 9.4 操作系统的物理服务器或虚拟主机。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>有效的互联网连接以下载必要的软件包和工具。</li></ul><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><h3 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h3><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf update -y</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装 QEMU、KVM 和相关工具</strong></p><ul><li>使用 <code>dnf</code> 安装 QEMU 和 KVM 以及相关的虚拟化管理工具：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install qemu-kvm qemu-img libvirt virt-install virt-manager -y</span><br><span class="line">sudo dnf install libguestfs-tools -y  <span class="comment"># 用于管理虚拟机磁盘镜像</span></span><br></pre></td></tr></table></figure></li></ul><p>1.3 <strong>启动并启用 KVM 和 Libvirt 服务</strong></p><ul><li>确保 KVM 和 Libvirt 服务已启动并运行：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start libvirtd</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> libvirtd</span><br></pre></td></tr></table></figure></li></ul><p>1.4 <strong>检查 KVM 是否已启用</strong></p><ul><li>使用以下命令检查 KVM 是否正常启用(有些情况下虽然没有列出KVM，但是仍然是支持的)：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsmod | grep kvm</span><br></pre></td></tr></table></figure></li><li>如果输出中包含 <code>kvm</code> 和 <code>kvm_intel</code> 或 <code>kvm_amd</code>，则表示 KVM 已正确启用。</li><li>实际测试，不包含<code>kvm</code>也可以使用，具体问题具体分析。</li></ul><h3 id="2-获取和准备-ARM64-镜像"><a href="#2-获取和准备-ARM64-镜像" class="headerlink" title="2. 获取和准备 ARM64 镜像"></a>2. <strong>获取和准备 ARM64 镜像</strong></h3><p>2.1 <strong>下载 RHEL 9.4 ARM64 操作系统镜像</strong></p><ul><li>从 Red Hat 官方网站或客户门户下载 RHEL 9.4 ARM64 ISO 镜像。确保您有适当的订阅以访问镜像。</li></ul><p>2.2 <strong>创建虚拟机磁盘镜像</strong></p><ul><li>使用 <code>qemu-img</code> 创建虚拟机磁盘镜像：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f qcow2 rhel9-arm64.qcow2 20G</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>-f qcow2</code>：指定磁盘镜像格式为 QCOW2。</li><li><code>20G</code>：设置磁盘大小为 20GB。</li></ul></li></ul><h3 id="3-创建和配置-ARM64-虚拟机"><a href="#3-创建和配置-ARM64-虚拟机" class="headerlink" title="3. 创建和配置 ARM64 虚拟机"></a>3. <strong>创建和配置 ARM64 虚拟机</strong></h3><p>3.1 <strong>启动虚拟机并进行安装</strong></p><ul><li>使用以下命令启动虚拟机，并从 ISO 镜像进行安装：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virt-install --name myvm --ram 2048 --vcpus 2 --disk path=/var/lib/libvirt/images/myvm.qcow2,size=20  --os-variant rhel9.4 --network bridge=virbr0 --graphics none --console pty,target_type=serial --cdrom /path/to/your/iso/file.iso</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>virt-install</code>：命令行工具，用于创建新的虚拟机。</li><li><code>--name myvm</code>：指定虚拟机的名称为 myvm。这个名称将用于管理和识别该虚拟机。</li><li><code>--ram 2048</code>：分配给虚拟机的内存大小，以 MB 为单位。这意味着为虚拟机分配了 2048 MB（2 GB）的内存。</li><li><code>--vcpus 2</code>：指定虚拟机的虚拟 CPU 数量为 2 个。这决定了虚拟机可以使用的 CPU 核心数。</li><li><code>--disk path=/var/lib/libvirt/images/arm64vm.qcow2,size=20</code>：path&#x3D;&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images&#x2F;arm64vm.qcow2：定义虚拟机的磁盘映像文件路径和文件名。此文件将存储虚拟机的虚拟硬盘。</li><li><code>size=20</code>：为虚拟机的磁盘分配 20 GB 的存储空间。</li><li><code>--os-variant generic</code>：指定操作系统的具体版本或变体为 generic，即通用版本。这意味着该配置适用于多种 Linux 发行版。可以使用 osinfo-query os 命令查看可用的具体操作系统变体。</li><li><code>--arch aarch64</code>：指定虚拟机的架构为 ARM64（aarch64）。这意味着虚拟机将仿真或使用 ARM64 架构的硬件。</li><li><code>--machine virt</code>：指定虚拟机的机器类型为 virt，这是 QEMU 用于 ARM 仿真的通用机器类型，适用于多种 ARM64 设备。</li><li><code>--network bridge=virbr0</code>：将虚拟机连接到名为 virbr0 的桥接网络接口。这允许虚拟机与主机及网络中的其他设备进行通信。</li><li><code>--graphics none</code>：指定虚拟机不使用图形界面（无图形输出），以纯命令行方式运行。这通常用于服务器或嵌入式系统的设置。</li><li><code>--console pty,target_type=serial</code>：设置虚拟机的控制台为伪终端（PTY），并将其连接到虚拟机的串行端口。这允许通过命令行的方式直接与虚拟机进行交互。</li><li><code>--cdrom /path/to/your/arm64.iso</code>：指定要加载的 ISO 文件路径，这通常是操作系统安装镜像的路径。虚拟机启动时会从这个 ISO 镜像中引导，并开始安装操作系统。<ul><li>也可以使用图形界面<code>virtual machine manager</code>进行安装</li></ul></li></ul></li></ul><p>3.2 <strong>安装操作系统</strong></p><ul><li>当虚拟机启动后，按照屏幕提示安装 RHEL 9.4 操作系统。安装过程与在物理机上的安装类似。</li></ul><p>3.3 <strong>完成安装后，重启虚拟机</strong></p><ul><li>完成安装后，可以使用以下命令进入虚拟机：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh console myvm</span><br></pre></td></tr></table></figure>   当提示 <code>Escape character is ^]</code> 时，按 <code>Enter</code> 键进入虚拟机的命令行。如果要退出控制台，您可以使用 <code>Ctrl + ]</code>。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure></li><li>解释：此命令省略了安装 CD-ROM 部分，仅使用已安装的磁盘镜像启动虚拟机。</li></ul><h3 id="4-维护与管理-ARM64-虚拟机"><a href="#4-维护与管理-ARM64-虚拟机" class="headerlink" title="4. 维护与管理 ARM64 虚拟机"></a>4. <strong>维护与管理 ARM64 虚拟机</strong></h3><p>4.1 <strong>快照管理</strong></p><ul><li>使用 <code>qemu-img</code> 管理虚拟机快照，便于恢复到之前的状态：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qemu-img snapshot -c snap1 rhel9-arm64.qcow2  <span class="comment"># 创建快照</span></span><br><span class="line">qemu-img snapshot -l rhel9-arm64.qcow2        <span class="comment"># 列出所有快照</span></span><br><span class="line">qemu-img snapshot -a snap1 rhel9-arm64.qcow2  <span class="comment"># 恢复到快照</span></span><br></pre></td></tr></table></figure></li></ul><p>4.2 <strong>备份虚拟机</strong></p><ul><li>通过复制 QCOW2 镜像文件来备份虚拟机：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> rhel9-arm64.qcow2 rhel9-arm64-backup.qcow2</span><br></pre></td></tr></table></figure></li></ul><p>4.3 <strong>调整虚拟机资源</strong></p><ul><li>停止虚拟机后，可以编辑启动命令来调整虚拟机的 CPU 和内存分配，以满足不同的测试需求。</li></ul><h3 id="5-常见问题与故障排除"><a href="#5-常见问题与故障排除" class="headerlink" title="5. 常见问题与故障排除"></a>5. <strong>常见问题与故障排除</strong></h3><p>5.1 <strong>虚拟机性能较差</strong></p><ul><li>如果发现虚拟机性能较差，可以考虑增加分配给虚拟机的 CPU 核心和内存，或启用 KVM 加速（如果支持）。</li></ul><p>5.2 <strong>无法启动虚拟机</strong></p><ul><li>检查启动命令中的文件路径和参数是否正确，确保 BIOS 和磁盘镜像文件存在且可访问。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://www.qemu.org/documentation/">QEMU Documentation</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9">Red Hat Enterprise Linux 9 Documentation</a></li><li><a href="https://libvirt.org/documentation.html">Libvirt Documentation</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> VM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 PF 直通 (Passthrough)</title>
      <link href="/2024/08/14/rhel9.4_mlx_pf/"/>
      <url>/2024/08/14/rhel9.4_mlx_pf/</url>
      
        <content type="html"><![CDATA[<h1 id="在-ARM64-平台的-RHEL-9-4-上配置-Mellanox-ConnectX-6-网卡的-PF-直通-Passthrough"><a href="#在-ARM64-平台的-RHEL-9-4-上配置-Mellanox-ConnectX-6-网卡的-PF-直通-Passthrough" class="headerlink" title="在 ARM64 平台的 RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 PF 直通 (Passthrough)"></a>在 ARM64 平台的 RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 PF 直通 (Passthrough)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>在虚拟化环境中，Mellanox ConnectX-6 网卡的物理功能 (Physical Function, PF) 直通（Passthrough）配置允许将整个物理网卡直接分配给虚拟机，从而获得接近裸机的网络性能。此配置特别适用于高性能网络需求的虚拟化应用场景。##详细介绍了如何在 ARM64 平台的 RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 PF 直通。</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h2><p>适用于系统管理员和虚拟化技术人员，帮助他们在 RHEL 9.4 ARM64 系统上配置 Mellanox ConnectX-6 网卡的 PF 直通功能，以优化虚拟化环境中的网络性能。</p><h2 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h2><ul><li><strong>系统管理员</strong>：确保系统已正确安装必要的软件包，且系统硬件支持 IOMMU 和 PF 直通功能。</li><li><strong>操作员</strong>：按照##配置 Mellanox ConnectX-6 网卡的 PF 直通，并确保其正确运行。</li></ul><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h2><ul><li>运行 RHEL 9.4 操作系统的 ARM64 服务器。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>Mellanox ConnectX-6 网卡，并确保服务器固件支持 IOMMU 和直通功能。</li></ul><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><h3 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h3><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf update -y</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装必要的驱动和工具</strong></p><ul><li><p>安装 Mellanox 网卡的驱动程序和相关工具：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install -y mlnx-ofed-basic</span><br></pre></td></tr></table></figure></li><li><p>安装完毕后，重启服务器以加载新安装的驱动：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></li></ul><p>1.3 <strong>检查 IOMMU 支持</strong></p><ul><li><p>确保系统的固件（Firmware&#x2F;BIOS）设置中已启用 IOMMU 支持。</p></li><li><p>确认 IOMMU 已在内核启动参数中启用：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo grubby --update-kernel=ALL --args=<span class="string">&quot;iommu.passthrough=on&quot;</span></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></li><li><p>重启后，使用以下命令确认 IOMMU 已启用：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i iommu</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-配置-Mellanox-ConnectX-6-的-PF-直通"><a href="#2-配置-Mellanox-ConnectX-6-的-PF-直通" class="headerlink" title="2. 配置 Mellanox ConnectX-6 的 PF 直通"></a>2. <strong>配置 Mellanox ConnectX-6 的 PF 直通</strong></h3><p>2.1 <strong>识别 Mellanox 网卡</strong></p><ul><li>使用 <code>lspci</code> 命令找到 Mellanox ConnectX-6 网卡的 PCI 总线地址：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep Mellanox</span><br></pre></td></tr></table></figure></li><li>记下类似 <code>0000:03:00.0</code> 的总线地址，这个地址表示网卡的物理功能（PF）。</li></ul><p>2.2 <strong>解除网卡绑定</strong></p><ul><li>在将网卡的 PF 直通给虚拟机之前，需要将其从主机系统中解除绑定：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:00.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/devices/0000:03:00.0/driver/unbind</span><br></pre></td></tr></table></figure></li></ul><p>2.3 <strong>绑定到 VFIO 驱动</strong></p><ul><li><p>将网卡的 PF 绑定到 VFIO 驱动以启用直通：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe vfio-pci</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:00.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/drivers/vfio-pci/bind</span><br></pre></td></tr></table></figure></li><li><p>确认绑定成功：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -nnk -d 15b3: | grep <span class="string">&quot;Kernel driver in use&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>输出应显示 <code>vfio-pci</code> 作为内核驱动。</p></li></ul><h3 id="3-配置-PF-直通到虚拟机"><a href="#3-配置-PF-直通到虚拟机" class="headerlink" title="3. 配置 PF 直通到虚拟机"></a>3. <strong>配置 PF 直通到虚拟机</strong></h3><p>3.1 <strong>编辑虚拟机配置</strong></p><ul><li>使用 <code>virsh edit</code> 或 <code>virt-manager</code> 将 PF 设备直接分配给虚拟机。示例 XML 配置：   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hostdev</span> <span class="attr">mode</span>=<span class="string">&#x27;subsystem&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">managed</span>=<span class="string">&#x27;yes&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x03&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x05&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hostdev</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>该配置将 Mellanox 网卡的 PF 设备直通给虚拟机。</li></ul><p>3.2 <strong>启用并启动虚拟机</strong></p><ul><li>编辑并保存虚拟机配置后，启动虚拟机：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh start &lt;vm_name&gt;</span><br></pre></td></tr></table></figure></li><li>在虚拟机中，使用 <code>ip link show</code> 或类似命令验证已分配的 PF 网卡。</li></ul><h3 id="4-维护与管理"><a href="#4-维护与管理" class="headerlink" title="4. 维护与管理"></a>4. <strong>维护与管理</strong></h3><p>4.1 <strong>释放 PF 资源</strong></p><ul><li>如果需要将 PF 资源从虚拟机中释放并返回主机，可以先关闭虚拟机并解除 VFIO 绑定：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virsh shutdown &lt;vm_name&gt;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:00.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/drivers/vfio-pci/unbind</span><br></pre></td></tr></table></figure></li></ul><p>4.2 <strong>重新绑定网卡到主机</strong></p><ul><li>将网卡重新绑定回主机操作系统的 Mellanox 驱动：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:00.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/drivers/mlx5_core/bind</span><br></pre></td></tr></table></figure></li></ul><p>4.3 <strong>定期更新驱动</strong></p><ul><li>确保定期更新 Mellanox 驱动程序和固件，以获取最新的功能和性能改进：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf upgrade -y mlnx-ofed-basic</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-常见问题与故障排除"><a href="#5-常见问题与故障排除" class="headerlink" title="5. 常见问题与故障排除"></a>5. <strong>常见问题与故障排除</strong></h3><p>5.1 <strong>PF 无法绑定到虚拟机</strong></p><ul><li>检查是否已正确启用 IOMMU 和 VFIO 驱动，确保 PF 已成功解除绑定并分配给虚拟机。</li></ul><p>5.2 <strong>虚拟机中无法识别 PF 网卡</strong></p><ul><li>检查虚拟机内的网络配置，确认 PF 是否已正确加载，并安装必要的驱动程序。</li></ul><p>5.3 <strong>性能问题</strong></p><ul><li>确保虚拟机配置中启用了 KVM 和 VFIO 驱动程序，确保最佳性能。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://docs.mellanox.com/">Mellanox ConnectX-6 Documentation</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9">Red Hat Enterprise Linux 9 Documentation</a></li><li><a href="https://libvirt.org/formatdomain.html">Libvirt Documentation</a></li><li><a href="https://www.qemu.org/documentation/">QEMU Documentation</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> PF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 SR-IOV VF 直通 (Passthrough)</title>
      <link href="/2024/08/14/rhel9.4_mlx_sriov_vf/"/>
      <url>/2024/08/14/rhel9.4_mlx_sriov_vf/</url>
      
        <content type="html"><![CDATA[<h1 id="在-ARM64-平台的-RHEL-9-4-上配置-Mellanox-ConnectX-6-网卡的-SR-IOV-VF-直通-Passthrough"><a href="#在-ARM64-平台的-RHEL-9-4-上配置-Mellanox-ConnectX-6-网卡的-SR-IOV-VF-直通-Passthrough" class="headerlink" title="在 ARM64 平台的 RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 SR-IOV VF 直通 (Passthrough)"></a>在 ARM64 平台的 RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 SR-IOV VF 直通 (Passthrough)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>在虚拟化环境中，Mellanox ConnectX-6 网卡的单根输入输出虚拟化（SR-IOV）功能允许将网卡的虚拟功能（Virtual Functions, VFs）分配给虚拟机，从而实现高效的网络性能和资源隔离。详细介绍了如何在 ARM64 平台的 RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 SR-IOV 虚拟功能 (VF) 直通。</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h2><p>适用于系统管理员和虚拟化技术人员，帮助他们在 RHEL 9.4 ARM64 系统上配置 Mellanox ConnectX-6 网卡的 SR-IOV 虚拟功能 (VF) 直通，以优化虚拟化环境中的网络性能。</p><h2 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h2><ul><li><strong>系统管理员</strong>：确保系统已正确安装必要的软件包，且系统硬件支持 IOMMU 和 SR-IOV 功能。</li><li><strong>操作员</strong>：按照##配置 Mellanox ConnectX-6 网卡的 SR-IOV VF 直通，并确保其正确运行。</li></ul><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h2><ul><li>运行 RHEL 9.4 操作系统的 ARM64 服务器。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>Mellanox ConnectX-6 网卡，并确保服务器固件支持 IOMMU 和 SR-IOV 功能。</li></ul><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><h3 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h3><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf update -y</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装必要的驱动和工具</strong></p><ul><li><p>安装 Mellanox 网卡的驱动程序和相关工具(如果已经安装mlx驱动直接跳过)：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install -y mlnx-ofed-basic</span><br></pre></td></tr></table></figure></li><li><p>安装完毕后，重启服务器以加载新安装的驱动：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></li></ul><p>1.3 <strong>检查 IOMMU 支持</strong></p><ul><li><p>确保系统的固件（Firmware&#x2F;BIOS）设置中已启用 IOMMU 支持。</p></li><li><p>确认 IOMMU 已在内核启动参数中启用：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo grubby --update-kernel=ALL --args=<span class="string">&quot;iommu.passthrough=on&quot;</span></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></li><li><p>重启后，使用以下命令确认 IOMMU 已启用：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i iommu</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-配置-Mellanox-ConnectX-6-的-SR-IOV"><a href="#2-配置-Mellanox-ConnectX-6-的-SR-IOV" class="headerlink" title="2. 配置 Mellanox ConnectX-6 的 SR-IOV"></a>2. <strong>配置 Mellanox ConnectX-6 的 SR-IOV</strong></h3><p>2.1 <strong>启用 SR-IOV 功能</strong></p><ul><li><p>使用 <code>lspci</code> 命令找到 Mellanox ConnectX-6 网卡的 PCI 总线地址：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep Mellanox</span><br></pre></td></tr></table></figure></li><li><p>记下类似 <code>0000:03:00.0</code> 的总线地址，这个地址表示网卡的物理功能（PF）。</p></li><li><p>在 <code>/sys/class/net/</code> 下找到对应的网卡接口（如 <code>enp3s0</code>），并配置启用 SR-IOV：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 8 | sudo <span class="built_in">tee</span> /sys/class/net/enp3s0/device/sriov_numvfs</span><br></pre></td></tr></table></figure></li><li><p>以上命令将在该网卡上启用 8 个虚拟功能（VFs）。可以根据需要调整数字。</p></li><li><p>可以通过下面的命令查询支持的最大值</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/class/net/enp3s0/device/sriov_totalvfs</span><br><span class="line">16</span><br></pre></td></tr></table></figure><p>2.2 <strong>验证 SR-IOV 配置</strong></p></li><li><p>使用 <code>ip link show</code> 或 <code>lspci | grep Mellanox</code> 命令，确认是否已创建 VFs：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip <span class="built_in">link</span> show enp3s0</span><br></pre></td></tr></table></figure></li><li><p>输出中应包含 <code>enp3s0</code> 及其下的 <code>vf 0</code> 至 <code>vf 7</code> 等信息。</p></li></ul><h3 id="3-配置-SR-IOV-VFs-的-Passthrough"><a href="#3-配置-SR-IOV-VFs-的-Passthrough" class="headerlink" title="3. 配置 SR-IOV VFs 的 Passthrough"></a>3. <strong>配置 SR-IOV VFs 的 Passthrough</strong></h3><p>3.1 <strong>识别并绑定 VF</strong></p><ul><li><p>使用 <code>lspci</code> 命令获取 SR-IOV VF 的 PCI 地址：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep Virtual</span><br></pre></td></tr></table></figure></li><li><p>将对应的 VF 通过 VFIO 驱动绑定：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe vfio</span><br><span class="line">sudo modprobe vfio-pci</span><br><span class="line">lspci -nn | grep Virtual <span class="comment">#查询[]中结果，例如[15b3:101e]</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:02.0&quot;</span> &gt; /sys/bus/pci/devices/0000\:03\:02.0/driver/unbind</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;15b3 101e&quot;</span> &gt; /sys/bus/pci/drivers/vfio-pci/new_id</span><br></pre></td></tr></table></figure><p>   或者</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe vfio</span><br><span class="line">sudo modprobe vfio-pci</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:02.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/drivers/mlx5_core/unbind</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:02.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/drivers/vfio-pci/bind</span><br></pre></td></tr></table></figure></li><li><p>确认绑定成功：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -nnk -d 15b3: | grep <span class="string">&quot;Kernel driver in use&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>输出应显示 <code>vfio-pci</code> 作为内核驱动。</p></li></ul><p>3.2 <strong>编辑虚拟机配置</strong></p><ul><li>使用 <code>virsh nodedev-list</code> 查找支持的设备   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pci_0000_03_02_0</span><br></pre></td></tr></table></figure></li><li>使用 <code>virsh nodedev-dumpxml pci_0000_03_02_0</code> 获取配置xml, 记录address   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;iommuGroup number=&#x27;62&#x27;&gt;</span><br><span class="line">  &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x03&#x27; slot=&#x27;0x02&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">&lt;/iommuGroup&gt;</span><br></pre></td></tr></table></figure></li><li>使用 <code>virsh edit</code> 或 <code>virt-manager</code> 将 VF 设备分配给虚拟机。示例 XML 配置：   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hostdev</span> <span class="attr">mode</span>=<span class="string">&#x27;subsystem&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">managed</span>=<span class="string">&#x27;yes&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x03&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x02&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x05&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hostdev</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>3.3 <strong>启用并启动虚拟机</strong></p><ul><li>编辑并保存虚拟机配置后，启动虚拟机：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virsh define /etc/libvirt/qemu/&lt;vm_name&gt;.xml</span><br><span class="line">virsh start &lt;vm_name&gt;</span><br></pre></td></tr></table></figure></li><li>在虚拟机中，使用 <code>ip link show</code> 或类似命令验证已分配的 VF 网卡。</li></ul><h3 id="4-维护与管理"><a href="#4-维护与管理" class="headerlink" title="4. 维护与管理"></a>4. <strong>维护与管理</strong></h3><p>4.1 <strong>释放 VF 资源</strong></p><ul><li>如果需要将 VF 资源从虚拟机中释放并返回主机，可以先关闭虚拟机并解除 VFIO 绑定：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">virsh shutdown &lt;vm_name&gt;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:02.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/drivers/vfio-pci/unbind</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:02.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/drivers/mlx5_core/bind</span><br></pre></td></tr></table></figure></li></ul><p>4.2 <strong>调整 VF 数量</strong></p><ul><li>如果需要更改启用的 VF 数量，可以编辑对应的 SR-IOV 配置：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &lt;new_number&gt; | sudo <span class="built_in">tee</span> /sys/class/net/enp3s0/device/sriov_numvfs</span><br></pre></td></tr></table></figure></li></ul><p>4.3 <strong>定期更新驱动</strong></p><ul><li>确保定期更新 Mellanox 驱动程序和固件，以获取最新的功能和性能改进：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf upgrade -y mlnx-ofed-basic</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-常见问题与故障排除"><a href="#5-常见问题与故障排除" class="headerlink" title="5. 常见问题与故障排除"></a>5. <strong>常见问题与故障排除</strong></h3><p>5.1 <strong>VF 无法绑定到虚拟机</strong></p><ul><li>检查是否已正确启用 IOMMU 和 SR-IOV 功能，确保 VFs 已成功创建并分配给虚拟机。</li></ul><p>5.2 <strong>虚拟机中无法识别 VF 网卡</strong></p><ul><li>检查虚拟机内的网络配置，确认 VF 是否已正确加载，并安装必要的驱动程序。</li></ul><p>5.3 <strong>性能问题</strong></p><ul><li>确保虚拟机配置中启用了 KVM 和 VFIO 驱动程序，确保最佳性能。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://docs.mellanox.com/">Mellanox ConnectX-6 Documentation</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9">Red Hat Enterprise Linux 9 Documentation</a></li><li><a href="https://libvirt.org/formatdomain.html">Libvirt Documentation</a></li><li><a href="https://www.qemu.org/documentation/">QEMU Documentation</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> SR-IOV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 `stress-ng` 进行系统压力测试</title>
      <link href="/2024/08/14/stress-ng_test/"/>
      <url>/2024/08/14/stress-ng_test/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-stress-ng-进行系统压力测试"><a href="#使用-stress-ng-进行系统压力测试" class="headerlink" title="使用 stress-ng 进行系统压力测试"></a>使用 <code>stress-ng</code> 进行系统压力测试</h1><hr><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p><code>stress-ng</code> 是一个功能强大的压力测试工具，能够对系统的 CPU、内存、I&#x2F;O、网络、磁盘等多个子系统进行深入测试。它可以帮助识别系统在极端条件下的稳定性问题，并用于评估硬件和软件的耐久性和性能。详细介绍了在 Linux 系统上安装、配置并运行 <code>stress-ng</code> 工具的过程，以进行全面的系统压力测试。</p><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h4><p>适用于需要验证系统硬件和软件稳定性的技术人员，尤其是需要测试 CPU、内存、I&#x2F;O、网络和磁盘性能的场景。</p><h4 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h4><ul><li><strong>系统管理员</strong>：确保系统已正确安装所有必需的依赖包，并具备执行测试所需的权限。</li><li><strong>操作员</strong>：按照本 SOP 正确执行 <code>stress-ng</code> 工具，确保测试顺利进行。</li></ul><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h4><ul><li>运行 Linux 操作系统的设备。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>有效的互联网连接以下载必要的软件包和工具。</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h4><h5 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h5><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装 <code>stress-ng</code> 工具</strong></p><ul><li><p><strong>在 Debian&#x2F;Ubuntu 系统上使用 <code>apt</code> 安装 <code>stress-ng</code>：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install stress-ng</span><br></pre></td></tr></table></figure></li><li><p><strong>在 RHEL&#x2F;CentOS 系统上使用 <code>yum</code> 安装 <code>stress-ng</code>：</strong></p><ul><li>首先，启用 EPEL 仓库（如果尚未启用）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure></li><li>然后安装 <code>stress-ng</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install stress-ng</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-配置与运行-stress-ng"><a href="#2-配置与运行-stress-ng" class="headerlink" title="2. 配置与运行 stress-ng"></a>2. <strong>配置与运行 <code>stress-ng</code></strong></h5><p>2.1 <strong>运行 CPU 压力测试</strong></p><ul><li>使用 <code>stress-ng</code> 工具对 CPU 进行压力测试。例如，以下命令将启动 4 个 CPU 工作线程，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --cpu 4 --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--cpu 4</code>：启动 4 个 CPU 工作线程。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.2 <strong>运行内存压力测试</strong></p><ul><li>对系统内存进行压力测试。例如，以下命令将启动 2 个内存工作线程，每个分配 256MB 内存，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --vm 2 --vm-bytes 256M --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--vm 2</code>：启动 2 个内存工作线程。</li><li><code>--vm-bytes 256M</code>：每个线程分配 256MB 内存。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.3 <strong>运行 I&#x2F;O 压力测试</strong></p><ul><li>对系统的 I&#x2F;O 操作进行压力测试。例如，以下命令将启动 4 个 I&#x2F;O 工作线程，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --io 4 --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--io 4</code>：启动 4 个 I&#x2F;O 工作线程。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.4 <strong>运行磁盘压力测试</strong></p><ul><li>对系统磁盘进行压力测试。例如，以下命令将启动 4 个磁盘工作线程，每个线程执行 10MB 的写操作，并持续运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --hdd 4 --hdd-bytes 10M --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--hdd 4</code>：启动 4 个磁盘工作线程。</li><li><code>--hdd-bytes 10M</code>：每个线程执行 10MB 的写操作。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.5 <strong>综合压力测试</strong></p><ul><li>运行包含多个子系统的综合压力测试。例如，以下命令将同时对 CPU、内存、I&#x2F;O 和磁盘进行压力测试，并持续运行 600 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --cpu 4 --vm 2 --vm-bytes 128M --io 2 --hdd 2 --hdd-bytes 5M --<span class="built_in">timeout</span> 600</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--cpu 4</code>：启动 4 个 CPU 工作线程。</li><li><code>--vm 2 --vm-bytes 128M</code>：启动 2 个内存工作线程，每个线程分配 128MB 内存。</li><li><code>--io 2</code>：启动 2 个 I&#x2F;O 工作线程。</li><li><code>--hdd 2 --hdd-bytes 5M</code>：启动 2 个磁盘工作线程，每个线程执行 5MB 的写操作。</li><li><code>--timeout 600</code>：测试持续 600 秒（10 分钟）。</li></ul></li></ul><p>2.6 <strong>生成性能报告</strong></p><ul><li>使用 <code>--metrics-brief</code> 选项生成一个简短的性能报告，显示测试的主要结果：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --cpu 4 --<span class="built_in">timeout</span> 300 --metrics-brief</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-监控与分析测试结果"><a href="#3-监控与分析测试结果" class="headerlink" title="3. 监控与分析测试结果"></a>3. <strong>监控与分析测试结果</strong></h5><p>3.1 <strong>监控测试进度</strong></p><ul><li>在测试过程中，可以在终端查看 <code>stress-ng</code> 的输出，监控测试的进展情况。</li></ul><p>3.2 <strong>分析测试结果</strong></p><ul><li><code>stress-ng</code> 工具本身可以生成详细的性能报告，您可以通过分析报告来了解系统在压力测试下的表现。</li></ul><p>3.3 <strong>保存测试日志</strong></p><ul><li>可以将测试日志保存到文件中，以便后续分析：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --cpu 4 --<span class="built_in">timeout</span> 300 --metrics-brief &gt; stress-ng-log.txt</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-优化与维护"><a href="#4-优化与维护" class="headerlink" title="4. 优化与维护"></a>4. <strong>优化与维护</strong></h5><p>4.1 <strong>定期测试</strong></p><ul><li>建议定期运行 <code>stress-ng</code> 工具，特别是在系统进行重大变更（如硬件升级或系统更新）之后，以确保系统的持续稳定性。</li></ul><p>4.2 <strong>调整参数</strong></p><ul><li>根据系统的具体需求和测试目标，调整 <code>stress-ng</code> 的参数，以便更好地检测系统潜在问题。</li></ul><h5 id="5-常见问题与故障排除"><a href="#5-常见问题与故障排除" class="headerlink" title="5. 常见问题与故障排除"></a>5. <strong>常见问题与故障排除</strong></h5><p>5.1 <strong>测试失败或系统崩溃</strong></p><ul><li>如果在测试过程中系统崩溃或测试失败，请检查系统日志以确定故障原因。可能需要降低测试负荷，或排查硬件问题。</li></ul><p>5.2 <strong>系统资源不足</strong></p><ul><li>如果在测试过程中出现内存或 CPU 资源不足的错误，考虑减少分配给测试的资源量，或调整系统配置。</li></ul><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h4><ul><li><a href="https://github.com/ColinIanKing/stress-ng">stress-ng GitHub Repository</a></li><li><a href="https://linux.die.net/man/1/stress-ng">Linux Performance Tools</a></li><li><a href="https://linuxconfig.org/bash-scripting-tutorial-for-beginners">Bash Scripting Basics</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> stress-ng </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 `stress` 进行系统压力测试</title>
      <link href="/2024/08/14/stress_test/"/>
      <url>/2024/08/14/stress_test/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-stress-进行系统压力测试"><a href="#使用-stress-进行系统压力测试" class="headerlink" title="使用 stress 进行系统压力测试"></a>使用 <code>stress</code> 进行系统压力测试</h1><hr><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p><code>stress</code> 是一个简单但功能强大的工具，用于对系统的 CPU、内存、I&#x2F;O 和磁盘进行压力测试。通过施加高负荷，它可以帮助识别系统在极端条件下的稳定性问题。详细介绍了在 Linux 系统上安装、配置并运行 <code>stress</code> 工具的过程，以进行全面的系统压力测试。</p><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h4><p>适用于需要验证系统硬件和软件稳定性的技术人员，尤其是在测试 CPU、内存、I&#x2F;O 和磁盘性能时使用。</p><h4 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h4><ul><li><strong>系统管理员</strong>：确保系统已正确安装所有必需的依赖包，并具备执行测试所需的权限。</li><li><strong>操作员</strong>：按照本 SOP 正确执行 <code>stress</code> 工具，确保测试顺利进行。</li></ul><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h4><ul><li>运行 Linux 操作系统的设备。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>有效的互联网连接以下载必要的软件包和工具。</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h4><h5 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h5><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装 Stress 工具</strong></p><ul><li><p><strong>在 Debian&#x2F;Ubuntu 系统上使用 <code>apt</code> 安装 <code>stress</code>：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install stress</span><br></pre></td></tr></table></figure></li><li><p><strong>在 RHEL&#x2F;CentOS 系统上使用 <code>yum</code> 安装 <code>stress</code>：</strong></p><ul><li>首先，启用 EPEL 仓库（如果尚未启用）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure></li><li>然后安装 <code>stress</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install stress</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-配置与运行-stress"><a href="#2-配置与运行-stress" class="headerlink" title="2. 配置与运行 stress"></a>2. <strong>配置与运行 <code>stress</code></strong></h5><p>2.1 <strong>运行 CPU 压力测试</strong></p><ul><li>使用 <code>stress</code> 工具对 CPU 进行压力测试。例如，以下命令将启动 4 个 CPU 工作线程，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --cpu 4 --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--cpu 4</code>：启动 4 个 CPU 工作线程。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.2 <strong>运行内存压力测试</strong></p><ul><li>对系统内存进行压力测试。例如，以下命令将启动 2 个内存工作线程，每个分配 256MB 内存，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --vm 2 --vm-bytes 256M --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--vm 2</code>：启动 2 个内存工作线程。</li><li><code>--vm-bytes 256M</code>：每个线程分配 256MB 内存。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.3 <strong>运行 I&#x2F;O 压力测试</strong></p><ul><li>对系统的 I&#x2F;O 操作进行压力测试。例如，以下命令将启动 4 个 I&#x2F;O 工作线程，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --io 4 --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--io 4</code>：启动 4 个 I&#x2F;O 工作线程。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.4 <strong>运行磁盘压力测试</strong></p><ul><li>对系统磁盘进行压力测试。例如，以下命令将启动 4 个磁盘工作线程，每个线程执行 10MB 的写操作，并持续运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --hdd 4 --hdd-bytes 10M --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--hdd 4</code>：启动 4 个磁盘工作线程。</li><li><code>--hdd-bytes 10M</code>：每个线程执行 10MB 的写操作。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><h5 id="3-监控与分析测试结果"><a href="#3-监控与分析测试结果" class="headerlink" title="3. 监控与分析测试结果"></a>3. <strong>监控与分析测试结果</strong></h5><p>3.1 <strong>监控测试进度</strong></p><ul><li>在测试过程中，可以在终端查看 <code>stress</code> 输出，监控测试的进展情况。</li></ul><p>3.2 <strong>分析测试结果</strong></p><ul><li><code>stress</code> 工具本身不会生成详细的测试报告，但可以通过系统日志和资源监控工具（如 <code>htop</code> 或 <code>dstat</code>）来分析系统在压力测试下的表现。</li></ul><h5 id="4-优化与维护"><a href="#4-优化与维护" class="headerlink" title="4. 优化与维护"></a>4. <strong>优化与维护</strong></h5><p>4.1 <strong>定期测试</strong></p><ul><li>建议定期运行 <code>stress</code> 工具，特别是在系统进行重大变更（如硬件升级或系统更新）之后，以确保系统的持续稳定性。</li></ul><p>4.2 <strong>调整参数</strong></p><ul><li>根据系统的具体需求和测试目标，调整 <code>stress</code> 的参数，以便更好地检测系统潜在问题。</li></ul><h5 id="5-常见问题与故障排除"><a href="#5-常见问题与故障排除" class="headerlink" title="5. 常见问题与故障排除"></a>5. <strong>常见问题与故障排除</strong></h5><p>5.1 <strong>测试失败或系统崩溃</strong></p><ul><li>如果在测试过程中系统崩溃或测试失败，请检查系统日志以确定故障原因。可能需要降低测试负荷，或排查硬件问题。</li></ul><p>5.2 <strong>系统资源不足</strong></p><ul><li>如果在测试过程中出现内存或 CPU 资源不足的错误，考虑减少分配给测试的资源量，或调整系统配置。</li></ul><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h4><ul><li><a href="https://github.com/stress-ng/stress-ng">Stress GitHub Repository</a></li><li><a href="https://linux.die.net/man/1/stress">Linux Performance Tools</a></li><li><a href="https://linuxconfig.org/bash-scripting-tutorial-for-beginners">Bash Scripting Basics</a></li></ul><hr><p>本 SOP 提供了使用 <code>stress</code> 工具进行系统压力测试的详细步骤，旨在帮助用户识别和解决潜在的系统稳定性问题。通过这些测试，您可以确保系统在高负荷下的性能表现，并及时采取措施修复可能的故障。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> stress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPv4 和 IPv6 路由管理</title>
      <link href="/2024/08/07/IPv4_and_IPv6_Routing_Tutorial/"/>
      <url>/2024/08/07/IPv4_and_IPv6_Routing_Tutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="IPv4-和-IPv6-路由管理"><a href="#IPv4-和-IPv6-路由管理" class="headerlink" title="IPv4 和 IPv6 路由管理"></a>IPv4 和 IPv6 路由管理</h1><hr><p>Linux 系统中 IPv4 和 IPv6 路由的基本操作，包括查看、添加和删除路由。</p><h2 id="IPv4-路由"><a href="#IPv4-路由" class="headerlink" title="IPv4 路由"></a>IPv4 路由</h2><h3 id="1-查看-IPv4-路由表"><a href="#1-查看-IPv4-路由表" class="headerlink" title="1. 查看 IPv4 路由表"></a>1. 查看 IPv4 路由表</h3><p>使用下面的命令来查看当前的 IPv4 路由表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route</span><br></pre></td></tr></table></figure><h3 id="2-添加-IPv4-路由"><a href="#2-添加-IPv4-路由" class="headerlink" title="2. 添加 IPv4 路由"></a>2. 添加 IPv4 路由</h3><p>根据网络配置需求，可以使用以下命令添加路由：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route add [目的网络/掩码] via [网关地址] dev [网卡设备名]</span><br></pre></td></tr></table></figure><p>例如，如果想要所有发往 <code>192.168.1.0/24</code> 网络的数据包都通过网关 <code>192.168.0.1</code> 和网卡 <code>eth0</code> 发送，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route add 192.168.1.0/24 via 192.168.0.1 dev eth0</span><br></pre></td></tr></table></figure><h3 id="3-删除-IPv4-路由"><a href="#3-删除-IPv4-路由" class="headerlink" title="3. 删除 IPv4 路由"></a>3. 删除 IPv4 路由</h3><p>从路由表中删除一条路由，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route del [目的网络/掩码]</span><br></pre></td></tr></table></figure><p>例如，删除之前添加的路由：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route del 192.168.1.0/24</span><br></pre></td></tr></table></figure><h2 id="IPv6-路由"><a href="#IPv6-路由" class="headerlink" title="IPv6 路由"></a>IPv6 路由</h2><h3 id="1-查看-IPv6-路由表"><a href="#1-查看-IPv6-路由表" class="headerlink" title="1. 查看 IPv6 路由表"></a>1. 查看 IPv6 路由表</h3><p>使用下面的命令来查看当前的 IPv6 路由表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip -6 route</span><br></pre></td></tr></table></figure><h3 id="2-添加-IPv6-路由"><a href="#2-添加-IPv6-路由" class="headerlink" title="2. 添加 IPv6 路由"></a>2. 添加 IPv6 路由</h3><p>根据网络配置需求，可以使用以下命令添加路由：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip -6 route add [目的地址/前缀] via [网关地址] dev [网卡设备名]</span><br></pre></td></tr></table></figure><p>例如，如果想要所有发往 <code>2001:db8::/32</code> 网络的数据包都通过网关 <code>fe80::1</code> 和网卡 <code>eth0</code> 发送，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip -6 route add 2001:db8::/32 via fe80::1 dev eth0</span><br></pre></td></tr></table></figure><h3 id="3-删除-IPv6-路由"><a href="#3-删除-IPv6-路由" class="headerlink" title="3. 删除 IPv6 路由"></a>3. 删除 IPv6 路由</h3><p>从路由表中删除一条路由，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip -6 route del [目的地址/前缀]</span><br></pre></td></tr></table></figure><p>例如，删除之前添加的路由：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip -6 route del 2001:db8::/32</span><br></pre></td></tr></table></figure><h2 id="持久化路由设置"><a href="#持久化路由设置" class="headerlink" title="持久化路由设置"></a>持久化路由设置</h2><p>为了使路由设置在系统重启后依然生效，可以将命令添加到启动脚本中，或者在配置文件中设置。这具体依赖于使用的 Linux 发行版。</p><h2 id="调试和故障排查"><a href="#调试和故障排查" class="headerlink" title="调试和故障排查"></a>调试和故障排查</h2><p>使用以下命令可以帮助调试和确认路由设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip route show</span><br><span class="line">ip -6 route show</span><br></pre></td></tr></table></figure><p>或者，使用 <code>ping</code> 或 <code>ping6</code> 测试网络连通性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping [IPv4地址]</span><br><span class="line">ping6 [IPv6地址]</span><br></pre></td></tr></table></figure><p>确保有适当的权限执行这些命令，特别是使用 <code>sudo</code> 来获取必要的管理员权限。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带宽和存储单位转换</title>
      <link href="/2024/08/07/bandwidth_storage_convert/"/>
      <url>/2024/08/07/bandwidth_storage_convert/</url>
      
        <content type="html"><![CDATA[<h1 id="带宽和存储单位转换"><a href="#带宽和存储单位转换" class="headerlink" title="带宽和存储单位转换"></a>带宽和存储单位转换</h1><h2 id="带宽单位转换（基于十进制）"><a href="#带宽单位转换（基于十进制）" class="headerlink" title="带宽单位转换（基于十进制）"></a>带宽单位转换（基于十进制）</h2><ol><li><strong>1 字节 (B) &#x3D; 8 比特 (b)</strong></li><li><strong>1 千比特 (Kb) &#x3D; 1000 比特 (b)</strong></li><li><strong>1 兆比特 (Mb) &#x3D; 1000 千比特 (Kb)</strong></li><li><strong>1 吉比特 (Gb) &#x3D; 1000 兆比特 (Mb)</strong></li><li><strong>1 太比特 (Tb) &#x3D; 1000 吉比特 (Gb)</strong></li></ol><h2 id="存储单位转换（基于二进制）"><a href="#存储单位转换（基于二进制）" class="headerlink" title="存储单位转换（基于二进制）"></a>存储单位转换（基于二进制）</h2><ol><li><strong>1 千字节 (KiB) &#x3D; 1024 字节 (B)</strong></li><li><strong>1 兆字节 (MiB) &#x3D; 1024 千字节 (KiB)</strong></li><li><strong>1 吉字节 (GiB) &#x3D; 1024 兆字节 (MiB)</strong></li><li><strong>1 太字节 (TiB) &#x3D; 1024 吉字节 (GiB)</strong></li></ol><h2 id="带宽和存储的相互转换"><a href="#带宽和存储的相互转换" class="headerlink" title="带宽和存储的相互转换"></a>带宽和存储的相互转换</h2><h3 id="示例1：带宽转存储"><a href="#示例1：带宽转存储" class="headerlink" title="示例1：带宽转存储"></a>示例1：带宽转存储</h3><p>假设有一个文件大小为100 MiB，下载速度为20 Mbps，需要多长时间下载完这个文件？</p><ol><li><p><strong>转换文件大小为比特</strong>：</p><ul><li>100 MiB &#x3D; 100 × 1024 × 1024 × 8 &#x3D; 838,860,800 比特 (b)</li></ul></li><li><p><strong>计算下载时间</strong>：</p><ul><li>时间 (秒) &#x3D; 文件大小 (比特) &#x2F; 带宽 (比特每秒)</li><li>时间 &#x3D; 838,860,800 b &#x2F; 20,000,000 bps &#x3D; 41.94 秒</li></ul></li></ol><h3 id="示例2：存储转带宽"><a href="#示例2：存储转带宽" class="headerlink" title="示例2：存储转带宽"></a>示例2：存储转带宽</h3><p>假设有一个网络带宽为50 Mbps，每秒能够传输多少 GiB 的数据？</p><ol><li><p><strong>转换带宽为字节每秒</strong>：</p><ul><li>50 Mbps &#x3D; 50 × 1000 × 1000 &#x2F; 8 &#x3D; 6,250,000 字节每秒 (Bps)</li></ul></li><li><p><strong>转换为GiB每秒</strong>：</p><ul><li>6,250,000 Bps &#x3D; 6,250,000 &#x2F; 1024 &#x2F; 1024 &#x2F; 1024 &#x3D; 0.0058 GiB 每秒</li></ul></li></ol><p>通过以上示例可以看到，带宽和存储单位可以通过字节和比特之间的转换进行相互转换。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numactl 操作流程</title>
      <link href="/2024/08/07/numactl_sop/"/>
      <url>/2024/08/07/numactl_sop/</url>
      
        <content type="html"><![CDATA[<h1 id="numactl-操作流程"><a href="#numactl-操作流程" class="headerlink" title="numactl 操作流程"></a><code>numactl</code> 操作流程</h1><hr><h2 id="1-检查NUMA节点信息"><a href="#1-检查NUMA节点信息" class="headerlink" title="1. 检查NUMA节点信息"></a>1. 检查NUMA节点信息</h2><p>在进行任何绑定操作之前，先检查系统的NUMA节点信息，以了解可用的CPU和内存节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --hardware</span><br></pre></td></tr></table></figure><p>记录输出信息，确保了解系统中所有NUMA节点及其CPU核心分布。</p><h2 id="2-确定需要绑定的CPU核心和NUMA节点"><a href="#2-确定需要绑定的CPU核心和NUMA节点" class="headerlink" title="2. 确定需要绑定的CPU核心和NUMA节点"></a>2. 确定需要绑定的CPU核心和NUMA节点</h2><p>根据应用程序的需求和系统的NUMA节点分布，确定需要绑定的CPU核心和内存节点。例如，假设需要绑定到CPU 2和3，并使用NUMA节点0上的内存。</p><h2 id="3-绑定CPU核心"><a href="#3-绑定CPU核心" class="headerlink" title="3. 绑定CPU核心"></a>3. 绑定CPU核心</h2><p>将应用程序绑定到特定的CPU核心，以提高CPU利用率和性能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --physcpubind=2,3 your_command</span><br></pre></td></tr></table></figure><p>例如，运行名为 <code>my_program</code> 的应用程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --physcpubind=2,3 ./my_program</span><br></pre></td></tr></table></figure><h2 id="4-绑定NUMA节点内存"><a href="#4-绑定NUMA节点内存" class="headerlink" title="4. 绑定NUMA节点内存"></a>4. 绑定NUMA节点内存</h2><p>如果还需要绑定到特定的NUMA节点内存，使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --membind=0 your_command</span><br></pre></td></tr></table></figure><p>例如，运行名为 <code>my_program</code> 的应用程序，并绑定到NUMA节点0的内存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --physcpubind=2,3 --membind=0 ./my_program</span><br></pre></td></tr></table></figure><h2 id="5-验证绑定结果"><a href="#5-验证绑定结果" class="headerlink" title="5. 验证绑定结果"></a>5. 验证绑定结果</h2><p>运行以下命令来检查进程的CPU和内存绑定情况，确保绑定成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --show</span><br></pre></td></tr></table></figure><h2 id="6-测试和监控"><a href="#6-测试和监控" class="headerlink" title="6. 测试和监控"></a>6. 测试和监控</h2><p>运行应用程序后，监控其性能和资源使用情况，确保绑定操作达到了预期效果。可以使用以下工具进行监控：</p><ul><li><code>top</code></li><li><code>htop</code></li><li><code>numastat</code></li><li><code>perf</code></li></ul><h1 id="示例SOP"><a href="#示例SOP" class="headerlink" title="示例SOP"></a>示例SOP</h1><h2 id="步骤1：检查NUMA节点信息"><a href="#步骤1：检查NUMA节点信息" class="headerlink" title="步骤1：检查NUMA节点信息"></a>步骤1：检查NUMA节点信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --hardware</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">available: 2 nodes (0-1)</span><br><span class="line">node 0 cpus: 0 1 2 3</span><br><span class="line">node 0 size: 32632 MB</span><br><span class="line">node 0 free: 12345 MB</span><br><span class="line">node 1 cpus: 4 5 6 7</span><br><span class="line">node 1 size: 32768 MB</span><br><span class="line">node 1 free: 23456 MB</span><br></pre></td></tr></table></figure><h2 id="步骤2：确定绑定的CPU核心和NUMA节点"><a href="#步骤2：确定绑定的CPU核心和NUMA节点" class="headerlink" title="步骤2：确定绑定的CPU核心和NUMA节点"></a>步骤2：确定绑定的CPU核心和NUMA节点</h2><p>假设需要绑定到CPU 2和3，并使用NUMA节点0上的内存。</p><h2 id="步骤3：绑定CPU核心"><a href="#步骤3：绑定CPU核心" class="headerlink" title="步骤3：绑定CPU核心"></a>步骤3：绑定CPU核心</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --physcpubind=2,3 ./my_program</span><br></pre></td></tr></table></figure><h2 id="步骤4：绑定NUMA节点内存"><a href="#步骤4：绑定NUMA节点内存" class="headerlink" title="步骤4：绑定NUMA节点内存"></a>步骤4：绑定NUMA节点内存</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --physcpubind=2,3 --membind=0 ./my_program</span><br></pre></td></tr></table></figure><h2 id="步骤5：验证绑定结果"><a href="#步骤5：验证绑定结果" class="headerlink" title="步骤5：验证绑定结果"></a>步骤5：验证绑定结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --show</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">policy: default</span><br><span class="line">physcpubind: 2 3 </span><br><span class="line">cpubind: 0 </span><br><span class="line">membind: 0 </span><br></pre></td></tr></table></figure><h2 id="步骤6：测试和监控"><a href="#步骤6：测试和监控" class="headerlink" title="步骤6：测试和监控"></a>步骤6：测试和监控</h2><p>使用 <code>htop</code> 或 <code>numastat</code> 等工具监控应用程序的性能和资源使用情况。</p><p>通过上述步骤，可以确保应用程序在NUMA系统上得到优化运行。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Numactl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在 Linux 系统中进入 S0、S1、S2、S3、S4 和 S5 模式</title>
      <link href="/2024/08/06/linux_power_state_mode/"/>
      <url>/2024/08/06/linux_power_state_mode/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在-Linux-系统中进入-S0、S1、S2、S3、S4-和-S5-模式"><a href="#如何在-Linux-系统中进入-S0、S1、S2、S3、S4-和-S5-模式" class="headerlink" title="如何在 Linux 系统中进入 S0、S1、S2、S3、S4 和 S5 模式"></a>如何在 Linux 系统中进入 S0、S1、S2、S3、S4 和 S5 模式</h1><hr><h2 id="检查系统支持的电源模式"><a href="#检查系统支持的电源模式" class="headerlink" title="检查系统支持的电源模式"></a>检查系统支持的电源模式</h2><p>在进入这些模式之前，可以使用以下命令来检查系统支持哪些电源状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/power/state</span><br></pre></td></tr></table></figure><p>该命令的输出可能包括：</p><ul><li><code>freeze</code>：冻结当前任务，不关闭任何设备。</li><li><code>standby</code>：进入 S1 模式。</li><li><code>mem</code>：进入 S3 模式。</li><li><code>disk</code>：进入 S4 模式，即休眠，将内存内容保存到磁盘。</li></ul><h2 id="各电源模式简介"><a href="#各电源模式简介" class="headerlink" title="各电源模式简介"></a>各电源模式简介</h2><ul><li>S0（工作状态）：系统处于完全开机状态，所有部件都在运行。</li><li>S1（待机）：CPU 停止执行指令，但内存和其他关键部件保持供电。</li><li>S2（待机）：CPU 和系统缓存停止供电，但内存保持供电。</li><li>S3（挂起到内存）：系统状态保存到内存中，除内存外的所有部件都断电。</li><li>S4（休眠）：系统状态保存到硬盘，所有部件断电。系统恢复时从硬盘读取状态。</li><li>S5（软关机）：系统完全关机，但电源仍然供电，可以通过电源按钮启动。</li></ul><h2 id="进入各电源模式的命令"><a href="#进入各电源模式的命令" class="headerlink" title="进入各电源模式的命令"></a>进入各电源模式的命令</h2><ul><li><p>S0 模式（工作状态）<br>无需特殊命令，系统开机时即处于 S0 模式。</p></li><li><p>S1 模式（Standby）<br>使用 echo 命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> standby | sudo <span class="built_in">tee</span> /sys/power/state</span><br></pre></td></tr></table></figure><ul><li>S2 模式（待机）<br>请注意，S2 模式在很多系统上并不常用或不被支持。如果系统支持，可以尝试：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> standby | sudo <span class="built_in">tee</span> /sys/power/state</span><br></pre></td></tr></table></figure><ul><li>S3 模式（Suspend-to-RAM）</li></ul><p><strong>方法一：使用 systemctl 命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">suspend</span></span><br></pre></td></tr></table></figure><p><strong>方法二：使用 echo 命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> mem | sudo <span class="built_in">tee</span> /sys/power/state</span><br></pre></td></tr></table></figure><ul><li>S4 模式（休眠）<br>使用 systemctl 命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl hibernate</span><br></pre></td></tr></table></figure><p>或者使用 echo 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> disk | sudo <span class="built_in">tee</span> /sys/power/state</span><br></pre></td></tr></table></figure><ul><li>S5 模式（软关机）<br>使用 systemctl 命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl poweroff</span><br></pre></td></tr></table></figure><h2 id="示例操作"><a href="#示例操作" class="headerlink" title="示例操作"></a>示例操作</h2><p><strong>1. 检查系统支持的电源模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/power/state</span><br><span class="line">freeze standby mem disk</span><br></pre></td></tr></table></figure><p><strong>2. 进入 S1 模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> standby | sudo <span class="built_in">tee</span> /sys/power/state</span><br></pre></td></tr></table></figure><p><strong>3. 进入 S3 模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">suspend</span></span><br></pre></td></tr></table></figure><p><strong>4. 进入 S4 模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl hibernate</span><br></pre></td></tr></table></figure><p><strong>5. 进入 S5 模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl poweroff</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>硬件支持：确保你的硬件支持相应的电源模式。</p><p>数据保存：进入这些模式前保存所有未保存的工作，以避免数据丢失。</p><p>驱动支持：有些系统和设备驱动可能对某些电源模式支持不完善，可能会导致恢复时出现问题。 </p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 连接 USB 串口教程</title>
      <link href="/2024/08/05/Linux_USB_Serial_Tutorial/"/>
      <url>/2024/08/05/Linux_USB_Serial_Tutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-连接-USB-串口教程"><a href="#Linux-连接-USB-串口教程" class="headerlink" title="Linux 连接 USB 串口教程"></a>Linux 连接 USB 串口教程</h1><hr><p>在Linux系统中，连接USB串口设备通常需要以下几个步骤：</p><h2 id="1-确认系统识别到USB串口设备"><a href="#1-确认系统识别到USB串口设备" class="headerlink" title="1. 确认系统识别到USB串口设备"></a>1. 确认系统识别到USB串口设备</h2><p>插入USB串口设备后，可以使用 <code>dmesg</code> 命令来查看系统是否识别到该设备。输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep ttyUSB</span><br></pre></td></tr></table></figure><p>应该看到类似以下的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[12345.678901] usb 1-1: cp210x converter now attached to ttyUSB0</span><br></pre></td></tr></table></figure><p>这表示系统已将USB串口设备识别为 <code>/dev/ttyUSB0</code>。</p><h2 id="2-安装必要的软件"><a href="#2-安装必要的软件" class="headerlink" title="2. 安装必要的软件"></a>2. 安装必要的软件</h2><p>使用USB串口设备通常需要安装 <code>screen</code> 或 <code>minicom</code> 等终端仿真软件。你可以使用以下命令来安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install screen</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install minicom</span><br></pre></td></tr></table></figure><h2 id="3-连接到USB串口设备"><a href="#3-连接到USB串口设备" class="headerlink" title="3. 连接到USB串口设备"></a>3. 连接到USB串口设备</h2><h3 id="使用-screen"><a href="#使用-screen" class="headerlink" title="使用 screen"></a>使用 screen</h3><p>可以使用 <code>screen</code> 命令连接到USB串口设备。例如，如果设备被识别为 <code>/dev/ttyUSB0</code>，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen /dev/ttyUSB0 115200</span><br></pre></td></tr></table></figure><p>这里的 <code>115200</code> 是波特率，根据你的设备配置进行调整。</p><h3 id="使用-minicom"><a href="#使用-minicom" class="headerlink" title="使用 minicom"></a>使用 minicom</h3><p>首先，配置 <code>minicom</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo minicom -s</span><br></pre></td></tr></table></figure><p>在配置界面中，选择“串口设置”，然后设置串口设备为 <code>/dev/ttyUSB0</code>，并设置相应的波特率。</p><p>配置完成后，选择“保存并退出”。然后可以使用以下命令连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minicom</span><br></pre></td></tr></table></figure><h2 id="4-退出连接"><a href="#4-退出连接" class="headerlink" title="4. 退出连接"></a>4. 退出连接</h2><h3 id="使用-screen-1"><a href="#使用-screen-1" class="headerlink" title="使用 screen"></a>使用 screen</h3><p>要退出 <code>screen</code> 会话，按 <code>Ctrl-a</code> 然后按 <code>k</code>，再按 <code>y</code> 确认。</p><h3 id="使用-minicom-1"><a href="#使用-minicom-1" class="headerlink" title="使用 minicom"></a>使用 minicom</h3><p>要退出 <code>minicom</code>，按 <code>Ctrl-a</code> 然后按 <code>q</code>，再选择“是”确认退出。</p><hr><p>以上就是在Linux系统中连接USB串口设备的基本步骤。</p><h2 id="DB9-串口线序"><a href="#DB9-串口线序" class="headerlink" title="DB9 串口线序"></a>DB9 串口线序</h2><h3 id="DB9公头（Male）针脚排列"><a href="#DB9公头（Male）针脚排列" class="headerlink" title="DB9公头（Male）针脚排列"></a>DB9公头（Male）针脚排列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5  4  3  2  1</span><br><span class="line"> ●  ●  ●  ●  ●</span><br><span class="line">  9  8  7  6</span><br><span class="line"> ●  ●  ●  ● </span><br></pre></td></tr></table></figure><h3 id="DB9母头（Female）针脚排列"><a href="#DB9母头（Female）针脚排列" class="headerlink" title="DB9母头（Female）针脚排列"></a>DB9母头（Female）针脚排列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1  2  3  4  5</span><br><span class="line"> ●  ●  ●  ●  ●</span><br><span class="line">  6  7  8  9</span><br><span class="line"> ●  ●  ●  ● </span><br></pre></td></tr></table></figure><h3 id="针脚定义"><a href="#针脚定义" class="headerlink" title="针脚定义"></a>针脚定义</h3><table><thead><tr><th>针脚编号</th><th>信号名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>DCD (Data Carrier Detect)</td><td>数据载波检测</td></tr><tr><td>2</td><td>RXD (Receive Data)</td><td>接收数据</td></tr><tr><td>3</td><td>TXD (Transmit Data)</td><td>发送数据</td></tr><tr><td>4</td><td>DTR (Data Terminal Ready)</td><td>数据终端准备好</td></tr><tr><td>5</td><td>GND (Ground)</td><td>信号地</td></tr><tr><td>6</td><td>DSR (Data Set Ready)</td><td>数据设置准备好</td></tr><tr><td>7</td><td>RTS (Request to Send)</td><td>请求发送</td></tr><tr><td>8</td><td>CTS (Clear to Send)</td><td>清除发送</td></tr><tr><td>9</td><td>RI (Ring Indicator)</td><td>振铃指示</td></tr></tbody></table><h3 id="常用连接"><a href="#常用连接" class="headerlink" title="常用连接"></a>常用连接</h3><h4 id="1-直连线（也称为直通线）"><a href="#1-直连线（也称为直通线）" class="headerlink" title="1. 直连线（也称为直通线）"></a>1. 直连线（也称为直通线）</h4><ul><li>这种连接方式通常用于PC与调制解调器（Modem）之间的连接。</li><li>直连线的针脚对应关系如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DB9公头 (Male)       DB9母头 (Female)</span><br><span class="line">2 (RXD)  &lt;--------&gt;  2 (RXD)</span><br><span class="line">3 (TXD)  &lt;--------&gt;  3 (TXD)</span><br><span class="line">5 (GND)  &lt;--------&gt;  5 (GND)</span><br><span class="line">7 (RTS)  &lt;--------&gt;  7 (RTS)</span><br><span class="line">8 (CTS)  &lt;--------&gt;  8 (CTS)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-交叉线（也称为null-modem线）"><a href="#2-交叉线（也称为null-modem线）" class="headerlink" title="2. 交叉线（也称为null modem线）"></a>2. 交叉线（也称为null modem线）</h4><ul><li>这种连接方式用于PC与PC之间，或PC与串口设备之间的直接通信。</li><li>交叉线的针脚对应关系如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DB9公头 (Male)       DB9公头 (Male)</span><br><span class="line">2 (RXD)  &lt;--------&gt;  3 (TXD)</span><br><span class="line">3 (TXD)  &lt;--------&gt;  2 (RXD)</span><br><span class="line">5 (GND)  &lt;--------&gt;  5 (GND)</span><br><span class="line">7 (RTS)  &lt;--------&gt;  8 (CTS)</span><br><span class="line">8 (CTS)  &lt;--------&gt;  7 (RTS)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Serial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RHEL9 网络配置</title>
      <link href="/2024/07/29/RHEL9_network_config/"/>
      <url>/2024/07/29/RHEL9_network_config/</url>
      
        <content type="html"><![CDATA[<h1 id="RHEL9-网络配置"><a href="#RHEL9-网络配置" class="headerlink" title="RHEL9 网络配置"></a>RHEL9 网络配置</h1><hr><h2 id="开关interface和profile"><a href="#开关interface和profile" class="headerlink" title="开关interface和profile"></a>开关interface和profile</h2><ol><li><p><strong>获取网络状态</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection</span><br><span class="line">NAME           UUID                                  TYPE      DEVICE</span><br><span class="line">Profile 2      21906cd8-c04d-45fd-9b7f-e6e85c43f891  ethernet  enP21p1s0f1np1</span><br><span class="line">enP21s17f1np1  f9ed821f-f3db-46ea-90fd-13dd74dc5587  ethernet  --</span><br></pre></td></tr></table></figure></li><li><p><strong>ifdown profile</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ifdown &quot;Profile 2&quot;</span><br><span class="line">Connection &#x27;Profile 2&#x27; successfully deactivated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/7)</span><br></pre></td></tr></table></figure></li><li><p><strong>link down interface</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ip link set enP21p1s0f1np1 down</span><br></pre></td></tr></table></figure></li><li><p><strong>link up interface</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ip link set enP21p1s0f1np1 up</span><br></pre></td></tr></table></figure></li><li><p><strong>ifup interface</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ifup &quot;Profile 2&quot;</span><br><span class="line">Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/8)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>/etc/fstab 文件配置教程</title>
      <link href="/2024/07/28/fstab_config/"/>
      <url>/2024/07/28/fstab_config/</url>
      
        <content type="html"><![CDATA[<h1 id="etc-fstab-文件配置教程"><a href="#etc-fstab-文件配置教程" class="headerlink" title="/etc/fstab 文件配置教程"></a><code>/etc/fstab</code> 文件配置教程</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>/etc/fstab</code> 文件用于定义系统在启动时如何自动挂载各种文件系统。这个文件在 Linux 系统中非常重要，它决定了系统启动时哪些设备将被挂载到哪些挂载点。</p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p><code>/etc/fstab</code> 文件的每一行代表一个文件系统的挂载配置，每行包含六个字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;文件系统&gt; &lt;挂载点&gt; &lt;类型&gt; &lt;选项&gt; &lt;转储&gt; &lt;自检&gt;</span><br></pre></td></tr></table></figure><h3 id="字段解释"><a href="#字段解释" class="headerlink" title="字段解释"></a>字段解释</h3><ol><li><p><strong>文件系统（File System）：</strong></p><ul><li>设备文件或分区。例如：<code>/dev/sda1</code>，<code>UUID=xxxx-xxxx</code>，<code>LABEL=home</code>。</li></ul></li><li><p><strong>挂载点（Mount Point）：</strong></p><ul><li>文件系统挂载到的目录。例如：<code>/</code>，<code>/home</code>，<code>/mnt/backup</code>。</li></ul></li><li><p><strong>文件系统类型（Filesystem Type）：</strong></p><ul><li>指定文件系统类型。例如：<code>ext4</code>，<code>ntfs</code>，<code>vfat</code>。</li></ul></li><li><p><strong>挂载选项（Mount Options）：</strong></p><ul><li>挂载时的选项，多个选项使用逗号分隔。例如：<code>defaults</code>，<code>ro</code>（只读），<code>noexec</code>（不可执行）。</li></ul></li><li><p><strong>转储频率（Dump Frequency）：</strong></p><ul><li>数字，表示是否需要备份。通常为 <code>0</code>（不备份）或 <code>1</code>（备份）。</li></ul></li><li><p><strong>自检顺序（Fsck Order）：</strong></p><ul><li>数字，表示启动时文件系统检查的顺序。根文件系统通常为 <code>1</code>，其他为 <code>2</code>，不检查则为 <code>0</code>。</li></ul></li></ol><h2 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h2><p>以下是一个典型的 <code>/etc/fstab</code> 文件示例：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># &lt;文件系统&gt;  &lt;挂载点&gt;    &lt;类型&gt; &lt;选项&gt;     &lt;转储&gt; &lt;自检&gt;</span></span><br><span class="line">/dev/sda1     /           ext4   defaults    1      1</span><br><span class="line">/dev/sda2     /home       ext4   defaults    1      2</span><br><span class="line">/dev/sdb1     /mnt/backup ntfs   defaults    0      0</span><br><span class="line">UUID=xxxx-xxxx /mnt/data  ext4   defaults    0      2</span><br><span class="line">LABEL=usbdrv  /mnt/usb    vfat   noauto,user 0      0</span><br></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li><code>/dev/sda1</code> 挂载到根目录 <code>/</code>，文件系统类型为 <code>ext4</code>，使用默认选项，转储频率为 <code>1</code>，自检顺序为 <code>1</code>。</li><li><code>/dev/sda2</code> 挂载到 <code>/home</code>，文件系统类型为 <code>ext4</code>，使用默认选项，转储频率为 <code>1</code>，自检顺序为 <code>2</code>。</li><li><code>/dev/sdb1</code> 挂载到 <code>/mnt/backup</code>，文件系统类型为 <code>ntfs</code>，使用默认选项，不进行转储和自检。</li><li>使用 <code>UUID=xxxx-xxxx</code> 指定的分区挂载到 <code>/mnt/data</code>，文件系统类型为 <code>ext4</code>，使用默认选项，不进行转储，自检顺序为 <code>2</code>。</li><li>使用 <code>LABEL=usbdrv</code> 指定的设备挂载到 <code>/mnt/usb</code>，文件系统类型为 <code>vfat</code>，不自动挂载，允许用户挂载，不进行转储和自检。</li></ul><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="步骤-1：备份现有的-etc-fstab"><a href="#步骤-1：备份现有的-etc-fstab" class="headerlink" title="步骤 1：备份现有的 /etc/fstab"></a>步骤 1：备份现有的 <code>/etc/fstab</code></h3><p>在修改之前，备份现有的 <code>/etc/fstab</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/fstab /etc/fstab.bak</span><br></pre></td></tr></table></figure><h3 id="步骤-2：编辑-etc-fstab"><a href="#步骤-2：编辑-etc-fstab" class="headerlink" title="步骤 2：编辑 /etc/fstab"></a>步骤 2：编辑 <code>/etc/fstab</code></h3><p>使用文本编辑器打开 <code>/etc/fstab</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/fstab</span><br></pre></td></tr></table></figure><h3 id="步骤-3：添加新的挂载条目"><a href="#步骤-3：添加新的挂载条目" class="headerlink" title="步骤 3：添加新的挂载条目"></a>步骤 3：添加新的挂载条目</h3><p>根据需要添加新的挂载条目。例如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=xxxx-xxxx /mnt/data  ext4   defaults    0      2</span><br></pre></td></tr></table></figure><h3 id="步骤-4：保存并退出"><a href="#步骤-4：保存并退出" class="headerlink" title="步骤 4：保存并退出"></a>步骤 4：保存并退出</h3><p>编辑完成后，保存文件并退出编辑器。对于 <code>nano</code> 编辑器，按 <code>Ctrl+O</code> 保存文件，然后按 <code>Ctrl+X</code> 退出。</p><h3 id="步骤-5：验证配置"><a href="#步骤-5：验证配置" class="headerlink" title="步骤 5：验证配置"></a>步骤 5：验证配置</h3><p>使用以下命令验证 <code>fstab</code> 文件的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -a</span><br></pre></td></tr></table></figure><p>如果没有错误信息，说明配置正确。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>确保每个字段之间用空格或制表符分隔。</li><li>使用 <code>UUID</code> 或 <code>LABEL</code> 可以避免设备名称变化带来的问题。</li><li>错误的 <code>fstab</code> 配置可能导致系统无法启动，修改前务必备份。</li></ul><h2 id="常见挂载选项"><a href="#常见挂载选项" class="headerlink" title="常见挂载选项"></a>常见挂载选项</h2><ul><li><code>defaults</code>：使用默认挂载选项 <code>rw, suid, dev, exec, auto, nouser, async</code>。</li><li><code>ro</code>：只读挂载。</li><li><code>rw</code>：读写挂载。</li><li><code>noauto</code>：不自动挂载。</li><li><code>user</code>：允许普通用户挂载。</li><li><code>nouser</code>：只允许 root 用户挂载。</li><li><code>noexec</code>：禁止执行二进制文件。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><code>man fstab</code>：查看 <code>fstab</code> 的手册页。</li><li><code>man mount</code>：查看 <code>mount</code> 命令的手册页。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Iperf/Iperf3 进行网络性能测试</title>
      <link href="/2024/07/21/iperf_network_test/"/>
      <url>/2024/07/21/iperf_network_test/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Iperf-Iperf3-进行网络性能测试"><a href="#使用-Iperf-Iperf3-进行网络性能测试" class="headerlink" title="使用 Iperf&#x2F;Iperf3 进行网络性能测试"></a>使用 Iperf&#x2F;Iperf3 进行网络性能测试</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>详细介绍了如何使用Iperf或Iperf3工具进行网络性能测试。Iperf是一个功能强大且灵活的网络测试工具，能够测量网络的带宽、延迟、抖动和数据包丢失等关键指标。本文将包括Iperf&#x2F;Iperf3的安装、参数介绍、实际使用案例以及测试结果的解读。</p><h2 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="2. 适用范围"></a>2. 适用范围</h2><p>适用于网络管理员、系统管理员和开发人员，他们需要对局域网(LAN)、广域网(WAN)或其他网络环境的性能进行深入评估。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>网络管理员</strong>: 负责安装和配置Iperf&#x2F;Iperf3工具，并确保测试环境的稳定性。</li><li><strong>系统管理员</strong>: 配置并监控服务器和客户端之间的网络性能测试。</li><li><strong>开发人员</strong>: 利用Iperf&#x2F;Iperf3生成的网络性能数据，优化应用程序的网络使用效率。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>安装了Iperf或Iperf3的系统（包括测试服务器和客户端）。</li><li>目标网络的完全访问权限。</li><li>具备基本的网络知识，理解TCP&#x2F;IP协议、带宽、延迟等概念。</li><li>具备适当的权限进行网络测试，以避免影响生产网络。</li></ul><h2 id="5-参数介绍与使用示例"><a href="#5-参数介绍与使用示例" class="headerlink" title="5. 参数介绍与使用示例"></a>5. 参数介绍与使用示例</h2><h3 id="5-1-常用参数详解"><a href="#5-1-常用参数详解" class="headerlink" title="5.1 常用参数详解"></a>5.1 常用参数详解</h3><ul><li><strong><code>-s</code></strong>: 启动Iperf作为服务器模式，等待客户端连接。该模式下的Iperf不会发送数据，只负责接收并报告结果。</li><li><strong><code>-c &lt;服务器IP地址&gt;</code></strong>: 启动Iperf作为客户端，连接到指定的服务器IP地址。</li><li><strong><code>-u</code></strong>: 使用UDP协议进行测试。如果未指定该选项，Iperf默认使用TCP。</li><li><strong><code>-b &lt;带宽&gt;</code></strong>: 设定UDP测试的目标带宽，例如<code>-b 100M</code>表示目标带宽为100Mbps。对于TCP，该参数会限制发送速率。</li><li><strong><code>-P &lt;并发数&gt;</code></strong>: 指定同时运行的并发流数，通常用于测试多线程或多连接的网络性能。</li><li><strong><code>-t &lt;时间&gt;</code></strong>: 指定测试持续的时间，单位为秒，默认值为10秒。</li><li><strong><code>-i &lt;间隔时间&gt;</code></strong>: 设置报告输出的间隔时间，单位为秒。例如，<code>-i 1</code>表示每秒输出一次中间结果。</li><li><strong><code>--logfile &lt;文件名&gt;</code></strong>: 将测试结果保存到指定的日志文件中，便于后续分析。</li><li><strong><code>--json</code></strong>: 以JSON格式输出测试结果，便于集成到自动化工具或分析系统中。</li></ul><h3 id="5-2-安装-Iperf-Iperf3"><a href="#5-2-安装-Iperf-Iperf3" class="headerlink" title="5.2 安装 Iperf&#x2F;Iperf3"></a>5.2 安装 Iperf&#x2F;Iperf3</h3><ol><li><p><strong>在Linux上安装Iperf&#x2F;Iperf3</strong>:</p><ul><li>Iperf和Iperf3可以通过包管理器安装：<ul><li><strong>Iperf</strong>:<ul><li><strong>Debian&#x2F;Ubuntu</strong>: <code>sudo apt-get install iperf</code></li><li><strong>CentOS&#x2F;RHEL</strong>: <code>sudo yum install iperf</code></li></ul></li><li><strong>Iperf3</strong>:<ul><li><strong>Debian&#x2F;Ubuntu</strong>: <code>sudo apt-get install iperf3</code></li><li><strong>CentOS&#x2F;RHEL</strong>: <code>sudo yum install iperf3</code></li></ul></li></ul></li></ul></li><li><p><strong>验证安装</strong>:</p><ul><li>使用以下命令验证安装是否成功：<ul><li><strong>Iperf</strong>: <code>iperf --version</code></li><li><strong>Iperf3</strong>: <code>iperf3 --version</code></li></ul></li></ul></li></ol><h3 id="5-3-基本带宽测试"><a href="#5-3-基本带宽测试" class="headerlink" title="5.3 基本带宽测试"></a>5.3 基本带宽测试</h3><ol><li><p><strong>使用Iperf测试TCP带宽</strong></p><ul><li><strong>目的</strong>: 测量两台设备之间的最大TCP带宽。</li><li><strong>步骤</strong>:<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -s</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -c &lt;服务器IP地址&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li><strong>结果分析</strong>:<ul><li>测试结果显示客户端到服务器的TCP带宽，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[  3]  0.0-10.0 sec  1.12 GBytes  961 Mbits/sec</span><br></pre></td></tr></table></figure></li><li><code>961 Mbits/sec</code> 表示在10秒内平均带宽为961 Mbps。</li></ul></li></ul></li><li><p><strong>使用Iperf3测试TCP带宽</strong></p><ul><li><strong>目的</strong>: 测量两台设备之间的最大TCP带宽，类似于Iperf，但Iperf3提供了更多的选项和更详细的报告。</li><li><strong>步骤</strong>:<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -s</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;服务器IP地址&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li><strong>结果分析</strong>:<ul><li>结果会显示更多细节，包括每秒的带宽、重传等信息，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ ID] Interval           Transfer     Bandwidth       Retr</span><br><span class="line">[  5]   0.00-10.00  sec  1.11 GBytes  952 Mbits/sec  12   sender</span><br><span class="line">[  5]   0.00-10.00  sec  1.11 GBytes  952 Mbits/sec          receiver</span><br></pre></td></tr></table></figure></li><li><code>952 Mbits/sec</code> 表示TCP带宽，<code>12 Retr</code> 表示发生了12次重传。</li></ul></li></ul></li></ol><h3 id="5-4-UDP性能测试"><a href="#5-4-UDP性能测试" class="headerlink" title="5.4 UDP性能测试"></a>5.4 UDP性能测试</h3><ol><li><p><strong>使用Iperf测试UDP带宽和抖动</strong></p><ul><li><strong>目的</strong>: 测量UDP带宽、抖动和丢包率，这对于实时应用（如VoIP）尤为重要。</li><li><strong>步骤</strong>:<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -s -u</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -c &lt;服务器IP地址&gt; -u -b 100M</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>-b 100M</code> 表示发送100Mbps的UDP流量。</li></ul></li><li><strong>结果分析</strong>:<ul><li>测试结果显示UDP带宽、抖动和丢包率，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[  3]  0.0-10.0 sec  119 MBytes  100 Mbits/sec  0.025 ms  0/8501 (0%)</span><br></pre></td></tr></table></figure></li><li><code>0.025 ms</code> 是抖动值，<code>0/8501 (0%)</code> 表示没有发生丢包。</li></ul></li></ul></li><li><p><strong>使用Iperf3测试UDP性能</strong></p><ul><li><strong>目的</strong>: 类似于Iperf的UDP测试，但Iperf3提供了更详细的报告和控制。</li><li><strong>步骤</strong>:<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -s</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;服务器IP地址&gt; -u -b 50M</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>-b 50M</code> 表示发送50Mbps的UDP流量。</li></ul></li><li><strong>结果分析</strong>:<ul><li>结果显示了更详细的统计信息，包括UDP流量的丢包率和抖动，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ ID] Interval           Transfer     Bandwidth       Total Datagrams</span><br><span class="line">[  5]   0.00-10.00  sec  59.4 MBytes  49.8 Mbits/sec  7601</span><br><span class="line">[  5] Sent 7601 datagrams</span><br><span class="line">[  5] Server Report:</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams</span><br><span class="line">[  5]   0.00-10.00  sec  59.4 MBytes  49.8 Mbits/sec  0.043 ms  1/7601 (0.013%)</span><br></pre></td></tr></table></figure></li><li><code>0.043 ms</code> 是抖动值，<code>1/7601 (0.013%)</code> 表示丢失了1个数据包，丢包率为0.013%。</li></ul></li></ul></li></ol><h3 id="5-5-并发测试"><a href="#5-5-并发测试" class="headerlink" title="5.5 并发测试"></a>5.5 并发测试</h3><ol><li><strong>同时测试多个并发流</strong><ul><li><strong>目的</strong>: 测试多个并发TCP或UDP流对网络性能的影响，模拟多用户或多应用程序同时使用网络的情况。</li><li><strong>步骤</strong>:<ul><li><strong>TCP并发测试</strong>：<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -s</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;服务器IP地址&gt; -P 5</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>-P 5</code> 表示同时启动5个并发流。</li></ul></li><li><strong>UDP并发测试</strong>：<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -s</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;服务器IP地址&gt; -u -b 50M -P 5</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><strong>结果分析</strong>:<ul><li>每个流的带宽</li></ul></li></ul></li></ol><p>、抖动和丢包率都会被单独报告，分析总带宽和每个流的性能可以帮助理解网络在并发场景下的表现。<br>     - 例如：<br>       <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams</span><br><span class="line">[SUM]   0.00-10.00  sec  298 MBytes  250 Mbits/sec  0.090 ms  0/14900 (0%)</span><br></pre></td></tr></table></figure></p><h3 id="5-6-高级测试示例"><a href="#5-6-高级测试示例" class="headerlink" title="5.6 高级测试示例"></a>5.6 高级测试示例</h3><ol><li><p><strong>跨多个子网的测试</strong></p><ul><li><strong>目的</strong>: 测试跨多个子网的网络性能，评估路由器或防火墙的性能。</li><li><strong>步骤</strong>:<ul><li>在不同子网中的服务器和客户端分别运行Iperf3或Iperf。</li><li>例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;跨子网的服务器IP地址&gt; -P 5 -t 30</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>结果分析</strong>:<ul><li>通过分析延迟、带宽和丢包率，了解网络设备在跨子网环境下的表现。</li></ul></li></ul></li><li><p><strong>长时间稳定性测试</strong></p><ul><li><strong>目的</strong>: 进行长时间的网络性能测试，检查网络连接的稳定性和长期表现。</li><li><strong>步骤</strong>:<ul><li>运行长达数小时甚至数天的Iperf3测试：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;服务器IP地址&gt; -t 3600</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>结果分析</strong>:<ul><li>长时间测试结果有助于识别网络中的间歇性问题，如偶发的丢包或带宽波动。</li></ul></li></ul></li></ol><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul><li><a href="https://iperf.fr/">Iperf官方文档</a></li><li><a href="https://github.com/esnet/iperf">Iperf3 GitHub仓库</a></li><li><a href="https://www.redhat.com/en/topics/virtualization/network-performance">网络性能测试指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Proxy 设置</title>
      <link href="/2024/07/21/linux_proxy_config/"/>
      <url>/2024/07/21/linux_proxy_config/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-Proxy-设置"><a href="#Linux-Proxy-设置" class="headerlink" title="Linux Proxy 设置"></a>Linux Proxy 设置</h1><hr><h2 id="Terminal-全局-http-proxy-只在当前Session生效"><a href="#Terminal-全局-http-proxy-只在当前Session生效" class="headerlink" title="Terminal 全局 http proxy (只在当前Session生效)"></a>Terminal 全局 http proxy (只在当前Session生效)</h2><h3 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h3>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://&lt;ip address&gt;:&lt;port&gt;&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://&lt;ip address&gt;:&lt;port&gt;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h3>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> http_proxy</span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br></pre></td></tr></table></figure><h2 id="Proxychains"><a href="#Proxychains" class="headerlink" title="Proxychains"></a>Proxychains</h2><h3 id="安装-预先手动配置Terminal-proxy"><a href="#安装-预先手动配置Terminal-proxy" class="headerlink" title="安装 (预先手动配置Terminal proxy)"></a>安装 (预先手动配置Terminal proxy)</h3><ol><li><p>Debian</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install proxychains</span><br></pre></td></tr></table></figure></li><li><p>RHEL9</p><p><strong>x86_64</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install https://dl.fedoraproject.org/pub/epel/9/Everything/aarch64/Packages/p/proxychains-ng-4.17-1.el9.x86_64.rpm</span><br></pre></td></tr></table></figure><p><strong>ARM64</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install https://dl.fedoraproject.org/pub/epel/9/Everything/aarch64/Packages/p/proxychains-ng-4.17-1.el9.aarch64.rpm</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li>编辑 &#x2F;etc&#x2F;proxychains.conf</li><li>找到quiet_mode，去掉前面的#<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Quiet mode (no output from library)</span><br><span class="line">quiet_mode</span><br></pre></td></tr></table></figure></li><li>滚动到最下，注释原有的sock4<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line"># add proxy here ...</span><br><span class="line"># meanwile</span><br><span class="line"># defaults set to &quot;tor&quot;</span><br><span class="line">#socks4         127.0.0.1 9050</span><br></pre></td></tr></table></figure></li><li>增加要使用的代理<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line">http         192.168.1.147 58080</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>在要连接网络的命令或者脚本名之前加上proxychains即可<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains apt update</span><br><span class="line">proxychains apt install ipmitool</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Red Hat Enterprise Linux 9 YUM 本地源配置</title>
      <link href="/2024/07/16/rhel9_yum_repo/"/>
      <url>/2024/07/16/rhel9_yum_repo/</url>
      
        <content type="html"><![CDATA[<h1 id="准备安装ISO和挂载"><a href="#准备安装ISO和挂载" class="headerlink" title="准备安装ISO和挂载"></a>准备安装ISO和挂载</h1><h2 id="Mount-RHEL9-iso"><a href="#Mount-RHEL9-iso" class="headerlink" title="Mount RHEL9.iso"></a>Mount RHEL9.iso</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount RHEL9.iso /mnt</span><br></pre></td></tr></table></figure><h1 id="创建repo"><a href="#创建repo" class="headerlink" title="创建repo"></a>创建repo</h1><h2 id="增加一个iso-repo到-etc-yum-repos-d-修改baseurl路径为iso-mount的文件夹"><a href="#增加一个iso-repo到-etc-yum-repos-d-修改baseurl路径为iso-mount的文件夹" class="headerlink" title="增加一个iso.repo到&#x2F;etc&#x2F;yum.repos.d, 修改baseurl路径为iso mount的文件夹."></a>增加一个iso.repo到&#x2F;etc&#x2F;yum.repos.d, 修改baseurl路径为iso mount的文件夹.</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/yum.repos.d/iso.repo</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[BaseOS]</span><br><span class="line">name=BaseOS Packages Red Hat Enterprise Linux 9</span><br><span class="line">metadata_expire=-1</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">baseurl=file:///mnt/BaseOS/</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release</span><br><span class="line"></span><br><span class="line">[AppStream]</span><br><span class="line">name=AppStream Packages Red Hat Enterprise Linux 9</span><br><span class="line">metadata_expire=-1</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">baseurl=file:///mnt/AppStream/</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release</span><br></pre></td></tr></table></figure><h1 id="YUM-更新和安装"><a href="#YUM-更新和安装" class="headerlink" title="YUM 更新和安装"></a>YUM 更新和安装</h1><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ipmitool</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> RHEL </tag>
            
            <tag> YUM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 ARM 平台上安装、编译和运行 Mlucas 并进行 FFTs 测试</title>
      <link href="/2024/07/03/ARM_FFTs_test/"/>
      <url>/2024/07/03/ARM_FFTs_test/</url>
      
        <content type="html"><![CDATA[<h1 id="在-ARM-平台上安装、编译和运行-Mlucas-并进行-FFTs-测试"><a href="#在-ARM-平台上安装、编译和运行-Mlucas-并进行-FFTs-测试" class="headerlink" title="在 ARM 平台上安装、编译和运行 Mlucas 并进行 FFTs 测试"></a>在 ARM 平台上安装、编译和运行 Mlucas 并进行 FFTs 测试</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>Mlucas 是一个用 C 编写的开源软件，专门用于多平台架构的高性能梅森数素性测试。在 ARM 平台上，由于 prime95&#x2F;mprime 仅支持 x86 架构，Mlucas 成为理想的替代方案。详细介绍了如何在 ARM 平台上安装、编译并运行 Mlucas，包括对各类参数的深入介绍与示例，并结合硬件资源优化进行了详细的配置步骤。</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h2><p>适用于希望在 ARM 平台上执行 FFTs 测试并优化硬件性能的技术人员。本文主要针对运行 Debian 系统的 ARM64 设备，但同样适用于其他 Linux 发行版，步骤可能略有不同。</p><h2 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h2><ul><li><strong>系统管理员</strong>：确保 ARM 平台上所需的软件和库均已正确安装，具备系统管理权限。</li><li><strong>操作员</strong>：严格按照本 SOP 进行 Mlucas 的安装、编译、调优和运行。</li></ul><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h2><ul><li>ARM64 架构的设备，运行 Linux 操作系统（如 Debian 或 RHEL9）。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>有效的互联网连接以下载必要的软件包和源码。</li></ul><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><h3 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h3><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装必要的依赖包</strong></p><ul><li><p><strong>Debian</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential libgmp-dev libhwloc-dev git clang</span><br></pre></td></tr></table></figure></li><li><p><strong>RHEL9</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf group install <span class="string">&quot;Development Tools&quot;</span></span><br><span class="line">sudo dnf install gmp-devel hwloc-devel clang git</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-下载和准备-Mlucas"><a href="#2-下载和准备-Mlucas" class="headerlink" title="2. 下载和准备 Mlucas"></a>2. <strong>下载和准备 Mlucas</strong></h3><p>2.1 <strong>从 GitHub 克隆 Mlucas 源码</strong></p><ul><li>使用以下命令克隆 Mlucas 项目到本地目录。也可以从 <a href="https://github.com/primesearch/Mlucas/releases">Release 页面</a> 下载源码包。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/primesearch/Mlucas.git</span><br></pre></td></tr></table></figure></li></ul><p>2.2 <strong>进入 Mlucas 项目目录</strong><br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Mlucas</span><br></pre></td></tr></table></figure></p><h3 id="3-编译-Mlucas"><a href="#3-编译-Mlucas" class="headerlink" title="3. 编译 Mlucas"></a>3. <strong>编译 Mlucas</strong></h3><p>3.1 <strong>设置编译器</strong></p><ul><li>将编译器设置为 <code>clang</code> 以优化编译过程。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CC=clang</span><br></pre></td></tr></table></figure></li></ul><p>3.2 <strong>使用 makemake.sh 脚本编译 Mlucas</strong></p><ul><li>执行 <code>makemake.sh</code> 脚本，确保启用 <code>hwloc</code> 支持，以优化 CPU 绑定和内存访问性能。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash makemake.sh use_hwloc</span><br></pre></td></tr></table></figure></li></ul><p>3.3 <strong>确认编译成功</strong></p><ul><li>编译完成后，编译生成的可执行文件将位于 <code>obj</code> 目录中。使用以下命令查看生成的文件：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> obj</span><br></pre></td></tr></table></figure></li><li>生成的文件名可能会因编译选项的不同而变化，如 <code>Mlucas</code>.</li></ul><h3 id="4-性能调优：为您的机器进行优化"><a href="#4-性能调优：为您的机器进行优化" class="headerlink" title="4. 性能调优：为您的机器进行优化"></a>4. <strong>性能调优：为您的机器进行优化</strong></h3><p><strong>STEP 2 − PERFORMANCE-TUNE FOR YOUR MACHINE</strong></p><p>在 Mlucas 编译完成后，重要的是对软件进行调优，以便充分利用您的硬件资源。这一步骤涉及运行一系列测试，以确定适合您机器的最佳 FFT 长度和 CPU 绑定配置。</p><p>4.1 <strong>运行自检</strong></p><ul><li><p>自检测试将评估您的硬件性能，并生成配置文件，帮助确定适合的 FFT 长度和其他参数。运行以下命令：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Mlucas -s</span><br></pre></td></tr></table></figure></li><li><p>该命令将测试多个 FFT 长度和 CPU 配置，以确定最佳配置。测试结果将存储在生成的日志文件中。</p></li></ul><p>4.2 <strong>分析自检结果</strong></p><ul><li><p>自检完成后，打开并分析生成的日志文件（通常是 <code>mlucas.cfg</code> 或其他输出文件），查看不同 FFT 长度下的性能表现。</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> mlucas.cfg</span><br></pre></td></tr></table></figure></li><li><p>该文件会列出每个 FFT 长度的平均迭代时间。较短的时间意味着更优的性能。选择那些具有最短迭代时间的 FFT 长度和配置。</p></li></ul><p>4.3 <strong>配置 Mlucas</strong></p><ul><li>根据自检结果，手动编辑 <code>mlucas.cfg</code> 文件，以使用最佳配置进行实际测试。例如，设置合适的 FFT 长度和 CPU 绑定。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano mlucas.cfg</span><br></pre></td></tr></table></figure></li><li>在配置文件中指定最佳 FFT 长度和 CPU 核心分配，如：   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FFTlength=2048K</span><br><span class="line">CPU=0-7</span><br></pre></td></tr></table></figure></li></ul><p>4.4 <strong>再次测试并验证</strong></p><ul><li>使用优化后的配置重新运行 Mlucas，并通过日志文件验证性能是否有所提升。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Mlucas -s m -logfile optimized_test.log</span><br></pre></td></tr></table></figure></li><li>实时查看日志文件以确认测试正在按预期的配置进行：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f optimized_test.log</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-Mlucas-参数设置与执行-FFTs-测试"><a href="#5-Mlucas-参数设置与执行-FFTs-测试" class="headerlink" title="5. Mlucas 参数设置与执行 FFTs 测试"></a>5. <strong>Mlucas 参数设置与执行 FFTs 测试</strong></h3><p>5.1 <strong>获取系统的 CPU 信息</strong></p><ul><li>在执行测试之前，获取并了解测试机器的 CPU 配置情况。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure></li><li>例如，输出结果可能为：   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CPU(s):              32</span><br><span class="line">Thread(s) per core:  1</span><br><span class="line">NUMA node0 CPU(s):   0-15</span><br><span class="line">NUMA node1 CPU(s):   16-31</span><br></pre></td></tr></table></figure></li></ul><p>5.2 <strong>Mlucas 常用参数介绍</strong></p><ul><li><code>-s</code>：指定自检或特定素性测试模式。常见值包括：<ul><li><code>-s</code>：自检模式，测试系统性能并生成配置文件。</li><li><code>-s m</code>：启动梅森数的快速测试。</li><li><code>-s q</code>：启动快速素数测试（例如 Fermat 测试）。</li></ul></li><li><code>-cpu</code>：指定使用的 CPU 核心范围。格式为 <code>-cpu start:end</code>，例如 <code>-cpu 0:15</code> 表示使用 CPU 0 到 15 号核心。</li><li><code>-fftlen</code>：设置 FFT 长度。FFT 长度决定了可处理的最大数字大小。常见值为 1024K, 2048K, 4096K 等。</li><li><code>-iters</code>：设置每个测试的迭代次数。更高的迭代次数可提供更精确的结果，但需要更多时间。</li><li><code>-logfile</code>：指定日志文件路径。默认值为 <code>mlucas.log</code>。</li></ul><p>5.3 <strong>FFT 测试的参数示例</strong></p><ul><li>自检模式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Mlucas -s</span><br></pre></td></tr></table></figure></li><li>运行 FFTs 测试并指定 CPU 核心范围：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Mlucas -s m -cpu 0:3 -fftlen 2048K -iters 10000 -logfile fft_test.log</span><br></pre></td></tr></table></figure></li><li>对不同核心组运行 FFTs 测试：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./Mlucas -s m -cpu 0:3</span><br><span class="line">./Mlucas -s m -cpu 4:7</span><br><span class="line">./Mlucas -s m -cpu 8:11</span><br><span class="line">./Mlucas -s m -cpu 12:15</span><br><span class="line">./Mlucas -s m -cpu 16:19</span><br><span class="line">./Mlucas -s m -cpu 20:23</span><br><span class="line">./Mlucas -s m -cpu 24:27</span><br><span class="line">./Mlucas -s m -cpu 28:31</span><br></pre></td></tr></table></figure></li></ul><p>5.4 <strong>监控测试进度</strong></p><ul><li>Mlucas 运行过程中会生成日志文件，可以使用以下命令实时查看日志以监控测试进度和性能表现：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f mlucas.log</span><br></pre></td></tr></table></figure></li></ul><p>5.5 <strong>常见优化建议</strong></p><ul><li><strong>调整 FFT 长度</strong>：根据硬件配置和测试目标，选择适合的 FFT 长度。较大的 FFT 长度通常适用于处理更大的数字，但可能会增加计算时间。</li><li><strong>核心绑定</strong>：通过 <code>-cpu</code> 参数绑定特定核心组，以避免不同进程争夺相同的 CPU 资源，从而提升性能。</li></ul><h3 id="6-优化与维护"><a href="#6-优化与维护" class="headerlink" title="6. 优化与维护"></a>6. <strong>优化与维护</strong></h3><p>6.1 <strong>优化 CPU 绑定</strong></p><ul><li>根据测试需求和系统资源，调整 <code>-cpu</code> 参数中的核心范围，以进一步优化计算性能。</li></ul><p>6.2 <strong>定期更新</strong></p><ul><li>通过定期从 GitHub 仓库获取最新的源码，并重新编译，以确保使用最新版的 Mlucas 并获得最新的性能优化。</li></ul><h3 id="7-自动化测试脚本"><a href="#7-自动化测试脚本" class="headerlink" title="7. 自动化测试脚本"></a>7. <strong>自动化测试脚本</strong></h3><p>7.1 <strong>编写自动化测试脚本</strong></p><ul><li>以下是 Bash 脚本<code>run_mlucas.sh</code>的详细说明，用于自动化 Mlucas 的测试过程。该脚本支持两种 FFT 模式 (<code>small</code> 和 <code>large</code>)，根据 CPU 核心数量自动分配核心组，并并行运行多个 Mlucas 实例。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 FFT 模式和其他关键参数</span></span><br><span class="line">fft_mode=<span class="string">&quot;small&quot;</span>  <span class="comment"># 默认模式为 small，可以通过传入参数修改</span></span><br><span class="line">fft_mode=<span class="variable">$1</span>  <span class="comment"># 接收传入的 FFT 模式参数</span></span><br><span class="line">mlucas_dir=<span class="string">&quot;/Mlucas&quot;</span>  <span class="comment"># 定义 Mlucas 目录路径</span></span><br><span class="line">s_mode=<span class="string">&quot;l&quot;</span></span><br><span class="line">duration=60  <span class="comment"># 定义测试持续时间</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$mlucas_dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义配置文件和核心分配策略</span></span><br><span class="line">small_cfg_file=<span class="string">&quot;mlucas_small.cfg&quot;</span></span><br><span class="line">large_cfg_file=<span class="string">&quot;mlucas_large.cfg&quot;</span></span><br><span class="line">cores_per_group=2  <span class="comment"># 每组分配的核心数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除旧的配置文件</span></span><br><span class="line"><span class="built_in">rm</span> mlucas.cfg -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查并初始化 small FFT 配置文件</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">&quot;<span class="variable">$small_cfg_file</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Basic testing - small FFTs...&quot;</span></span><br><span class="line">    ./obj_asimd/Mlucas -s small -cpu 0:$((cores_per_group-<span class="number">1</span>)) &gt;&amp; small_test.log</span><br><span class="line">    <span class="built_in">mv</span> mlucas.cfg mlucas_small.cfg</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Initialized mlucas_small.cfg.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查并初始化 large FFT 配置文件</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">&quot;<span class="variable">$large_cfg_file</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Basic testing - large FFTs, this will take a long time...&quot;</span></span><br><span class="line">    ./obj_asimd/Mlucas -s large -cpu 0:$((cores_per_group-<span class="number">1</span>)) &gt;&amp; large_test.log</span><br><span class="line">    <span class="built_in">mv</span> mlucas.cfg mlucas_large.cfg</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Initialized mlucas_large.cfg.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果两个配置文件都存在，提取相关信息</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$small_cfg_file</span>&quot;</span> ] &amp;&amp; [ -f <span class="string">&quot;<span class="variable">$large_cfg_file</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$small_cfg_file</span> and <span class="variable">$large_cfg_file</span> are existed.&quot;</span></span><br><span class="line">    small_fft=$(<span class="built_in">tail</span> -n 1 mlucas_small.cfg | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">    small_fft_radix=$(<span class="built_in">tail</span> -n 1 mlucas_small.cfg | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $11&#125;&#x27;</span>)</span><br><span class="line">    small_fft_time=$(<span class="built_in">tail</span> -n 1 mlucas_small.cfg | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    large_fft=$(<span class="built_in">tail</span> -n 1 mlucas_large.cfg | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">    large_fft_radix=$(<span class="built_in">tail</span> -n 1 mlucas_large.cfg | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $11&#125;&#x27;</span>)</span><br><span class="line">    large_fft_time=$(<span class="built_in">tail</span> -n 1 mlucas_large.cfg | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    small_fft_iter=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$small_fft_time</span> 1000 <span class="variable">$duration</span>&quot;</span> | awk <span class="string">&#x27;&#123;printf &quot;%.0f\n&quot;, $3 / ($1 / $2)/ 2&#125;&#x27;</span>)</span><br><span class="line">    large_fft_iter=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$large_fft_time</span> 1000 <span class="variable">$duration</span>&quot;</span> | awk <span class="string">&#x27;&#123;printf &quot;%.0f\n&quot;, $3 / ($1 / $2)/ 2&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据模式设置链接和参数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$fft_mode</span>&quot;</span> = <span class="string">&quot;large&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    instance_count=1</span><br><span class="line">    <span class="built_in">ln</span> -s mlucas_large.cfg mlucas.cfg</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    instance_count=2</span><br><span class="line">    <span class="built_in">ln</span> -s mlucas_small.cfg mlucas.cfg</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据模式选择 FFT 配置</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$fft_mode</span>&quot;</span> = <span class="string">&quot;large&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    fft=<span class="variable">$large_fft</span></span><br><span class="line">    fft_radix=<span class="variable">$large_fft_radix</span></span><br><span class="line">    iter=<span class="variable">$large_fft_iter</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    fft=<span class="variable">$small_fft</span></span><br><span class="line">    fft_radix=<span class="variable">$small_fft_radix</span></span><br><span class="line">    iter=<span class="variable">$small_fft_iter</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> fft: <span class="variable">$fft</span> fft_radix: <span class="variable">$fft_radix</span> iter: <span class="variable">$iter</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建运行环境</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Creating env...&quot;</span></span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$mlucas_dir</span>/runset -rf</span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$mlucas_dir</span>/jobs.sh -f</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$mlucas_dir</span>/runset</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#!/bin/bash&quot;</span> &gt;&gt; jobs.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 CPU 核心数量</span></span><br><span class="line">cores=$(<span class="built_in">cat</span> /proc/cpuinfo | grep processor | <span class="built_in">wc</span> -l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算总共需要多少组</span></span><br><span class="line">num_groups=$((cores / cores_per_group))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环输出每组的核心范围并生成任务脚本</span></span><br><span class="line"><span class="keyword">for</span> ((i = <span class="number">0</span>; i &lt; num_groups; i++)); <span class="keyword">do</span></span><br><span class="line">    start=$((i * cores_per_group))</span><br><span class="line">    end=$((start + cores_per_group - <span class="number">1</span>))</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Group <span class="variable">$i</span>: <span class="variable">$start</span>:<span class="variable">$end</span>&quot;</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="variable">$mlucas_dir</span>/runset/run<span class="variable">$i</span></span><br><span class="line">    <span class="keyword">for</span> ((j = <span class="number">0</span>; j &lt; instance_count; j++)); <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;cd <span class="variable">$mlucas_dir</span>/runset/run<span class="variable">$i</span> &amp;&amp; nohup ../../obj_asimd/Mlucas -fft <span class="variable">$fft</span> -iters <span class="variable">$iter</span> -maxalloc 50 -cpu <span class="variable">$start</span>:<span class="variable">$end</span> -radset 1 &gt;&gt; <span class="variable">$mlucas_dir</span>/runset/run<span class="variable">$i</span>/test<span class="variable">$j</span>.log 2&gt;&amp;1 &amp;&quot;</span> &gt;&gt; jobs.sh</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行生成的任务脚本</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running jobs.sh...&quot;</span></span><br><span class="line">bash jobs.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;jobs.sh running in background.&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&#x27;pkill -x Mlucas&#x27; to end testing.&quot;</span></span><br></pre></td></tr></table></figure><p>7.2 <strong>脚本运行说明</strong></p><ul><li>该脚本在启动时会根据传入的参数选择 FFT 模式（small 或 large），并自动初始化相应的配置文件。</li><li>脚本自动检测系统中的 CPU 核心数量，并将核心划分为多个组，每组运行一个或多个 Mlucas 实例。</li><li>生成的任务脚本 <code>jobs.sh</code> 会在后台启动所有的 Mlucas 实例，并记录测试日志。</li></ul><p>7.3 <strong>执行脚本</strong></p><ul><li>在终端中执行脚本，传入所需的 FFT 模式（如 <code>small</code> 或 <code>large</code>）。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash run_mlucas.sh small</span><br></pre></td></tr></table></figure></li></ul><p>7.4 <strong>监控日志</strong></p><ul><li>脚本将测试日志记录在每个核心组的 <code>test.log</code> 文件中，可以通过以下命令实时监控日志：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f /Mlucas/runset/run0/test0.<span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ul><p>7.5 <strong>停止测试</strong></p><ul><li>如果需要终止测试，可以使用以下命令终止所有正在运行的 Mlucas 实例：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -x Mlucas</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://www.mersenneforum.org/mayer/README.html">Mlucas README</a></li><li><a href="https://github.com/primesearch/Mlucas">Mlucas GitHub Repository</a></li><li><a href="https://www.arm.com/resources/developer/guide">ARM64 Linux Compilation Guides</a></li><li><a href="https://linuxconfig.org/bash-scripting-tutorial-for-beginners">Bash Scripting Basics</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Memtester 进行内存测试</title>
      <link href="/2024/07/03/memtester_test/"/>
      <url>/2024/07/03/memtester_test/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Memtester-进行内存测试"><a href="#使用-Memtester-进行内存测试" class="headerlink" title="使用 Memtester 进行内存测试"></a>使用 Memtester 进行内存测试</h1><hr><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>详细介绍了如何使用 Memtester 工具进行内存的稳定性和健康检查。Memtester 是一个内存测试工具，它通过对内存执行各种读写操作来检测可能存在的内存错误。它可以在操作系统运行时对内存进行测试，是诊断内存故障的有效工具。</p><h2 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="2. 适用范围"></a>2. 适用范围</h2><p>适用于系统管理员、硬件技术人员和其他需要检测和诊断内存问题的用户，尤其是在Linux和类Unix操作系统环境中。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>系统管理员</strong>: 负责安装和运行 Memtester 工具，并根据测试结果采取必要的维护或更换操作。</li><li><strong>硬件技术人员</strong>: 评估内存的物理健康状况，尤其是在发生系统崩溃或不稳定性时。</li><li><strong>开发人员</strong>: 在开发高负载应用程序时，利用 Memtester 测试内存的稳定性。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>具有 root 或 sudo 权限的系统账户。</li><li>系统内存的足够可用空间以进行测试（通常建议至少有一半以上的空闲内存）。</li><li>系统对 Memtester 工具的支持和安装（通常在大多数 Linux 发行版的包管理器中可用）。</li></ul><h2 id="5-流程和示例"><a href="#5-流程和示例" class="headerlink" title="5. 流程和示例"></a>5. 流程和示例</h2><h3 id="5-1-安装-Memtester"><a href="#5-1-安装-Memtester" class="headerlink" title="5.1 安装 Memtester"></a>5.1 安装 Memtester</h3><ol><li><strong>在Linux上安装Memtester</strong>:<ul><li>Memtester 可以通过包管理器安装：<ul><li><strong>Debian&#x2F;Ubuntu</strong>: <code>sudo apt-get install memtester</code></li><li><strong>CentOS&#x2F;RHEL</strong>: <code>sudo yum install memtester</code></li><li><strong>Fedora</strong>: <code>sudo dnf install memtester</code></li></ul></li><li>也可以通过编译source code:<ul><li>To build: download, unpack, and type <code>make</code>. That’s all.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://pyropus.ca./software/memtester/old-versions/memtester-4.6.0.tar.gz</span><br><span class="line">tar zxvf memtester-4.6.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> memtester-4.6.0</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><strong>验证安装</strong>:<ul><li>使用以下命令验证安装是否成功：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memtester --version</span><br></pre></td></tr></table></figure></li><li>如果成功安装，Memtester 会返回版本号信息。</li></ul></li></ol><h3 id="5-2-基本内存测试"><a href="#5-2-基本内存测试" class="headerlink" title="5.2 基本内存测试"></a>5.2 基本内存测试</h3><ol><li><strong>运行Memtester</strong>:<ul><li><strong>目的</strong>: 测试指定大小的内存块以检测潜在的内存错误。</li><li><strong>步骤</strong>:<ol><li>以 root 或具有 sudo 权限的用户运行 Memtester：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo memtester &lt;测试内存大小&gt; &lt;测试次数&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>例如，要测试 1 GB 的内存并运行 5 次测试循环：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo memtester 1G 5</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>结果分析</strong>:<ul><li>Memtester 会显示内存测试的详细过程，包括每次测试的结果和通过或失败的标志。</li><li>输出示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">memtester version 4.3.0 (64-bit)</span><br><span class="line">Copyright (C) 2004 Charles Cazabon.</span><br><span class="line">Licensed under the GNU General Public License version 2 (only).</span><br><span class="line"></span><br><span class="line">pagesize is 4096</span><br><span class="line">pagesizemask is 0xfffffffffffff000</span><br><span class="line">want 1024MB (1073741824 bytes)</span><br><span class="line">got  1024MB (1073741824 bytes), trying mlock ...locked.</span><br><span class="line">Loop 1/5:</span><br><span class="line">Stuck Address       : ok</span><br><span class="line">Random Value        : ok</span><br><span class="line">Compare XOR         : ok</span><br><span class="line">Compare SUB         : ok</span><br><span class="line">Compare MUL         : ok</span><br><span class="line">Compare DIV         : ok</span><br><span class="line">Compare OR          : ok</span><br><span class="line">Compare AND         : ok</span><br><span class="line">Sequential Increment: ok</span><br><span class="line">Solid Bits          : ok</span><br><span class="line">Block Sequential    : ok</span><br><span class="line">Checkerboard        : ok</span><br><span class="line">Bit Spread          : ok</span><br><span class="line">Bit Flip            : ok</span><br><span class="line">Walking Ones        : ok</span><br><span class="line">Walking Zeroes      : ok</span><br><span class="line">8-bit Writes        : ok</span><br><span class="line">16-bit Writes       : ok</span><br></pre></td></tr></table></figure></li><li><code>ok</code> 表示该测试项通过。如果有任何测试未通过，Memtester 会在输出中标记错误。</li></ul></li></ul></li></ol><h3 id="5-3-高级内存测试"><a href="#5-3-高级内存测试" class="headerlink" title="5.3 高级内存测试"></a>5.3 高级内存测试</h3><ol><li><p><strong>测试所有可用内存</strong>:</p><ul><li><strong>目的</strong>: 在不指定内存大小的情况下，测试系统中所有可用的空闲内存。</li><li><strong>步骤</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo memtester $(free -m | grep -oP <span class="string">&#x27;\\d+&#x27;</span> | <span class="built_in">head</span> -n 1)M 1</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li>该命令会自动检测并使用系统的所有可用内存进行测试。</li><li>如果在测试期间检测到错误，Memtester 会报告并建议进一步的物理检查或更换内存模块。</li></ul></li></ul></li><li><p><strong>连续运行内存测试以检测间歇性错误</strong>:</p><ul><li><strong>目的</strong>: 长时间连续运行内存测试以捕获间歇性或偶发的内存错误。</li><li><strong>步骤</strong>:<ul><li>使用较大内存块和更多的测试循环，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo memtester 2G 50</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>结果分析</strong>:<ul><li>通过连续的测试循环，Memtester 能够检测到由于热胀冷缩或电气干扰导致的间歇性错误。</li><li>如果发现任何错误，建议检查物理内存模块，并考虑在不同的插槽中进行测试。</li></ul></li></ul></li></ol><h3 id="5-4-多任务环境中的内存测试"><a href="#5-4-多任务环境中的内存测试" class="headerlink" title="5.4 多任务环境中的内存测试"></a>5.4 多任务环境中的内存测试</h3><ol><li><strong>在多任务系统中运行Memtester</strong>:<ul><li><strong>目的</strong>: 在多任务负载下测试内存的稳定性。</li><li><strong>步骤</strong>:<ul><li>在进行内存测试时，可以让系统继续运行其他任务，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo memtester 512M 10 &amp;</span><br><span class="line">stress --cpu 4 --<span class="built_in">timeout</span> 600</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>结果分析</strong>:<ul><li>Memtester 与其他高负载任务（如 CPU 压力测试）同时运行，可以有效检测内存模块在高压力下的可靠性。</li><li>如果 Memtester 报告错误或系统崩溃，表明可能存在内存不稳定的情况。</li></ul></li></ul></li></ol><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul><li><a href="https://pyropus.ca/software/memtester/">Memtester 官方文档</a></li><li><a href="https://www.memtest86.com/troubleshooting.htm">内存测试与诊断指南</a></li><li><a href="https://www.redhat.com/en/topics/linux/hardware-diagnostics">系统硬件诊断最佳实践</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> Memtester </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stressapptest 测试</title>
      <link href="/2024/07/03/stressapptest_test/"/>
      <url>/2024/07/03/stressapptest_test/</url>
      
        <content type="html"><![CDATA[<h1 id="在-ARM-平台上使用-Stressapptest-进行压力测试"><a href="#在-ARM-平台上使用-Stressapptest-进行压力测试" class="headerlink" title="在 ARM 平台上使用 Stressapptest 进行压力测试"></a>在 ARM 平台上使用 Stressapptest 进行压力测试</h1><hr><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p>Stressapptest 是一款专门用于内存和 I&#x2F;O 子系统压力测试的工具。它通过在系统上施加高负荷来发现硬件问题，特别是在内存和缓存方面的潜在故障。<br>详细介绍了在 ARM 平台上安装、配置并运行 Stressapptest 进行系统稳定性和性能测试的过程。</p><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h4><p>适用于希望在平台上验证硬件稳定性和性能的技术人员，特别是在内存和 I&#x2F;O 方面的测试。</p><h4 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h4><ul><li><strong>系统管理员</strong>：确保系统已正确安装所有必需的依赖包，并具备执行测试所需的权限。</li><li><strong>操作员</strong>：按照本 SOP 正确执行 Stressapptest，确保测试顺利进行。</li></ul><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h4><ul><li>运行 Linux 操作系统（如 Debian 或 RHEL9）。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>有效的互联网连接以下载必要的软件包和工具。</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h4><h5 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h5><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装 Stressapptest</strong></p><ul><li><p><strong>在 Debian&#x2F;Ubuntu 系统上使用 <code>apt</code> 安装 Stressapptest：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install stressapptest</span><br></pre></td></tr></table></figure></li><li><p><strong>在 RHEL&#x2F;CentOS 系统上使用 <code>yum</code> 安装 Stressapptest：</strong></p><ul><li>首先，启用 EPEL 仓库（如果尚未启用）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure></li><li>然后安装 Stressapptest：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install stressapptest</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-手动下载并编译-Stressapptest"><a href="#2-手动下载并编译-Stressapptest" class="headerlink" title="2. 手动下载并编译 Stressapptest"></a>2. <strong>手动下载并编译 Stressapptest</strong></h5><blockquote><p>注意：如果通过包管理器安装 Stressapptest 不可行或需要最新版，可以通过手动编译安装。</p></blockquote><p>2.1 <strong>从 GitHub 克隆 Stressapptest 源码</strong></p><ul><li>使用以下命令从 GitHub 克隆 Stressapptest 项目到本地目录。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/stressapptest/stressapptest.git</span><br></pre></td></tr></table></figure></li></ul><p>2.2 <strong>进入项目目录</strong><br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> stressapptest</span><br></pre></td></tr></table></figure></p><p>2.3 <strong>编译 Stressapptest</strong></p><ul><li>使用以下命令编译 Stressapptest。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li></ul><p>2.4 <strong>安装 Stressapptest</strong></p><ul><li>编译完成后，可以选择将其安装到系统中，便于全局使用。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-配置与运行-Stressapptest"><a href="#3-配置与运行-Stressapptest" class="headerlink" title="3. 配置与运行 Stressapptest"></a>3. <strong>配置与运行 Stressapptest</strong></h5><p>3.1 <strong>运行基本测试</strong></p><ul><li>在默认配置下运行 Stressapptest。此命令将在默认设置下运行一个 20 分钟的压力测试：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stressapptest -s 1200 -M 1024 -W</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>-s 1200</code>：指定测试时长为 1200 秒（即 20 分钟）。</li><li><code>-M 1024</code>：使用 1024 MB 内存进行测试。</li><li><code>-W</code>：使测试过程的 I&#x2F;O 操作更具挑战性。</li></ul></li></ul><p>3.2 <strong>测试所有可用内存</strong></p><ul><li>为了测试系统的所有可用内存，使用 <code>-m</code> 选项指定测试内存的百分比。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stressapptest -s 1800 -m 90</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>-m 90</code>：使用 90% 的系统内存进行测试。</li><li><code>-s 1800</code>：测试时长为 1800 秒（即 30 分钟）。</li></ul></li></ul><p>3.3 <strong>并行运行多个测试实例</strong></p><ul><li>在多核系统上，可以并行运行多个测试实例，以加大测试负荷。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stressapptest -s 3600 -M 512 -m 80 -C 16</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>-C 16</code>：使用 16 个 CPU 核心进行测试。</li><li><code>-M 512</code>：每个测试实例使用 512 MB 内存。</li></ul></li></ul><h5 id="4-监控与分析测试结果"><a href="#4-监控与分析测试结果" class="headerlink" title="4. 监控与分析测试结果"></a>4. <strong>监控与分析测试结果</strong></h5><p>4.1 <strong>监控测试进度</strong></p><ul><li>在测试过程中，可以实时查看输出，了解测试进度和当前的系统状态。</li></ul><p>4.2 <strong>分析测试结果</strong></p><ul><li>测试完成后，Stressapptest 将生成一份测试报告，显示任何检测到的内存错误或 I&#x2F;O 错误。检查输出中的错误报告，以确定是否存在硬件问题。</li></ul><p>4.3 <strong>保存测试日志</strong></p><ul><li>可以将测试日志保存到文件中，以便后续分析：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stressapptest -s 3600 -M 1024 -W &gt; stressapptest_log.txt</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-优化与维护"><a href="#5-优化与维护" class="headerlink" title="5. 优化与维护"></a>5. <strong>优化与维护</strong></h5><p>5.1 <strong>定期测试</strong></p><ul><li>建议定期运行 Stressapptest，特别是在系统进行重大变更（如硬件升级或系统更新）之后，以确保系统的持续稳定性。</li></ul><p>5.2 <strong>调整参数</strong></p><ul><li>根据测试结果，调整 Stressapptest 的参数，以便更好地检测系统潜在问题。</li></ul><h5 id="6-常见问题与故障排除"><a href="#6-常见问题与故障排除" class="headerlink" title="6. 常见问题与故障排除"></a>6. <strong>常见问题与故障排除</strong></h5><p>6.1 <strong>测试失败或系统崩溃</strong></p><ul><li>如果在测试过程中系统崩溃或测试失败，请检查系统日志以确定故障原因。可能需要降低测试负荷，或排查硬件问题。</li></ul><p>6.2 <strong>内存不足</strong></p><ul><li>如果在测试过程中出现内存不足的错误，考虑减少分配给测试的内存量，或增加系统的虚拟内存。</li></ul><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h4><ul><li><a href="https://github.com/stressapptest/stressapptest">Stressapptest GitHub Repository</a></li><li><a href="https://linux.die.net/man/1/stressapptest">Linux Performance Tools</a></li><li><a href="https://linuxconfig.org/bash-scripting-tutorial-for-beginners">Bash Scripting Basics</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> Stressapptest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基本命令操作</title>
      <link href="/2024/07/02/linux_common_commands/"/>
      <url>/2024/07/02/linux_common_commands/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-基本命令操作"><a href="#Linux-基本命令操作" class="headerlink" title="Linux 基本命令操作"></a>Linux 基本命令操作</h1><hr><h2 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h2><ol><li><p><strong>列出目录内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file1.txt  file2.txt  directory1  directory2</span><br></pre></td></tr></table></figure></li><li><p><strong>切换到指定目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> directory1</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(无输出，仅切换目录)</span><br></pre></td></tr></table></figure></li><li><p><strong>显示当前工作目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/user/directory1</span><br></pre></td></tr></table></figure></li><li><p><strong>创建新目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> new_directory</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(无输出，仅创建目录)</span><br></pre></td></tr></table></figure></li><li><p><strong>删除文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> file1.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(无输出，仅删除文件)</span><br></pre></td></tr></table></figure></li></ol><h2 id="文件内容查看和编辑"><a href="#文件内容查看和编辑" class="headerlink" title="文件内容查看和编辑"></a>文件内容查看和编辑</h2><ol><li><p><strong>显示文件内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> file2.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is the content of file2.txt.</span><br></pre></td></tr></table></figure></li><li><p><strong>分页显示文件内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more file2.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the content of file2.txt.</span><br><span class="line">--More-- (按空格键翻页)</span><br></pre></td></tr></table></figure></li><li><p><strong>编辑文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano file2.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(进入 nano 编辑界面)</span><br></pre></td></tr></table></figure></li></ol><h2 id="文件权限和所有权"><a href="#文件权限和所有权" class="headerlink" title="文件权限和所有权"></a>文件权限和所有权</h2><ol><li><p><strong>更改文件权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 file2.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(无输出，仅更改权限)</span><br></pre></td></tr></table></figure></li><li><p><strong>更改文件所有者</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> newuser file2.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(无输出，仅更改所有者)</span><br></pre></td></tr></table></figure></li></ol><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><ol><li><p><strong>显示当前运行的进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> PID TTY          TIME CMD</span><br><span class="line">1056 pts/0    00:00:00 bash</span><br><span class="line">1082 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure></li><li><p><strong>实时显示系统资源使用情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top - 10:45:14 up 2 days,  4:22,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks: 118 total,   1 running, 117 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.7 us,  0.3 sy,  0.0 ni, 99.0 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  2048576 total,   192652 free,  1298964 used,   556960 buff/cache</span><br><span class="line">KiB Swap:  1048572 total,  1048572 free,        0 used.   652632 avail Mem </span><br></pre></td></tr></table></figure></li><li><p><strong>清除journalctl系统日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --flush --rotate --vacuum-time=1s</span><br></pre></td></tr></table></figure></li><li><p><strong>显示磁盘使用情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1        20G  9.3G  9.1G  51% /</span><br><span class="line">tmpfs           996M  1.2M  995M   1% /run</span><br></pre></td></tr></table></figure></li><li><p><strong>关机或重启系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo shutdown -h now</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(系统会显示关机通知并在几秒钟后关机)</span><br></pre></td></tr></table></figure></li></ol><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><ol><li><p><strong>检测网络连接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping google.com</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PING google.com (172.217.164.110) 56(84) bytes of data.</span><br><span class="line">64 bytes from lga25s61-in-f14.1e100.net (172.217.164.110): icmp_seq=1 ttl=54 time=10.8 ms</span><br></pre></td></tr></table></figure></li><li><p><strong>设置 terminal proxy</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://192.168.50.1:58080&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://192.168.50.1:58080&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 proxychains proxy</strong></p><p>A. 安装 proxychains</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install proxychains</span><br></pre></td></tr></table></figure><p>B. 修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/proxychains.conf</span><br><span class="line"><span class="comment"># Quiet mode (no output from library)</span></span><br><span class="line">quiet_mode</span><br><span class="line"></span><br><span class="line">[ProxyList]</span><br><span class="line"><span class="comment"># add proxy here ...</span></span><br><span class="line"><span class="comment"># meanwile</span></span><br><span class="line"><span class="comment"># defaults set to &quot;tor&quot;</span></span><br><span class="line"><span class="comment">#socks4         127.0.0.1 9050</span></span><br><span class="line">http    192.168.50.1    58080</span><br></pre></td></tr></table></figure><p>C. 使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains apt update</span><br></pre></td></tr></table></figure></li></ol><h2 id="软件安装相关"><a href="#软件安装相关" class="headerlink" title="软件安装相关"></a>软件安装相关</h2><ol><li><p><strong>apt 安装软件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install stress</span><br></pre></td></tr></table></figure></li><li><p><strong>apt 卸载软件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt remove stress</span><br></pre></td></tr></table></figure></li><li><p><strong>apt 搜索软件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search stress</span><br></pre></td></tr></table></figure></li><li><p><strong>dpkg 查看已安装软件信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l</span><br></pre></td></tr></table></figure></li><li><p><strong>编译安装</strong></p><p>A. 安装编译组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -y build-essential</span><br></pre></td></tr></table></figure><p>B. 下载并解压 source code</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://jaist.dl.sourceforge.net/project/smartmontools/smartmontools/7.4/smartmontools-7.4.tar.gz</span><br><span class="line">tar xvf smartmontools-7.4.tar.gz</span><br></pre></td></tr></table></figure><p>C. 编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> smartmontools-7.4/</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>D. 检查是否成功编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smartctl -v</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机迁移指南</title>
      <link href="/2024/06/30/VM_Migration_Guide_Full/"/>
      <url>/2024/06/30/VM_Migration_Guide_Full/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机迁移指南"><a href="#虚拟机迁移指南" class="headerlink" title="虚拟机迁移指南"></a>虚拟机迁移指南</h1><hr><h2 id="1-确保虚拟机是持久化的"><a href="#1-确保虚拟机是持久化的" class="headerlink" title="1. 确保虚拟机是持久化的"></a>1. 确保虚拟机是持久化的</h2><p>虚拟机必须是持久化的才能进行迁移。如果虚拟机是临时的（transient），需要先将其配置为持久化。</p><h3 id="将临时虚拟机转换为持久化虚拟机"><a href="#将临时虚拟机转换为持久化虚拟机" class="headerlink" title="将临时虚拟机转换为持久化虚拟机"></a>将临时虚拟机转换为持久化虚拟机</h3><p>如果虚拟机是临时的，可以使用以下命令将其转换为持久化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh dumpxml mgtest &gt; /tmp/mgtest.xml</span><br><span class="line">sudo virsh define /tmp/mgtest.xml</span><br></pre></td></tr></table></figure><h2 id="2-在线迁移虚拟机"><a href="#2-在线迁移虚拟机" class="headerlink" title="2. 在线迁移虚拟机"></a>2. 在线迁移虚拟机</h2><h3 id="确保虚拟机磁盘缓存设置为-none-或-directsync"><a href="#确保虚拟机磁盘缓存设置为-none-或-directsync" class="headerlink" title="确保虚拟机磁盘缓存设置为 none 或 directsync"></a>确保虚拟机磁盘缓存设置为 none 或 directsync</h3><p>编辑虚拟机的 XML 配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh edit mgtest</span><br></pre></td></tr></table></figure><p>在 <code>&lt;disk&gt;</code> 部分中添加或修改 <code>&lt;driver&gt;</code> 部分，将 <code>cache</code> 设置为 <code>none</code> 或 <code>directsync</code>，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span> <span class="attr">device</span>=<span class="string">&#x27;disk&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&#x27;qemu&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;qcow2&#x27;</span> <span class="attr">cache</span>=<span class="string">&#x27;none&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&#x27;/mnt/nfs_share/mgtest.qcow2&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;vda&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;virtio&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x04&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br></pre></td></tr></table></figure><p>保存并退出编辑器。</p><h3 id="重启虚拟机"><a href="#重启虚拟机" class="headerlink" title="重启虚拟机"></a>重启虚拟机</h3><p>为了使配置生效，需要重启虚拟机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh shutdown mgtest</span><br><span class="line">sudo virsh start mgtest</span><br></pre></td></tr></table></figure><h3 id="进行在线迁移"><a href="#进行在线迁移" class="headerlink" title="进行在线迁移"></a>进行在线迁移</h3><p>使用以下命令进行在线迁移：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh migrate --live mgtest qemu+ssh://192.168.50.235/system</span><br></pre></td></tr></table></figure><h2 id="3-离线迁移虚拟机"><a href="#3-离线迁移虚拟机" class="headerlink" title="3. 离线迁移虚拟机"></a>3. 离线迁移虚拟机</h2><h3 id="确保虚拟机是持久化的"><a href="#确保虚拟机是持久化的" class="headerlink" title="确保虚拟机是持久化的"></a>确保虚拟机是持久化的</h3><p>如果虚拟机是临时的，可以使用以下命令将其转换为持久化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh dumpxml mgtest &gt; /tmp/mgtest.xml</span><br><span class="line">sudo virsh define /tmp/mgtest.xml</span><br></pre></td></tr></table></figure><h3 id="关闭虚拟机"><a href="#关闭虚拟机" class="headerlink" title="关闭虚拟机"></a>关闭虚拟机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh shutdown mgtest</span><br></pre></td></tr></table></figure><h3 id="进行离线迁移"><a href="#进行离线迁移" class="headerlink" title="进行离线迁移"></a>进行离线迁移</h3><p>执行离线迁移命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh migrate --offline --persistent mgtest qemu+ssh://192.168.50.235/system</span><br></pre></td></tr></table></figure><h2 id="4-示例流程"><a href="#4-示例流程" class="headerlink" title="4. 示例流程"></a>4. 示例流程</h2><h3 id="检查虚拟机状态"><a href="#检查虚拟机状态" class="headerlink" title="检查虚拟机状态"></a>检查虚拟机状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh list --all</span><br></pre></td></tr></table></figure><h3 id="将临时虚拟机转换为持久化（如果需要）"><a href="#将临时虚拟机转换为持久化（如果需要）" class="headerlink" title="将临时虚拟机转换为持久化（如果需要）"></a>将临时虚拟机转换为持久化（如果需要）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh dumpxml mgtest &gt; /tmp/mgtest.xml</span><br><span class="line">sudo virsh define /tmp/mgtest.xml</span><br></pre></td></tr></table></figure><h3 id="关闭虚拟机-1"><a href="#关闭虚拟机-1" class="headerlink" title="关闭虚拟机"></a>关闭虚拟机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh shutdown mgtest</span><br></pre></td></tr></table></figure><h3 id="进行在线迁移-1"><a href="#进行在线迁移-1" class="headerlink" title="进行在线迁移"></a>进行在线迁移</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh migrate --live mgtest qemu+ssh://192.168.50.235/system</span><br></pre></td></tr></table></figure><h3 id="进行离线迁移-1"><a href="#进行离线迁移-1" class="headerlink" title="进行离线迁移"></a>进行离线迁移</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh migrate --offline --persistent mgtest qemu+ssh://192.168.50.235/system</span><br></pre></td></tr></table></figure><h2 id="5-NFS-配置步骤"><a href="#5-NFS-配置步骤" class="headerlink" title="5. NFS 配置步骤"></a>5. NFS 配置步骤</h2><h3 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h3><ol><li><p><strong>安装NFS服务器：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure></li><li><p><strong>创建共享目录：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /srv/nfs_share</span><br><span class="line">sudo <span class="built_in">chown</span> nobody:nogroup /srv/nfs_share</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 /srv/nfs_share</span><br></pre></td></tr></table></figure></li><li><p><strong>配置NFS导出：</strong></p><p>编辑 <code>/etc/exports</code> 文件，添加共享目录的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/exports</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/srv/nfs_share 192.168.50.0/24(rw,sync,no_subtree_check,no_root_squash)</span><br></pre></td></tr></table></figure></li><li><p><strong>导出NFS共享目录：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo exportfs -ra</span><br></pre></td></tr></table></figure></li><li><p><strong>启动并启用NFS服务：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nfs-kernel-server</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> nfs-kernel-server</span><br></pre></td></tr></table></figure></li></ol><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><ol><li><p><strong>安装NFS客户端：</strong></p><p>在两个主机上分别安装NFS客户端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nfs-common</span><br></pre></td></tr></table></figure></li><li><p><strong>创建挂载点目录：</strong></p><p>在两个主机上分别创建挂载点目录，例如 <code>/mnt/nfs_share</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /mnt/nfs_share</span><br></pre></td></tr></table></figure></li><li><p><strong>挂载NFS共享目录：</strong></p><p>在两个主机上分别执行以下命令，将NFS共享目录挂载到本地目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t nfs -o rw 192.168.50.100:/srv/nfs_share /mnt/nfs_share</span><br></pre></td></tr></table></figure></li><li><p><strong>配置自动挂载（可选）：</strong></p><p>为了在系统重启后自动挂载NFS共享目录，可以编辑 <code>/etc/fstab</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/fstab</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.50.100:/srv/nfs_share /mnt/nfs_share nfs defaults 0 0</span><br></pre></td></tr></table></figure></li></ol><h3 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h3><ol><li><p><strong>验证挂载：</strong></p><p>在两个主机上分别执行以下命令，确认NFS共享目录是否成功挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure></li><li><p><strong>测试读写权限：</strong></p><p>在两个主机上分别尝试在挂载的共享目录中创建文件，确保读写权限正常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">touch</span> /mnt/nfs_share/testfile</span><br><span class="line"><span class="built_in">ls</span> -l /mnt/nfs_share/testfile</span><br></pre></td></tr></table></figure></li></ol><p>通过以上步骤，可以配置和验证NFS共享目录，以便在虚拟机迁移过程中使用。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>禁用 Debian 系统的屏幕锁定和自动睡眠</title>
      <link href="/2024/06/30/disable_screen_lock_and_sleep/"/>
      <url>/2024/06/30/disable_screen_lock_and_sleep/</url>
      
        <content type="html"><![CDATA[<h1 id="禁用-Debian-系统的屏幕锁定和自动睡眠"><a href="#禁用-Debian-系统的屏幕锁定和自动睡眠" class="headerlink" title="禁用 Debian 系统的屏幕锁定和自动睡眠"></a>禁用 Debian 系统的屏幕锁定和自动睡眠</h1><p>本文档提供了禁用 Debian 系统屏幕锁定和自动睡眠功能的详细步骤。</p><h2 id="1-禁用屏幕锁定"><a href="#1-禁用屏幕锁定" class="headerlink" title="1. 禁用屏幕锁定"></a>1. 禁用屏幕锁定</h2><p>首先，确保屏幕锁定被禁用。你可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.screensaver lock-enabled <span class="literal">false</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.screensaver idle-activation-enabled <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="2-禁用系统睡眠"><a href="#2-禁用系统睡眠" class="headerlink" title="2. 禁用系统睡眠"></a>2. 禁用系统睡眠</h2><p>要禁用系统的自动睡眠功能，可以通过 <code>systemd</code> 的配置文件来实现。编辑 <code>/etc/systemd/logind.conf</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/logind.conf</span><br></pre></td></tr></table></figure><p>找到并修改以下行：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#HandleLidSwitch=suspend</span></span><br><span class="line"><span class="attr">HandleLidSwitch</span>=ignore</span><br><span class="line"><span class="comment">#HandleLidSwitchDocked=ignore</span></span><br><span class="line"><span class="attr">HandleLidSwitchDocked</span>=ignore</span><br><span class="line"><span class="comment">#HandleSuspendKey=suspend</span></span><br><span class="line"><span class="attr">HandleSuspendKey</span>=ignore</span><br><span class="line"><span class="comment">#HandleHibernateKey=hibernate</span></span><br><span class="line"><span class="attr">HandleHibernateKey</span>=ignore</span><br><span class="line"><span class="comment">#HandleLidSwitchExternalPower=suspend</span></span><br><span class="line"><span class="attr">HandleLidSwitchExternalPower</span>=ignore</span><br><span class="line"><span class="comment">#HandleLidSwitchDockedExternalPower=ignore</span></span><br><span class="line"><span class="attr">HandleLidSwitchDockedExternalPower</span>=ignore</span><br></pre></td></tr></table></figure><p>保存文件并重启 <code>systemd-logind</code> 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart systemd-logind</span><br></pre></td></tr></table></figure><h2 id="3-禁用-GNOME-电源设置中的自动睡眠"><a href="#3-禁用-GNOME-电源设置中的自动睡眠" class="headerlink" title="3. 禁用 GNOME 电源设置中的自动睡眠"></a>3. 禁用 GNOME 电源设置中的自动睡眠</h2><p>打开终端，使用以下命令禁用 GNOME 电源设置中的自动睡眠：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.power sleep-inactive-ac-timeout 0</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.power sleep-inactive-battery-timeout 0</span><br></pre></td></tr></table></figure><h2 id="4-确认配置"><a href="#4-确认配置" class="headerlink" title="4. 确认配置"></a>4. 确认配置</h2><p>再次检查这些配置是否已经生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gsettings get org.gnome.desktop.screensaver lock-enabled</span><br><span class="line">gsettings get org.gnome.desktop.screensaver idle-activation-enabled</span><br><span class="line">gsettings get org.gnome.settings-daemon.plugins.power sleep-inactive-ac-timeout</span><br><span class="line">gsettings get org.gnome.settings-daemon.plugins.power sleep-inactive-battery-timeout</span><br></pre></td></tr></table></figure><h2 id="5-检查日志信息"><a href="#5-检查日志信息" class="headerlink" title="5. 检查日志信息"></a>5. 检查日志信息</h2><p>如果问题依旧存在，请检查系统日志以获取更多信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -xe</span><br></pre></td></tr></table></figure><p>通过以上步骤，你应该能够成功禁用 Debian 系统中的屏幕锁定和自动睡眠功能。如果需要更多帮助，请提供更详细的信息以便进一步排查。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World!</title>
      <link href="/2024/06/30/hello-world/"/>
      <url>/2024/06/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> template </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POST TEMPLATE</title>
      <link href="/2024/06/30/post_template/"/>
      <url>/2024/06/30/post_template/</url>
      
        <content type="html"><![CDATA[<p>写法解释<br>title【必需】文章标题<br>date【必需】文章创建日期<br>updated【可选】文章更新日期<br>tags【可选】文章标签<br>categories【可选】文章分类<br>keywords【可选】文章关键字<br>description【可选】文章描述<br>top_img【可选】文章顶部图片<br>cover【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false&#x2F;图片地址&#x2F;留空)<br>comments【可选】显示文章评论模块(默认 true)<br>toc【可选】显示文章TOC(默认为设置中toc的enable配置)<br>toc_number【可选】显示toc_number(默认为设置中toc的number配置)<br>toc_style_simple【可选】显示 toc 简洁模式<br>copyright【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)<br>copyright_author【可选】文章版权模块的文章作者<br>copyright_author_href【可选】文章版权模块的文章作者链接<br>copyright_url【可选】文章版权模块的文章连结链接<br>copyright_info【可选】文章版权模块的版权声明文字<br>mathjax【可选】显示mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false )<br>katex【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false )<br>aplayer【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置<br>highlight_shrink【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中 highlight_shrink 的配置)<br>aside【可选】显示侧边栏 (默认 true)<br>abcjs【可选】加载 abcjs (当设置 abcjs 的 per_page: false 时，才需要配置，默认 false )</p><p>作者: Jerry<br>連結: <a href="https://butterfly.js.org/posts/dc584b87/#Post-Front-matter">https://butterfly.js.org/posts/dc584b87/#Post-Front-matter</a><br>來源: Butterfly<br>著作權歸作者所有。商業轉載請聯繫作者獲得授權，非商業轉載請註明出處。</p>]]></content>
      
      
      
        <tags>
            
            <tag> template </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Template</title>
      <link href="/2024/06/28/README/"/>
      <url>/2024/06/28/README/</url>
      
        <content type="html"><![CDATA[<img src="https://raw.githubusercontent.com/hexojs/logo/master/hexo-logo-avatar.png" alt="Hexo logo" width="100" height="100" align="right" /><h1 id="Hexo-Template"><a href="#Hexo-Template" class="headerlink" title="Hexo Template"></a>Hexo Template</h1><blockquote><p>A fast, simple &amp; powerful blog framework, powered by <a href="https://nodejs.org/">Node.js</a>. Here is the template of it.</p></blockquote><p><a href="https://mmdjiji.github.io/hexo-template">Demo</a> |<br><a href="https://hexo.io/">Official Website</a> |<br><a href="https://hexo.io/docs/">Documentation</a> |<br><a href="https://github.com/mmdjiji/hexo-template">GitHub</a></p><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><p>There are two lines to modify in <code>_config.yml</code>:</p><ol><li><p>Set your site url at <strong>line 16</strong>. For example, if you use GitHub Page, set url as <code>https://username.github.io/project</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://jiji.pro/hexo-template</span></span><br></pre></td></tr></table></figure></li><li><p>Set your project name at <strong>line 107</strong>, if your project name is <code>username</code> or <code>username.github.io</code>, just remove it at the end of <code>_config.yml</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">root:</span> <span class="string">/hexo-template</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h2><p>This repository uses GitHub Actions for CI&#x2F;CD. You don’t need to build your documents manually. Just commit your documents (then run <code>git push</code>), and then turn on the GitHub Pages in the settings to access your online documents. (For this demo is <a href="https://mmdjiji.github.io/hexo-template">https://mmdjiji.github.io/hexo-template</a>)</p><h2 id="Hexo-Features"><a href="#Hexo-Features" class="headerlink" title="Hexo Features"></a>Hexo Features</h2><ul><li>Blazing fast generating</li><li>Support for GitHub Flavored Markdown and most Octopress plugins</li><li>One-command deploy to GitHub Pages, Heroku, etc.</li><li>Powerful API for limitless extensibility</li><li>Hundreds of <a href="https://hexo.io/themes/">themes</a> &amp; <a href="https://hexo.io/plugins/">plugins</a></li></ul><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><p><strong>Install Hexo</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>Install with <a href="https://brew.sh/">brew</a> on macOS and Linux:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install hexo</span><br></pre></td></tr></table></figure><p><strong>Setup your blog</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br></pre></td></tr></table></figure><p><strong>Start the server</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p><strong>Create a new post</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;Hello Hexo&quot;</span></span><br></pre></td></tr></table></figure><p><strong>Generate static files</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h2 id="More-Information"><a href="#More-Information" class="headerlink" title="More Information"></a>More Information</h2><ul><li>Read the <a href="https://hexo.io/">documentation</a></li><li>Visit the <a href="https://github.com/hexojs/awesome-hexo">Awesome Hexo</a> list</li><li>Find solutions in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a></li><li>Join discussion on <a href="https://groups.google.com/group/hexo">Google Group</a>, <a href="https://discord.gg/teM2Anj">Discord</a>, <a href="https://gitter.im/hexojs/hexo">Gitter</a> or <a href="https://t.me/hexojs">Telegram</a></li><li>See the <a href="https://hexo.io/plugins/">plugin list</a> and the <a href="https://hexo.io/themes/">theme list</a> on wiki</li><li>Follow <a href="https://twitter.com/hexojs">@hexojs</a> for latest news</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Follows <a href="https://github.com/hexojs/hexo">hexojs&#x2F;hexo</a> , use <a href="LICENSE">MIT License</a>.</p><p><a href="https://app.fossa.com/projects/git%2Bgithub.com%2Fhexojs%2Fhexo?ref=badge_large"><img src="https://app.fossa.com/api/projects/git%2Bgithub.com%2Fhexojs%2Fhexo.svg?type=large" alt="FOSSA Status"></a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Template </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
