<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数字证书、证书颁发机构 (CA)、私钥、公钥和数字签名</title>
      <link href="/2024/08/14/Digital_Certificate_SOP/"/>
      <url>/2024/08/14/Digital_Certificate_SOP/</url>
      
        <content type="html"><![CDATA[<h1 id="数字证书、证书颁发机构-CA-、私钥、公钥和数字签名"><a href="#数字证书、证书颁发机构-CA-、私钥、公钥和数字签名" class="headerlink" title="数字证书、证书颁发机构 (CA)、私钥、公钥和数字签名"></a>数字证书、证书颁发机构 (CA)、私钥、公钥和数字签名</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>概述了使用数字证书、证书颁发机构 (CA)、私钥、公钥和数字签名的基本概念和程序。这些组件对于确保通信安全、验证数字数据的真实性和完整性至关重要。</p><h2 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="2. 适用范围"></a>2. 适用范围</h2><p>适用于组织内负责管理、部署和使用数字证书和加密技术的IT安全专业人员、系统管理员和开发人员。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>IT安全团队</strong>：管理数字证书的生命周期，包括颁发、更新和吊销，确保符合安全策略。</li><li><strong>系统管理员</strong>：配置系统以使用数字证书，并管理私钥的安全存储。</li><li><strong>开发人员</strong>：在应用程序中集成公钥和私钥，以实现安全通信协议。</li><li><strong>终端用户</strong>：使用配置了有效和可信证书的系统。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>可信的证书颁发机构 (CA) 或内部CA设置。</li><li>生成加密密钥对的工具（例如OpenSSL）。</li><li>私钥的安全存储机制，如硬件安全模块 (HSM) 或加密文件。</li><li>配置为支持TLS&#x2F;SSL协议的应用程序或系统，用于安全的数据传输。</li></ul><h2 id="5-流程"><a href="#5-流程" class="headerlink" title="5. 流程"></a>5. 流程</h2><p><img src="https://lilinth.github.io/picx-images-hosting/8740f369-7073-4439-9658-d2729bdfb355[1].13lp5jsm8r.webp" alt="8740f369-7073-4439-9658-d2729bdfb355[1]"></p><h3 id="5-1-生成密钥对"><a href="#5-1-生成密钥对" class="headerlink" title="5.1 生成密钥对"></a>5.1 生成密钥对</h3><ol><li><p><strong>生成私钥</strong>：</p><ul><li>使用加密工具（如OpenSSL）创建私钥。</li><li>示例命令：<code>openssl genpkey -algorithm RSA -out private_key.pem -aes256</code></li><li>私钥必须安全存储，因为它对于加密和签名创建至关重要。</li></ul></li><li><p><strong>派生公钥</strong>：</p><ul><li>从私钥中提取公钥，可与他人共享。</li><li>示例命令：<code>openssl rsa -pubout -in private_key.pem -out public_key.pem</code></li><li>公钥用于加密和验证数字签名。</li></ul></li></ol><h3 id="5-2-创建证书签名请求-CSR"><a href="#5-2-创建证书签名请求-CSR" class="headerlink" title="5.2 创建证书签名请求 (CSR)"></a>5.2 创建证书签名请求 (CSR)</h3><ol><li><strong>生成CSR</strong>：<ul><li>使用私钥创建包含公钥和组织信息的CSR。</li><li>示例命令：<code>openssl req -new -key private_key.pem -out csr.pem</code></li><li>将CSR提交给CA进行验证和证书颁发。</li></ul></li></ol><h3 id="5-3-证书颁发机构-CA-操作"><a href="#5-3-证书颁发机构-CA-操作" class="headerlink" title="5.3 证书颁发机构 (CA) 操作"></a>5.3 证书颁发机构 (CA) 操作</h3><ol><li><p><strong>签署CSR</strong>：</p><ul><li>CA审核CSR，验证后进行签名并颁发数字证书。</li><li>该证书用于服务器在安全通信中验证其身份。</li><li>内部CA的示例命令：<code>openssl x509 -req -days 365 -in csr.pem -signkey ca_private_key.pem -out certificate.pem</code></li></ul></li><li><p><strong>证书更新</strong>：</p><ul><li>在证书过期之前，生成新的CSR并提交给CA。</li><li>CA颁发新的证书，并更新有效期。</li></ul></li></ol><h3 id="5-4-数字签名和验证"><a href="#5-4-数字签名和验证" class="headerlink" title="5.4 数字签名和验证"></a>5.4 数字签名和验证</h3><ol><li><p><strong>创建数字签名</strong>：</p><ul><li>通过对消息或文档进行哈希处理并使用私钥加密哈希值来签名。</li><li>这可确保消息的完整性和真实性。</li><li>示例：<code>openssl dgst -sha256 -sign private_key.pem -out signature.sig file_to_sign.txt</code></li></ul></li><li><p><strong>验证数字签名</strong>：</p><ul><li>使用发送方的公钥解密哈希值，并将其与根据收到的文档计算的哈希值进行比较，以验证签名的真实性。</li><li>示例：<code>openssl dgst -sha256 -verify public_key.pem -signature signature.sig file_to_verify.txt</code></li></ul></li></ol><h3 id="5-5-管理证书吊销"><a href="#5-5-管理证书吊销" class="headerlink" title="5.5 管理证书吊销"></a>5.5 管理证书吊销</h3><ol><li><strong>吊销证书</strong>：<ul><li>如果证书被泄露，应立即通过CA吊销。</li><li>CA会将证书添加到证书吊销列表 (CRL) 中，系统会检查CRL以避免使用被泄露的证书。</li><li>创建CRL的示例命令：<code>openssl ca -gencrl -out crl.pem</code></li></ul></li></ol><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul><li><a href="https://www.openssl.org/docs/">OpenSSL文档</a></li><li><a href="https://www.digicert.com/ssl/">理解数字证书</a></li><li><a href="https://www.globalsign.com/en/blog/what-is-a-certificate-authority">证书颁发机构概述</a></li><li><a href="https://www.cloudflare.com/learning/ssl/what-is-public-key-infrastructure-pki/">PKI和数字签名</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Certificate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Fio 工具进行性能测试</title>
      <link href="/2024/08/14/fio_test/"/>
      <url>/2024/08/14/fio_test/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Fio-工具进行性能测试"><a href="#使用-Fio-工具进行性能测试" class="headerlink" title="使用 Fio 工具进行性能测试"></a>使用 Fio 工具进行性能测试</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>详细介绍如何使用Fio（Flexible I&#x2F;O Tester）工具进行存储性能测试。Fio是一款广泛应用的工具，能够测试块设备和文件系统的读写性能。本文将结合多个实际示例，逐步说明如何配置和运行Fio测试，并解析每个测试结果。</p><h2 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="2. 适用范围"></a>2. 适用范围</h2><p>适用于系统管理员、存储工程师和开发人员，他们需要对各种存储设备（如HDD、SSD、RAID阵列、SAN和NAS设备）进行性能评估。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>系统管理员</strong>: 负责安装和配置Fio工具，确保测试环境的稳定性和一致性。</li><li><strong>存储工程师</strong>: 设计测试参数和负载模型，以模拟实际使用场景。</li><li><strong>开发人员</strong>: 使用Fio生成性能数据，帮助优化应用程序的I&#x2F;O操作。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>安装了Fio工具的系统。</li><li>对目标存储设备的完全访问权限。</li><li>理解存储设备和文件系统的基本原理。</li><li>适当的权限执行性能测试，以避免影响生产环境。</li></ul><h2 id="5-流程和示例"><a href="#5-流程和示例" class="headerlink" title="5. 流程和示例"></a>5. 流程和示例</h2><h3 id="5-1-安装-Fio"><a href="#5-1-安装-Fio" class="headerlink" title="5.1 安装 Fio"></a>5.1 安装 Fio</h3><ol><li><p><strong>在Linux上安装Fio</strong>:</p><ul><li>大多数Linux发行版可以通过包管理器安装Fio。</li><li>使用以下命令安装Fio:<ul><li><strong>Debian&#x2F;Ubuntu</strong>: <code>sudo apt-get install fio</code></li><li><strong>CentOS&#x2F;RHEL</strong>: <code>sudo yum install fio</code></li><li><strong>Fedora</strong>: <code>sudo dnf install fio</code></li></ul></li></ul></li><li><p><strong>验证安装</strong>:</p><ul><li>使用命令 <code>fio --version</code> 验证Fio是否成功安装。</li></ul></li></ol><h3 id="5-2-基本测试命令"><a href="#5-2-基本测试命令" class="headerlink" title="5.2 基本测试命令"></a>5.2 基本测试命令</h3><ol><li><strong>运行简单的读写测试</strong>:<ul><li>以下命令将在指定的文件或设备上运行基本的顺序写入和读取测试。</li><li>示例命令: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=basic_test --filename=/path/to/testfile --size=1G --rw=readwrite --bs=4k --ioengine=libaio --numjobs=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure></li><li>参数说明:<ul><li><code>--name=basic_test</code>: 测试任务的名称。</li><li><code>--filename=/path/to/testfile</code>: 测试的目标文件或设备。</li><li><code>--size=1G</code>: 文件大小为1GB。</li><li><code>--rw=readwrite</code>: 读写混合测试。</li><li><code>--bs=4k</code>: 块大小为4KB。</li><li><code>--ioengine=libaio</code>: 使用Linux异步I&#x2F;O引擎。</li><li><code>--numjobs=1</code>: 使用单个工作线程。</li><li><code>--runtime=60</code>: 运行时间为60秒。</li><li><code>--group_reporting</code>: 汇总报告输出。</li></ul></li></ul></li></ol><h3 id="5-3-复杂测试"><a href="#5-3-复杂测试" class="headerlink" title="5.3 复杂测试"></a>5.3 复杂测试</h3><ol><li><p><strong>运行随机读写测试</strong>:</p><ul><li>对存储设备进行随机读写测试，以模拟实际工作负载。</li><li>示例命令:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=random_test --filename=/path/to/testfile --size=2G --rw=randrw --bs=4k --ioengine=libaio --numjobs=4 --runtime=120 --rwmixread=70 --group_reporting</span><br></pre></td></tr></table></figure></li><li>额外参数:<ul><li><code>--rw=randrw</code>: 随机读写测试。</li><li><code>--rwmixread=70</code>: 设置读操作占比为70%。</li></ul></li></ul></li><li><p><strong>测试多线程性能</strong>:</p><ul><li>使用多个工作线程同时对设备进行读写，以测试多线程性能。</li><li>示例命令:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=multithread_test --filename=/path/to/testfile --size=4G --rw=randwrite --bs=8k --ioengine=libaio --numjobs=8 --runtime=180 --group_reporting</span><br></pre></td></tr></table></figure></li><li>该命令使用8个线程，每个线程执行随机写操作。</li></ul></li></ol><h3 id="5-4-分析结果"><a href="#5-4-分析结果" class="headerlink" title="5.4 分析结果"></a>5.4 分析结果</h3><ol><li><p><strong>查看测试报告</strong>:</p><ul><li>Fio的输出会包含每个测试的详细报告，包括吞吐量、IOPS、延迟等指标。</li><li>示例输出分析:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Run status group 0 (all jobs):</span><br><span class="line">  READ: io=1048576KB, bw=17496KB/s, iops=4374, runt= 60001msec</span><br><span class="line">  WRITE: io=1048576KB, bw=17496KB/s, iops=4374, runt= 60001msec</span><br></pre></td></tr></table></figure></li><li><code>bw</code>表示带宽（吞吐量），<code>iops</code>表示每秒I&#x2F;O操作次数，<code>runt</code>表示测试运行时间。</li></ul></li><li><p><strong>保存结果</strong>:</p><ul><li>可以将结果输出保存到文件中进行进一步分析。</li><li>使用 <code>--output=&lt;filename&gt;</code> 参数保存报告，例如:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=basic_test --filename=/path/to/testfile --size=1G --rw=readwrite --bs=4k --ioengine=libaio --numjobs=1 --runtime=60 --group_reporting --output=fio_report.txt</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="6-更多示例"><a href="#6-更多示例" class="headerlink" title="6. 更多示例"></a>6. 更多示例</h2><h3 id="6-1-基本顺序读写测试"><a href="#6-1-基本顺序读写测试" class="headerlink" title="6.1 基本顺序读写测试"></a>6.1 基本顺序读写测试</h3><ol><li><p><strong>顺序写入测试</strong></p><ul><li><strong>目的</strong>: 测试存储设备在顺序写入数据时的性能，这对数据仓库或视频存储系统等大文件顺序写入场景非常重要。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=seq_write --filename=/path/to/testfile --size=10G --rw=write --bs=1M --direct=1 --ioengine=libaio --numjobs=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>bw</code>: 测试期间的平均带宽，反映了设备的顺序写入速度。</li><li><code>iops</code>: 每秒I&#x2F;O操作次数，通常用于衡量设备的响应能力。</li><li>例如，如果 <code>bw=500MB/s</code> 和 <code>iops=500</code>，这表明设备在此测试中能够维持500MB&#x2F;s的顺序写入速度。</li></ul></li></ul></li><li><p><strong>顺序读取测试</strong></p><ul><li><strong>目的</strong>: 测试存储设备在顺序读取数据时的性能，适用于需要大量顺序读取操作的场景，如视频播放或数据分析。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=seq_read --filename=/path/to/testfile --size=10G --rw=<span class="built_in">read</span> --bs=1M --direct=1 --ioengine=libaio --numjobs=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>bw</code>: 测试期间的平均读取带宽。</li><li>例如，<code>bw=600MB/s</code> 表示设备能够以600MB&#x2F;s的速度顺序读取数据，这对于顺序数据访问模式的应用非常理想。</li></ul></li></ul></li></ol><h3 id="6-2-随机读写测试"><a href="#6-2-随机读写测试" class="headerlink" title="6.2 随机读写测试"></a>6.2 随机读写测试</h3><ol><li><p><strong>随机写入测试</strong></p><ul><li><strong>目的</strong>: 测试设备在随机写入数据时的性能，模拟数据库写入、日志记录等需要频繁写入小块数据的场景。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=rand_write --filename=/path/to/testfile --size=5G --rw=randwrite --bs=4k --direct=1 --ioengine=libaio --numjobs=4 --runtime=120 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>iops</code>: 随机写入操作的IOPS通常是关注的重点，反映了设备在处理小块随机写入时的能力。</li><li><code>lat</code>: 延迟时间，表示每次I&#x2F;O操作的平均时间，延迟越低越好。</li><li>例如，<code>iops=20000</code> 和 <code>lat=0.1ms</code> 表示设备在随机写入小块数据时表现良好。</li></ul></li></ul></li><li><p><strong>随机读取测试</strong></p><ul><li><strong>目的</strong>: 测试存储设备在随机读取数据时的性能，适用于OLTP数据库或高并发读取的应用场景。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=rand_read --filename=/path/to/testfile --size=5G --rw=randread --bs=4k --direct=1 --ioengine=libaio --numjobs=4 --runtime=120 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>iops</code> 和 <code>lat</code> 是评估设备随机读取性能的重要指标。</li><li>例如，如果 <code>iops=50000</code> 和 <code>lat=0.08ms</code>，这表明设备在高负载下也能快速响应随机读取请求。</li></ul></li></ul></li><li><p><strong>随机读写混合测试</strong></p><ul><li><strong>目的</strong>: 测试读写混合场景下的存储性能，常见于需要同时处理读取和写入请求的系统，如文件服务器或虚拟化环境。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=rand_rw_mix --filename=/path/to/testfile --size=5G --rw=randrw --bs=4k --direct=1 --ioengine=libaio --numjobs=4 --runtime=120 --rwmixread=70 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>rwmixread=70</code> 设置读写比例为70%读和30%写，这能测试出设备在读写混合负载下的表现。</li><li>观察 <code>iops</code> 和 <code>lat</code> 来评估在这种混合场景下的性能。</li></ul></li></ul></li></ol><h3 id="6-3-多线程和多进程测试"><a href="#6-3-多线程和多进程测试" class="headerlink" title="6.3 多线程和多进程测试"></a>6.3 多线程和多进程测试</h3><ol><li><p><strong>多线程顺序读写测试</strong></p><ul><li><strong>目的</strong>: 评估存储设备在多线程情况下的顺序读写性能，模拟多用户并发访问的场景。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=multithread_seq --filename=/path/to/testfile --size=10G --rw=write --bs=1M --direct=1 --ioengine=libaio --numjobs=8 --runtime=180 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>bw</code> 和 <code>iops</code> 在多线程情况下可能会有所增加，但也可能因锁争用或I&#x2F;O调度影响而下降。</li><li>对比单线程和多线程结果，可以评估设备在并发负载下的扩展性。</li></ul></li></ul></li><li><p><strong>多进程随机写入测试</strong></p><ul><li><strong>目的</strong>: 测试在多个进程同时进行随机写入时的性能，适用于模拟数据库集群或并行计算环境。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=multiprocess_rand_write --filename=/path/to/testfile --size=10G --rw=randwrite --bs=4k --direct=1 --ioengine=libaio --numjobs=8 --runtime=180 --group_reporting --gtod_reduce=1</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li>多进程下的 <code>iops</code> 和 <code>lat</code> 是关键指标，注意观察是否有瓶颈产生。</li><li>例如，如果 <code>iops=45000</code> 和 <code>lat=0.15ms</code>，则表示设备在高并发写入场景下表现较为稳定。</li></ul></li></ul></li></ol><h3 id="6-4-文件系统缓存的影响"><a href="#6-4-文件系统缓存的影响" class="headerlink" title="6.4 文件系统缓存的影响"></a>6.4 文件系统缓存的影响</h3><ol><li><p><strong>开启缓存的随机写入测试</strong></p><ul><li><strong>目的</strong>: 测试文件系统缓存对写操作的影响，模拟常规写入操作。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=cached_rand_write --filename=/path/to/testfile --size=2G --rw=randwrite --bs=4k --ioengine=<span class="built_in">sync</span> --numjobs=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>iops</code> 可能会因为缓存的作用而显著提高，<code>lat</code> 也可能减少。</li><li>例如，如果 <code>iops=35000</code> 和 <code>lat=0.05ms</code>，这表明文件系统缓存对性能有积极影响。</li></ul></li></ul></li><li><p><strong>禁用缓存的随机写入测试</strong></p><ul><li><strong>目的</strong>: 禁用缓存直接写入到磁盘，评估纯粹的硬件性能。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=direct_rand_write --filename=/path/to/testfile --size=2G --rw=randwrite --bs=4k --direct=1 --ioengine=libaio --numjobs=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li>禁用缓存后，<code>iops</code> 和 <code>lat</code> 反映了设备的实际性能。</li><li>例如，<code>iops=15000</code> 和 <code>lat=0.3ms</code> 表示在无缓存情况下，设备的硬件性能。</li></ul></li></ul></li></ol><h3 id="6-5-RAID阵列性能测试"><a href="#6-5-RAID阵列性能测试" class="headerlink" title="6.5 RAID阵列性能测试"></a>6.5 RAID阵列性能测试</h3><ol><li><p><strong>顺序读取RAID性能</strong></p><ul><li><strong>目的</strong>: 评估RAID阵列的顺序读取性能，适用于高吞吐量需求的应用，如视频编辑或数据备份。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=raid_seq_read --filename=/dev/md0 --size=10G --rw=<span class="built_in">read</span> --bs=1M --direct=1 --ioengine=libaio --numjobs=1 --runtime=300 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>bw</code> 是主要关注点，反映了RAID阵列在顺序读取任务中的吞吐能力。</li><li>例如，<code>bw=800MB/s</code> 表示RAID阵列在该测试中表现良好。</li></ul></li></ul></li><li><p><strong>随机写入RAID性能</strong></p><ul><li><strong>目的</strong>: 测试RAID阵列的随机写入性能，适用于需要高I&#x2F;O吞吐的环境，如虚拟化平台。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=raid_rand_write --filename=/dev/md0 --size=5G --rw=randwrite --bs=4k --direct=1 --ioengine=libaio --numjobs=4 --runtime=300 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li>关注 <code>iops</code> 和 <code>lat</code> 指标，评估RAID在并发随机写入下的性能。</li><li>例如，如果 <code>iops=30000</code> 和 <code>lat=0.2ms</code>，则表示RAID阵列能够在随机写入场景下保持较高的性能。</li></ul></li></ul></li></ol><h2 id="7-一些Tips"><a href="#7-一些Tips" class="headerlink" title="7. 一些Tips"></a>7. 一些Tips</h2><ul><li>Q: 指定运行FIO的时间，但是提前就结束了。</li><li>A: 加上参数 <code>-time_base</code>即可</li></ul><h2 id="8-参考文献"><a href="#8-参考文献" class="headerlink" title="8. 参考文献"></a>8. 参考文献</h2><ul><li><a href="https://fio.readthedocs.io/">Fio官方文档</a></li><li><a href="https://www.redhat.com/en/resources/storage-performance-testing-best-practices">存储性能测试最佳实践</a></li><li><a href="https://www.intel.com/content/www/us/en/support/articles/000005791/memory-and-storage.html">RAID性能优化指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 `stress-ng` 进行系统压力测试</title>
      <link href="/2024/08/14/stress-ng_test/"/>
      <url>/2024/08/14/stress-ng_test/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-stress-ng-进行系统压力测试"><a href="#使用-stress-ng-进行系统压力测试" class="headerlink" title="使用 stress-ng 进行系统压力测试"></a>使用 <code>stress-ng</code> 进行系统压力测试</h1><hr><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p><code>stress-ng</code> 是一个功能强大的压力测试工具，能够对系统的 CPU、内存、I&#x2F;O、网络、磁盘等多个子系统进行深入测试。它可以帮助识别系统在极端条件下的稳定性问题，并用于评估硬件和软件的耐久性和性能。详细介绍了在 Linux 系统上安装、配置并运行 <code>stress-ng</code> 工具的过程，以进行全面的系统压力测试。</p><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h4><p>适用于需要验证系统硬件和软件稳定性的技术人员，尤其是需要测试 CPU、内存、I&#x2F;O、网络和磁盘性能的场景。</p><h4 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h4><ul><li><strong>系统管理员</strong>：确保系统已正确安装所有必需的依赖包，并具备执行测试所需的权限。</li><li><strong>操作员</strong>：按照本 SOP 正确执行 <code>stress-ng</code> 工具，确保测试顺利进行。</li></ul><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h4><ul><li>运行 Linux 操作系统的设备。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>有效的互联网连接以下载必要的软件包和工具。</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h4><h5 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h5><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装 <code>stress-ng</code> 工具</strong></p><ul><li><p><strong>在 Debian&#x2F;Ubuntu 系统上使用 <code>apt</code> 安装 <code>stress-ng</code>：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install stress-ng</span><br></pre></td></tr></table></figure></li><li><p><strong>在 RHEL&#x2F;CentOS 系统上使用 <code>yum</code> 安装 <code>stress-ng</code>：</strong></p><ul><li>首先，启用 EPEL 仓库（如果尚未启用）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure></li><li>然后安装 <code>stress-ng</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install stress-ng</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-配置与运行-stress-ng"><a href="#2-配置与运行-stress-ng" class="headerlink" title="2. 配置与运行 stress-ng"></a>2. <strong>配置与运行 <code>stress-ng</code></strong></h5><p>2.1 <strong>运行 CPU 压力测试</strong></p><ul><li>使用 <code>stress-ng</code> 工具对 CPU 进行压力测试。例如，以下命令将启动 4 个 CPU 工作线程，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --cpu 4 --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--cpu 4</code>：启动 4 个 CPU 工作线程。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.2 <strong>运行内存压力测试</strong></p><ul><li>对系统内存进行压力测试。例如，以下命令将启动 2 个内存工作线程，每个分配 256MB 内存，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --vm 2 --vm-bytes 256M --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--vm 2</code>：启动 2 个内存工作线程。</li><li><code>--vm-bytes 256M</code>：每个线程分配 256MB 内存。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.3 <strong>运行 I&#x2F;O 压力测试</strong></p><ul><li>对系统的 I&#x2F;O 操作进行压力测试。例如，以下命令将启动 4 个 I&#x2F;O 工作线程，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --io 4 --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--io 4</code>：启动 4 个 I&#x2F;O 工作线程。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.4 <strong>运行磁盘压力测试</strong></p><ul><li>对系统磁盘进行压力测试。例如，以下命令将启动 4 个磁盘工作线程，每个线程执行 10MB 的写操作，并持续运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --hdd 4 --hdd-bytes 10M --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--hdd 4</code>：启动 4 个磁盘工作线程。</li><li><code>--hdd-bytes 10M</code>：每个线程执行 10MB 的写操作。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.5 <strong>综合压力测试</strong></p><ul><li>运行包含多个子系统的综合压力测试。例如，以下命令将同时对 CPU、内存、I&#x2F;O 和磁盘进行压力测试，并持续运行 600 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --cpu 4 --vm 2 --vm-bytes 128M --io 2 --hdd 2 --hdd-bytes 5M --<span class="built_in">timeout</span> 600</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--cpu 4</code>：启动 4 个 CPU 工作线程。</li><li><code>--vm 2 --vm-bytes 128M</code>：启动 2 个内存工作线程，每个线程分配 128MB 内存。</li><li><code>--io 2</code>：启动 2 个 I&#x2F;O 工作线程。</li><li><code>--hdd 2 --hdd-bytes 5M</code>：启动 2 个磁盘工作线程，每个线程执行 5MB 的写操作。</li><li><code>--timeout 600</code>：测试持续 600 秒（10 分钟）。</li></ul></li></ul><p>2.6 <strong>生成性能报告</strong></p><ul><li>使用 <code>--metrics-brief</code> 选项生成一个简短的性能报告，显示测试的主要结果：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --cpu 4 --<span class="built_in">timeout</span> 300 --metrics-brief</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-监控与分析测试结果"><a href="#3-监控与分析测试结果" class="headerlink" title="3. 监控与分析测试结果"></a>3. <strong>监控与分析测试结果</strong></h5><p>3.1 <strong>监控测试进度</strong></p><ul><li>在测试过程中，可以在终端查看 <code>stress-ng</code> 的输出，监控测试的进展情况。</li></ul><p>3.2 <strong>分析测试结果</strong></p><ul><li><code>stress-ng</code> 工具本身可以生成详细的性能报告，您可以通过分析报告来了解系统在压力测试下的表现。</li></ul><p>3.3 <strong>保存测试日志</strong></p><ul><li>可以将测试日志保存到文件中，以便后续分析：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --cpu 4 --<span class="built_in">timeout</span> 300 --metrics-brief &gt; stress-ng-log.txt</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-优化与维护"><a href="#4-优化与维护" class="headerlink" title="4. 优化与维护"></a>4. <strong>优化与维护</strong></h5><p>4.1 <strong>定期测试</strong></p><ul><li>建议定期运行 <code>stress-ng</code> 工具，特别是在系统进行重大变更（如硬件升级或系统更新）之后，以确保系统的持续稳定性。</li></ul><p>4.2 <strong>调整参数</strong></p><ul><li>根据系统的具体需求和测试目标，调整 <code>stress-ng</code> 的参数，以便更好地检测系统潜在问题。</li></ul><h5 id="5-常见问题与故障排除"><a href="#5-常见问题与故障排除" class="headerlink" title="5. 常见问题与故障排除"></a>5. <strong>常见问题与故障排除</strong></h5><p>5.1 <strong>测试失败或系统崩溃</strong></p><ul><li>如果在测试过程中系统崩溃或测试失败，请检查系统日志以确定故障原因。可能需要降低测试负荷，或排查硬件问题。</li></ul><p>5.2 <strong>系统资源不足</strong></p><ul><li>如果在测试过程中出现内存或 CPU 资源不足的错误，考虑减少分配给测试的资源量，或调整系统配置。</li></ul><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h4><ul><li><a href="https://github.com/ColinIanKing/stress-ng">stress-ng GitHub Repository</a></li><li><a href="https://linux.die.net/man/1/stress-ng">Linux Performance Tools</a></li><li><a href="https://linuxconfig.org/bash-scripting-tutorial-for-beginners">Bash Scripting Basics</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> stress-ng </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 `stress` 进行系统压力测试</title>
      <link href="/2024/08/14/stress_test/"/>
      <url>/2024/08/14/stress_test/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-stress-进行系统压力测试"><a href="#使用-stress-进行系统压力测试" class="headerlink" title="使用 stress 进行系统压力测试"></a>使用 <code>stress</code> 进行系统压力测试</h1><hr><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p><code>stress</code> 是一个简单但功能强大的工具，用于对系统的 CPU、内存、I&#x2F;O 和磁盘进行压力测试。通过施加高负荷，它可以帮助识别系统在极端条件下的稳定性问题。详细介绍了在 Linux 系统上安装、配置并运行 <code>stress</code> 工具的过程，以进行全面的系统压力测试。</p><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h4><p>适用于需要验证系统硬件和软件稳定性的技术人员，尤其是在测试 CPU、内存、I&#x2F;O 和磁盘性能时使用。</p><h4 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h4><ul><li><strong>系统管理员</strong>：确保系统已正确安装所有必需的依赖包，并具备执行测试所需的权限。</li><li><strong>操作员</strong>：按照本 SOP 正确执行 <code>stress</code> 工具，确保测试顺利进行。</li></ul><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h4><ul><li>运行 Linux 操作系统的设备。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>有效的互联网连接以下载必要的软件包和工具。</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h4><h5 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h5><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装 Stress 工具</strong></p><ul><li><p><strong>在 Debian&#x2F;Ubuntu 系统上使用 <code>apt</code> 安装 <code>stress</code>：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install stress</span><br></pre></td></tr></table></figure></li><li><p><strong>在 RHEL&#x2F;CentOS 系统上使用 <code>yum</code> 安装 <code>stress</code>：</strong></p><ul><li>首先，启用 EPEL 仓库（如果尚未启用）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure></li><li>然后安装 <code>stress</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install stress</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-配置与运行-stress"><a href="#2-配置与运行-stress" class="headerlink" title="2. 配置与运行 stress"></a>2. <strong>配置与运行 <code>stress</code></strong></h5><p>2.1 <strong>运行 CPU 压力测试</strong></p><ul><li>使用 <code>stress</code> 工具对 CPU 进行压力测试。例如，以下命令将启动 4 个 CPU 工作线程，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --cpu 4 --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--cpu 4</code>：启动 4 个 CPU 工作线程。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.2 <strong>运行内存压力测试</strong></p><ul><li>对系统内存进行压力测试。例如，以下命令将启动 2 个内存工作线程，每个分配 256MB 内存，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --vm 2 --vm-bytes 256M --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--vm 2</code>：启动 2 个内存工作线程。</li><li><code>--vm-bytes 256M</code>：每个线程分配 256MB 内存。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.3 <strong>运行 I&#x2F;O 压力测试</strong></p><ul><li>对系统的 I&#x2F;O 操作进行压力测试。例如，以下命令将启动 4 个 I&#x2F;O 工作线程，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --io 4 --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--io 4</code>：启动 4 个 I&#x2F;O 工作线程。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.4 <strong>运行磁盘压力测试</strong></p><ul><li>对系统磁盘进行压力测试。例如，以下命令将启动 4 个磁盘工作线程，每个线程执行 10MB 的写操作，并持续运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --hdd 4 --hdd-bytes 10M --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--hdd 4</code>：启动 4 个磁盘工作线程。</li><li><code>--hdd-bytes 10M</code>：每个线程执行 10MB 的写操作。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><h5 id="3-监控与分析测试结果"><a href="#3-监控与分析测试结果" class="headerlink" title="3. 监控与分析测试结果"></a>3. <strong>监控与分析测试结果</strong></h5><p>3.1 <strong>监控测试进度</strong></p><ul><li>在测试过程中，可以在终端查看 <code>stress</code> 输出，监控测试的进展情况。</li></ul><p>3.2 <strong>分析测试结果</strong></p><ul><li><code>stress</code> 工具本身不会生成详细的测试报告，但可以通过系统日志和资源监控工具（如 <code>htop</code> 或 <code>dstat</code>）来分析系统在压力测试下的表现。</li></ul><h5 id="4-优化与维护"><a href="#4-优化与维护" class="headerlink" title="4. 优化与维护"></a>4. <strong>优化与维护</strong></h5><p>4.1 <strong>定期测试</strong></p><ul><li>建议定期运行 <code>stress</code> 工具，特别是在系统进行重大变更（如硬件升级或系统更新）之后，以确保系统的持续稳定性。</li></ul><p>4.2 <strong>调整参数</strong></p><ul><li>根据系统的具体需求和测试目标，调整 <code>stress</code> 的参数，以便更好地检测系统潜在问题。</li></ul><h5 id="5-常见问题与故障排除"><a href="#5-常见问题与故障排除" class="headerlink" title="5. 常见问题与故障排除"></a>5. <strong>常见问题与故障排除</strong></h5><p>5.1 <strong>测试失败或系统崩溃</strong></p><ul><li>如果在测试过程中系统崩溃或测试失败，请检查系统日志以确定故障原因。可能需要降低测试负荷，或排查硬件问题。</li></ul><p>5.2 <strong>系统资源不足</strong></p><ul><li>如果在测试过程中出现内存或 CPU 资源不足的错误，考虑减少分配给测试的资源量，或调整系统配置。</li></ul><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h4><ul><li><a href="https://github.com/stress-ng/stress-ng">Stress GitHub Repository</a></li><li><a href="https://linux.die.net/man/1/stress">Linux Performance Tools</a></li><li><a href="https://linuxconfig.org/bash-scripting-tutorial-for-beginners">Bash Scripting Basics</a></li></ul><hr><p>本 SOP 提供了使用 <code>stress</code> 工具进行系统压力测试的详细步骤，旨在帮助用户识别和解决潜在的系统稳定性问题。通过这些测试，您可以确保系统在高负荷下的性能表现，并及时采取措施修复可能的故障。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> stress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPv4 和 IPv6 路由管理</title>
      <link href="/2024/08/07/IPv4_and_IPv6_Routing_Tutorial/"/>
      <url>/2024/08/07/IPv4_and_IPv6_Routing_Tutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="IPv4-和-IPv6-路由管理"><a href="#IPv4-和-IPv6-路由管理" class="headerlink" title="IPv4 和 IPv6 路由管理"></a>IPv4 和 IPv6 路由管理</h1><hr><p>Linux 系统中 IPv4 和 IPv6 路由的基本操作，包括查看、添加和删除路由。</p><h2 id="IPv4-路由"><a href="#IPv4-路由" class="headerlink" title="IPv4 路由"></a>IPv4 路由</h2><h3 id="1-查看-IPv4-路由表"><a href="#1-查看-IPv4-路由表" class="headerlink" title="1. 查看 IPv4 路由表"></a>1. 查看 IPv4 路由表</h3><p>使用下面的命令来查看当前的 IPv4 路由表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route</span><br></pre></td></tr></table></figure><h3 id="2-添加-IPv4-路由"><a href="#2-添加-IPv4-路由" class="headerlink" title="2. 添加 IPv4 路由"></a>2. 添加 IPv4 路由</h3><p>根据网络配置需求，可以使用以下命令添加路由：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route add [目的网络/掩码] via [网关地址] dev [网卡设备名]</span><br></pre></td></tr></table></figure><p>例如，如果想要所有发往 <code>192.168.1.0/24</code> 网络的数据包都通过网关 <code>192.168.0.1</code> 和网卡 <code>eth0</code> 发送，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route add 192.168.1.0/24 via 192.168.0.1 dev eth0</span><br></pre></td></tr></table></figure><h3 id="3-删除-IPv4-路由"><a href="#3-删除-IPv4-路由" class="headerlink" title="3. 删除 IPv4 路由"></a>3. 删除 IPv4 路由</h3><p>从路由表中删除一条路由，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route del [目的网络/掩码]</span><br></pre></td></tr></table></figure><p>例如，删除之前添加的路由：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route del 192.168.1.0/24</span><br></pre></td></tr></table></figure><h2 id="IPv6-路由"><a href="#IPv6-路由" class="headerlink" title="IPv6 路由"></a>IPv6 路由</h2><h3 id="1-查看-IPv6-路由表"><a href="#1-查看-IPv6-路由表" class="headerlink" title="1. 查看 IPv6 路由表"></a>1. 查看 IPv6 路由表</h3><p>使用下面的命令来查看当前的 IPv6 路由表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip -6 route</span><br></pre></td></tr></table></figure><h3 id="2-添加-IPv6-路由"><a href="#2-添加-IPv6-路由" class="headerlink" title="2. 添加 IPv6 路由"></a>2. 添加 IPv6 路由</h3><p>根据网络配置需求，可以使用以下命令添加路由：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip -6 route add [目的地址/前缀] via [网关地址] dev [网卡设备名]</span><br></pre></td></tr></table></figure><p>例如，如果想要所有发往 <code>2001:db8::/32</code> 网络的数据包都通过网关 <code>fe80::1</code> 和网卡 <code>eth0</code> 发送，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip -6 route add 2001:db8::/32 via fe80::1 dev eth0</span><br></pre></td></tr></table></figure><h3 id="3-删除-IPv6-路由"><a href="#3-删除-IPv6-路由" class="headerlink" title="3. 删除 IPv6 路由"></a>3. 删除 IPv6 路由</h3><p>从路由表中删除一条路由，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip -6 route del [目的地址/前缀]</span><br></pre></td></tr></table></figure><p>例如，删除之前添加的路由：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip -6 route del 2001:db8::/32</span><br></pre></td></tr></table></figure><h2 id="持久化路由设置"><a href="#持久化路由设置" class="headerlink" title="持久化路由设置"></a>持久化路由设置</h2><p>为了使路由设置在系统重启后依然生效，可以将命令添加到启动脚本中，或者在配置文件中设置。这具体依赖于使用的 Linux 发行版。</p><h2 id="调试和故障排查"><a href="#调试和故障排查" class="headerlink" title="调试和故障排查"></a>调试和故障排查</h2><p>使用以下命令可以帮助调试和确认路由设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip route show</span><br><span class="line">ip -6 route show</span><br></pre></td></tr></table></figure><p>或者，使用 <code>ping</code> 或 <code>ping6</code> 测试网络连通性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping [IPv4地址]</span><br><span class="line">ping6 [IPv6地址]</span><br></pre></td></tr></table></figure><p>确保有适当的权限执行这些命令，特别是使用 <code>sudo</code> 来获取必要的管理员权限。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带宽和存储单位转换</title>
      <link href="/2024/08/07/bandwidth_storage_convert/"/>
      <url>/2024/08/07/bandwidth_storage_convert/</url>
      
        <content type="html"><![CDATA[<h1 id="带宽和存储单位转换"><a href="#带宽和存储单位转换" class="headerlink" title="带宽和存储单位转换"></a>带宽和存储单位转换</h1><h2 id="带宽单位转换（基于十进制）"><a href="#带宽单位转换（基于十进制）" class="headerlink" title="带宽单位转换（基于十进制）"></a>带宽单位转换（基于十进制）</h2><ol><li><strong>1 字节 (B) &#x3D; 8 比特 (b)</strong></li><li><strong>1 千比特 (Kb) &#x3D; 1000 比特 (b)</strong></li><li><strong>1 兆比特 (Mb) &#x3D; 1000 千比特 (Kb)</strong></li><li><strong>1 吉比特 (Gb) &#x3D; 1000 兆比特 (Mb)</strong></li><li><strong>1 太比特 (Tb) &#x3D; 1000 吉比特 (Gb)</strong></li></ol><h2 id="存储单位转换（基于二进制）"><a href="#存储单位转换（基于二进制）" class="headerlink" title="存储单位转换（基于二进制）"></a>存储单位转换（基于二进制）</h2><ol><li><strong>1 千字节 (KiB) &#x3D; 1024 字节 (B)</strong></li><li><strong>1 兆字节 (MiB) &#x3D; 1024 千字节 (KiB)</strong></li><li><strong>1 吉字节 (GiB) &#x3D; 1024 兆字节 (MiB)</strong></li><li><strong>1 太字节 (TiB) &#x3D; 1024 吉字节 (GiB)</strong></li></ol><h2 id="带宽和存储的相互转换"><a href="#带宽和存储的相互转换" class="headerlink" title="带宽和存储的相互转换"></a>带宽和存储的相互转换</h2><h3 id="示例1：带宽转存储"><a href="#示例1：带宽转存储" class="headerlink" title="示例1：带宽转存储"></a>示例1：带宽转存储</h3><p>假设有一个文件大小为100 MiB，下载速度为20 Mbps，需要多长时间下载完这个文件？</p><ol><li><p><strong>转换文件大小为比特</strong>：</p><ul><li>100 MiB &#x3D; 100 × 1024 × 1024 × 8 &#x3D; 838,860,800 比特 (b)</li></ul></li><li><p><strong>计算下载时间</strong>：</p><ul><li>时间 (秒) &#x3D; 文件大小 (比特) &#x2F; 带宽 (比特每秒)</li><li>时间 &#x3D; 838,860,800 b &#x2F; 20,000,000 bps &#x3D; 41.94 秒</li></ul></li></ol><h3 id="示例2：存储转带宽"><a href="#示例2：存储转带宽" class="headerlink" title="示例2：存储转带宽"></a>示例2：存储转带宽</h3><p>假设有一个网络带宽为50 Mbps，每秒能够传输多少 GiB 的数据？</p><ol><li><p><strong>转换带宽为字节每秒</strong>：</p><ul><li>50 Mbps &#x3D; 50 × 1000 × 1000 &#x2F; 8 &#x3D; 6,250,000 字节每秒 (Bps)</li></ul></li><li><p><strong>转换为GiB每秒</strong>：</p><ul><li>6,250,000 Bps &#x3D; 6,250,000 &#x2F; 1024 &#x2F; 1024 &#x2F; 1024 &#x3D; 0.0058 GiB 每秒</li></ul></li></ol><p>通过以上示例可以看到，带宽和存储单位可以通过字节和比特之间的转换进行相互转换。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numactl 操作流程</title>
      <link href="/2024/08/07/numactl_sop/"/>
      <url>/2024/08/07/numactl_sop/</url>
      
        <content type="html"><![CDATA[<h1 id="numactl-操作流程"><a href="#numactl-操作流程" class="headerlink" title="numactl 操作流程"></a><code>numactl</code> 操作流程</h1><hr><h2 id="1-检查NUMA节点信息"><a href="#1-检查NUMA节点信息" class="headerlink" title="1. 检查NUMA节点信息"></a>1. 检查NUMA节点信息</h2><p>在进行任何绑定操作之前，先检查系统的NUMA节点信息，以了解可用的CPU和内存节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --hardware</span><br></pre></td></tr></table></figure><p>记录输出信息，确保了解系统中所有NUMA节点及其CPU核心分布。</p><h2 id="2-确定需要绑定的CPU核心和NUMA节点"><a href="#2-确定需要绑定的CPU核心和NUMA节点" class="headerlink" title="2. 确定需要绑定的CPU核心和NUMA节点"></a>2. 确定需要绑定的CPU核心和NUMA节点</h2><p>根据应用程序的需求和系统的NUMA节点分布，确定需要绑定的CPU核心和内存节点。例如，假设需要绑定到CPU 2和3，并使用NUMA节点0上的内存。</p><h2 id="3-绑定CPU核心"><a href="#3-绑定CPU核心" class="headerlink" title="3. 绑定CPU核心"></a>3. 绑定CPU核心</h2><p>将应用程序绑定到特定的CPU核心，以提高CPU利用率和性能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --physcpubind=2,3 your_command</span><br></pre></td></tr></table></figure><p>例如，运行名为 <code>my_program</code> 的应用程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --physcpubind=2,3 ./my_program</span><br></pre></td></tr></table></figure><h2 id="4-绑定NUMA节点内存"><a href="#4-绑定NUMA节点内存" class="headerlink" title="4. 绑定NUMA节点内存"></a>4. 绑定NUMA节点内存</h2><p>如果还需要绑定到特定的NUMA节点内存，使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --membind=0 your_command</span><br></pre></td></tr></table></figure><p>例如，运行名为 <code>my_program</code> 的应用程序，并绑定到NUMA节点0的内存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --physcpubind=2,3 --membind=0 ./my_program</span><br></pre></td></tr></table></figure><h2 id="5-验证绑定结果"><a href="#5-验证绑定结果" class="headerlink" title="5. 验证绑定结果"></a>5. 验证绑定结果</h2><p>运行以下命令来检查进程的CPU和内存绑定情况，确保绑定成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --show</span><br></pre></td></tr></table></figure><h2 id="6-测试和监控"><a href="#6-测试和监控" class="headerlink" title="6. 测试和监控"></a>6. 测试和监控</h2><p>运行应用程序后，监控其性能和资源使用情况，确保绑定操作达到了预期效果。可以使用以下工具进行监控：</p><ul><li><code>top</code></li><li><code>htop</code></li><li><code>numastat</code></li><li><code>perf</code></li></ul><h1 id="示例SOP"><a href="#示例SOP" class="headerlink" title="示例SOP"></a>示例SOP</h1><h2 id="步骤1：检查NUMA节点信息"><a href="#步骤1：检查NUMA节点信息" class="headerlink" title="步骤1：检查NUMA节点信息"></a>步骤1：检查NUMA节点信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --hardware</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">available: 2 nodes (0-1)</span><br><span class="line">node 0 cpus: 0 1 2 3</span><br><span class="line">node 0 size: 32632 MB</span><br><span class="line">node 0 free: 12345 MB</span><br><span class="line">node 1 cpus: 4 5 6 7</span><br><span class="line">node 1 size: 32768 MB</span><br><span class="line">node 1 free: 23456 MB</span><br></pre></td></tr></table></figure><h2 id="步骤2：确定绑定的CPU核心和NUMA节点"><a href="#步骤2：确定绑定的CPU核心和NUMA节点" class="headerlink" title="步骤2：确定绑定的CPU核心和NUMA节点"></a>步骤2：确定绑定的CPU核心和NUMA节点</h2><p>假设需要绑定到CPU 2和3，并使用NUMA节点0上的内存。</p><h2 id="步骤3：绑定CPU核心"><a href="#步骤3：绑定CPU核心" class="headerlink" title="步骤3：绑定CPU核心"></a>步骤3：绑定CPU核心</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --physcpubind=2,3 ./my_program</span><br></pre></td></tr></table></figure><h2 id="步骤4：绑定NUMA节点内存"><a href="#步骤4：绑定NUMA节点内存" class="headerlink" title="步骤4：绑定NUMA节点内存"></a>步骤4：绑定NUMA节点内存</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --physcpubind=2,3 --membind=0 ./my_program</span><br></pre></td></tr></table></figure><h2 id="步骤5：验证绑定结果"><a href="#步骤5：验证绑定结果" class="headerlink" title="步骤5：验证绑定结果"></a>步骤5：验证绑定结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --show</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">policy: default</span><br><span class="line">physcpubind: 2 3 </span><br><span class="line">cpubind: 0 </span><br><span class="line">membind: 0 </span><br></pre></td></tr></table></figure><h2 id="步骤6：测试和监控"><a href="#步骤6：测试和监控" class="headerlink" title="步骤6：测试和监控"></a>步骤6：测试和监控</h2><p>使用 <code>htop</code> 或 <code>numastat</code> 等工具监控应用程序的性能和资源使用情况。</p><p>通过上述步骤，可以确保应用程序在NUMA系统上得到优化运行。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Numactl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在 Linux 系统中进入 S0、S1、S2、S3、S4 和 S5 模式</title>
      <link href="/2024/08/06/linux_power_state_mode/"/>
      <url>/2024/08/06/linux_power_state_mode/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在-Linux-系统中进入-S0、S1、S2、S3、S4-和-S5-模式"><a href="#如何在-Linux-系统中进入-S0、S1、S2、S3、S4-和-S5-模式" class="headerlink" title="如何在 Linux 系统中进入 S0、S1、S2、S3、S4 和 S5 模式"></a>如何在 Linux 系统中进入 S0、S1、S2、S3、S4 和 S5 模式</h1><hr><h2 id="检查系统支持的电源模式"><a href="#检查系统支持的电源模式" class="headerlink" title="检查系统支持的电源模式"></a>检查系统支持的电源模式</h2><p>在进入这些模式之前，可以使用以下命令来检查系统支持哪些电源状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/power/state</span><br></pre></td></tr></table></figure><p>该命令的输出可能包括：</p><ul><li><code>freeze</code>：冻结当前任务，不关闭任何设备。</li><li><code>standby</code>：进入 S1 模式。</li><li><code>mem</code>：进入 S3 模式。</li><li><code>disk</code>：进入 S4 模式，即休眠，将内存内容保存到磁盘。</li></ul><h2 id="各电源模式简介"><a href="#各电源模式简介" class="headerlink" title="各电源模式简介"></a>各电源模式简介</h2><ul><li>S0（工作状态）：系统处于完全开机状态，所有部件都在运行。</li><li>S1（待机）：CPU 停止执行指令，但内存和其他关键部件保持供电。</li><li>S2（待机）：CPU 和系统缓存停止供电，但内存保持供电。</li><li>S3（挂起到内存）：系统状态保存到内存中，除内存外的所有部件都断电。</li><li>S4（休眠）：系统状态保存到硬盘，所有部件断电。系统恢复时从硬盘读取状态。</li><li>S5（软关机）：系统完全关机，但电源仍然供电，可以通过电源按钮启动。</li></ul><h2 id="进入各电源模式的命令"><a href="#进入各电源模式的命令" class="headerlink" title="进入各电源模式的命令"></a>进入各电源模式的命令</h2><ul><li><p>S0 模式（工作状态）<br>无需特殊命令，系统开机时即处于 S0 模式。</p></li><li><p>S1 模式（Standby）<br>使用 echo 命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> standby | sudo <span class="built_in">tee</span> /sys/power/state</span><br></pre></td></tr></table></figure><ul><li>S2 模式（待机）<br>请注意，S2 模式在很多系统上并不常用或不被支持。如果系统支持，可以尝试：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> standby | sudo <span class="built_in">tee</span> /sys/power/state</span><br></pre></td></tr></table></figure><ul><li>S3 模式（Suspend-to-RAM）</li></ul><p><strong>方法一：使用 systemctl 命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">suspend</span></span><br></pre></td></tr></table></figure><p><strong>方法二：使用 echo 命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> mem | sudo <span class="built_in">tee</span> /sys/power/state</span><br></pre></td></tr></table></figure><ul><li>S4 模式（休眠）<br>使用 systemctl 命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl hibernate</span><br></pre></td></tr></table></figure><p>或者使用 echo 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> disk | sudo <span class="built_in">tee</span> /sys/power/state</span><br></pre></td></tr></table></figure><ul><li>S5 模式（软关机）<br>使用 systemctl 命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl poweroff</span><br></pre></td></tr></table></figure><h2 id="示例操作"><a href="#示例操作" class="headerlink" title="示例操作"></a>示例操作</h2><p><strong>1. 检查系统支持的电源模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/power/state</span><br><span class="line">freeze standby mem disk</span><br></pre></td></tr></table></figure><p><strong>2. 进入 S1 模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> standby | sudo <span class="built_in">tee</span> /sys/power/state</span><br></pre></td></tr></table></figure><p><strong>3. 进入 S3 模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">suspend</span></span><br></pre></td></tr></table></figure><p><strong>4. 进入 S4 模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl hibernate</span><br></pre></td></tr></table></figure><p><strong>5. 进入 S5 模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl poweroff</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>硬件支持：确保你的硬件支持相应的电源模式。</p><p>数据保存：进入这些模式前保存所有未保存的工作，以避免数据丢失。</p><p>驱动支持：有些系统和设备驱动可能对某些电源模式支持不完善，可能会导致恢复时出现问题。 </p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 连接 USB 串口教程</title>
      <link href="/2024/08/05/Linux_USB_Serial_Tutorial/"/>
      <url>/2024/08/05/Linux_USB_Serial_Tutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-连接-USB-串口教程"><a href="#Linux-连接-USB-串口教程" class="headerlink" title="Linux 连接 USB 串口教程"></a>Linux 连接 USB 串口教程</h1><hr><p>在Linux系统中，连接USB串口设备通常需要以下几个步骤：</p><h2 id="1-确认系统识别到USB串口设备"><a href="#1-确认系统识别到USB串口设备" class="headerlink" title="1. 确认系统识别到USB串口设备"></a>1. 确认系统识别到USB串口设备</h2><p>插入USB串口设备后，可以使用 <code>dmesg</code> 命令来查看系统是否识别到该设备。输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep ttyUSB</span><br></pre></td></tr></table></figure><p>应该看到类似以下的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[12345.678901] usb 1-1: cp210x converter now attached to ttyUSB0</span><br></pre></td></tr></table></figure><p>这表示系统已将USB串口设备识别为 <code>/dev/ttyUSB0</code>。</p><h2 id="2-安装必要的软件"><a href="#2-安装必要的软件" class="headerlink" title="2. 安装必要的软件"></a>2. 安装必要的软件</h2><p>使用USB串口设备通常需要安装 <code>screen</code> 或 <code>minicom</code> 等终端仿真软件。你可以使用以下命令来安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install screen</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install minicom</span><br></pre></td></tr></table></figure><h2 id="3-连接到USB串口设备"><a href="#3-连接到USB串口设备" class="headerlink" title="3. 连接到USB串口设备"></a>3. 连接到USB串口设备</h2><h3 id="使用-screen"><a href="#使用-screen" class="headerlink" title="使用 screen"></a>使用 screen</h3><p>可以使用 <code>screen</code> 命令连接到USB串口设备。例如，如果设备被识别为 <code>/dev/ttyUSB0</code>，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen /dev/ttyUSB0 115200</span><br></pre></td></tr></table></figure><p>这里的 <code>115200</code> 是波特率，根据你的设备配置进行调整。</p><h3 id="使用-minicom"><a href="#使用-minicom" class="headerlink" title="使用 minicom"></a>使用 minicom</h3><p>首先，配置 <code>minicom</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo minicom -s</span><br></pre></td></tr></table></figure><p>在配置界面中，选择“串口设置”，然后设置串口设备为 <code>/dev/ttyUSB0</code>，并设置相应的波特率。</p><p>配置完成后，选择“保存并退出”。然后可以使用以下命令连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minicom</span><br></pre></td></tr></table></figure><h2 id="4-退出连接"><a href="#4-退出连接" class="headerlink" title="4. 退出连接"></a>4. 退出连接</h2><h3 id="使用-screen-1"><a href="#使用-screen-1" class="headerlink" title="使用 screen"></a>使用 screen</h3><p>要退出 <code>screen</code> 会话，按 <code>Ctrl-a</code> 然后按 <code>k</code>，再按 <code>y</code> 确认。</p><h3 id="使用-minicom-1"><a href="#使用-minicom-1" class="headerlink" title="使用 minicom"></a>使用 minicom</h3><p>要退出 <code>minicom</code>，按 <code>Ctrl-a</code> 然后按 <code>q</code>，再选择“是”确认退出。</p><hr><p>以上就是在Linux系统中连接USB串口设备的基本步骤。</p><h2 id="DB9-串口线序"><a href="#DB9-串口线序" class="headerlink" title="DB9 串口线序"></a>DB9 串口线序</h2><h3 id="DB9公头（Male）针脚排列"><a href="#DB9公头（Male）针脚排列" class="headerlink" title="DB9公头（Male）针脚排列"></a>DB9公头（Male）针脚排列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5  4  3  2  1</span><br><span class="line"> ●  ●  ●  ●  ●</span><br><span class="line">  9  8  7  6</span><br><span class="line"> ●  ●  ●  ● </span><br></pre></td></tr></table></figure><h3 id="DB9母头（Female）针脚排列"><a href="#DB9母头（Female）针脚排列" class="headerlink" title="DB9母头（Female）针脚排列"></a>DB9母头（Female）针脚排列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1  2  3  4  5</span><br><span class="line"> ●  ●  ●  ●  ●</span><br><span class="line">  6  7  8  9</span><br><span class="line"> ●  ●  ●  ● </span><br></pre></td></tr></table></figure><h3 id="针脚定义"><a href="#针脚定义" class="headerlink" title="针脚定义"></a>针脚定义</h3><table><thead><tr><th>针脚编号</th><th>信号名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>DCD (Data Carrier Detect)</td><td>数据载波检测</td></tr><tr><td>2</td><td>RXD (Receive Data)</td><td>接收数据</td></tr><tr><td>3</td><td>TXD (Transmit Data)</td><td>发送数据</td></tr><tr><td>4</td><td>DTR (Data Terminal Ready)</td><td>数据终端准备好</td></tr><tr><td>5</td><td>GND (Ground)</td><td>信号地</td></tr><tr><td>6</td><td>DSR (Data Set Ready)</td><td>数据设置准备好</td></tr><tr><td>7</td><td>RTS (Request to Send)</td><td>请求发送</td></tr><tr><td>8</td><td>CTS (Clear to Send)</td><td>清除发送</td></tr><tr><td>9</td><td>RI (Ring Indicator)</td><td>振铃指示</td></tr></tbody></table><h3 id="常用连接"><a href="#常用连接" class="headerlink" title="常用连接"></a>常用连接</h3><h4 id="1-直连线（也称为直通线）"><a href="#1-直连线（也称为直通线）" class="headerlink" title="1. 直连线（也称为直通线）"></a>1. 直连线（也称为直通线）</h4><ul><li>这种连接方式通常用于PC与调制解调器（Modem）之间的连接。</li><li>直连线的针脚对应关系如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DB9公头 (Male)       DB9母头 (Female)</span><br><span class="line">2 (RXD)  &lt;--------&gt;  2 (RXD)</span><br><span class="line">3 (TXD)  &lt;--------&gt;  3 (TXD)</span><br><span class="line">5 (GND)  &lt;--------&gt;  5 (GND)</span><br><span class="line">7 (RTS)  &lt;--------&gt;  7 (RTS)</span><br><span class="line">8 (CTS)  &lt;--------&gt;  8 (CTS)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-交叉线（也称为null-modem线）"><a href="#2-交叉线（也称为null-modem线）" class="headerlink" title="2. 交叉线（也称为null modem线）"></a>2. 交叉线（也称为null modem线）</h4><ul><li>这种连接方式用于PC与PC之间，或PC与串口设备之间的直接通信。</li><li>交叉线的针脚对应关系如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DB9公头 (Male)       DB9公头 (Male)</span><br><span class="line">2 (RXD)  &lt;--------&gt;  3 (TXD)</span><br><span class="line">3 (TXD)  &lt;--------&gt;  2 (RXD)</span><br><span class="line">5 (GND)  &lt;--------&gt;  5 (GND)</span><br><span class="line">7 (RTS)  &lt;--------&gt;  8 (CTS)</span><br><span class="line">8 (CTS)  &lt;--------&gt;  7 (RTS)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Serial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RHEL9 网络配置</title>
      <link href="/2024/07/29/RHEL9_network_config/"/>
      <url>/2024/07/29/RHEL9_network_config/</url>
      
        <content type="html"><![CDATA[<h1 id="RHEL9-网络配置"><a href="#RHEL9-网络配置" class="headerlink" title="RHEL9 网络配置"></a>RHEL9 网络配置</h1><hr><h2 id="开关interface和profile"><a href="#开关interface和profile" class="headerlink" title="开关interface和profile"></a>开关interface和profile</h2><ol><li><p><strong>获取网络状态</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection</span><br><span class="line">NAME           UUID                                  TYPE      DEVICE</span><br><span class="line">Profile 2      21906cd8-c04d-45fd-9b7f-e6e85c43f891  ethernet  enP21p1s0f1np1</span><br><span class="line">enP21s17f1np1  f9ed821f-f3db-46ea-90fd-13dd74dc5587  ethernet  --</span><br></pre></td></tr></table></figure></li><li><p><strong>ifdown profile</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ifdown &quot;Profile 2&quot;</span><br><span class="line">Connection &#x27;Profile 2&#x27; successfully deactivated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/7)</span><br></pre></td></tr></table></figure></li><li><p><strong>link down interface</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ip link set enP21p1s0f1np1 down</span><br></pre></td></tr></table></figure></li><li><p><strong>link up interface</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ip link set enP21p1s0f1np1 up</span><br></pre></td></tr></table></figure></li><li><p><strong>ifup interface</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ifup &quot;Profile 2&quot;</span><br><span class="line">Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/8)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>/etc/fstab 文件配置教程</title>
      <link href="/2024/07/28/fstab_config/"/>
      <url>/2024/07/28/fstab_config/</url>
      
        <content type="html"><![CDATA[<h1 id="etc-fstab-文件配置教程"><a href="#etc-fstab-文件配置教程" class="headerlink" title="/etc/fstab 文件配置教程"></a><code>/etc/fstab</code> 文件配置教程</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>/etc/fstab</code> 文件用于定义系统在启动时如何自动挂载各种文件系统。这个文件在 Linux 系统中非常重要，它决定了系统启动时哪些设备将被挂载到哪些挂载点。</p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p><code>/etc/fstab</code> 文件的每一行代表一个文件系统的挂载配置，每行包含六个字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;文件系统&gt; &lt;挂载点&gt; &lt;类型&gt; &lt;选项&gt; &lt;转储&gt; &lt;自检&gt;</span><br></pre></td></tr></table></figure><h3 id="字段解释"><a href="#字段解释" class="headerlink" title="字段解释"></a>字段解释</h3><ol><li><p><strong>文件系统（File System）：</strong></p><ul><li>设备文件或分区。例如：<code>/dev/sda1</code>，<code>UUID=xxxx-xxxx</code>，<code>LABEL=home</code>。</li></ul></li><li><p><strong>挂载点（Mount Point）：</strong></p><ul><li>文件系统挂载到的目录。例如：<code>/</code>，<code>/home</code>，<code>/mnt/backup</code>。</li></ul></li><li><p><strong>文件系统类型（Filesystem Type）：</strong></p><ul><li>指定文件系统类型。例如：<code>ext4</code>，<code>ntfs</code>，<code>vfat</code>。</li></ul></li><li><p><strong>挂载选项（Mount Options）：</strong></p><ul><li>挂载时的选项，多个选项使用逗号分隔。例如：<code>defaults</code>，<code>ro</code>（只读），<code>noexec</code>（不可执行）。</li></ul></li><li><p><strong>转储频率（Dump Frequency）：</strong></p><ul><li>数字，表示是否需要备份。通常为 <code>0</code>（不备份）或 <code>1</code>（备份）。</li></ul></li><li><p><strong>自检顺序（Fsck Order）：</strong></p><ul><li>数字，表示启动时文件系统检查的顺序。根文件系统通常为 <code>1</code>，其他为 <code>2</code>，不检查则为 <code>0</code>。</li></ul></li></ol><h2 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h2><p>以下是一个典型的 <code>/etc/fstab</code> 文件示例：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># &lt;文件系统&gt;  &lt;挂载点&gt;    &lt;类型&gt; &lt;选项&gt;     &lt;转储&gt; &lt;自检&gt;</span></span><br><span class="line">/dev/sda1     /           ext4   defaults    1      1</span><br><span class="line">/dev/sda2     /home       ext4   defaults    1      2</span><br><span class="line">/dev/sdb1     /mnt/backup ntfs   defaults    0      0</span><br><span class="line">UUID=xxxx-xxxx /mnt/data  ext4   defaults    0      2</span><br><span class="line">LABEL=usbdrv  /mnt/usb    vfat   noauto,user 0      0</span><br></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li><code>/dev/sda1</code> 挂载到根目录 <code>/</code>，文件系统类型为 <code>ext4</code>，使用默认选项，转储频率为 <code>1</code>，自检顺序为 <code>1</code>。</li><li><code>/dev/sda2</code> 挂载到 <code>/home</code>，文件系统类型为 <code>ext4</code>，使用默认选项，转储频率为 <code>1</code>，自检顺序为 <code>2</code>。</li><li><code>/dev/sdb1</code> 挂载到 <code>/mnt/backup</code>，文件系统类型为 <code>ntfs</code>，使用默认选项，不进行转储和自检。</li><li>使用 <code>UUID=xxxx-xxxx</code> 指定的分区挂载到 <code>/mnt/data</code>，文件系统类型为 <code>ext4</code>，使用默认选项，不进行转储，自检顺序为 <code>2</code>。</li><li>使用 <code>LABEL=usbdrv</code> 指定的设备挂载到 <code>/mnt/usb</code>，文件系统类型为 <code>vfat</code>，不自动挂载，允许用户挂载，不进行转储和自检。</li></ul><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="步骤-1：备份现有的-etc-fstab"><a href="#步骤-1：备份现有的-etc-fstab" class="headerlink" title="步骤 1：备份现有的 /etc/fstab"></a>步骤 1：备份现有的 <code>/etc/fstab</code></h3><p>在修改之前，备份现有的 <code>/etc/fstab</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/fstab /etc/fstab.bak</span><br></pre></td></tr></table></figure><h3 id="步骤-2：编辑-etc-fstab"><a href="#步骤-2：编辑-etc-fstab" class="headerlink" title="步骤 2：编辑 /etc/fstab"></a>步骤 2：编辑 <code>/etc/fstab</code></h3><p>使用文本编辑器打开 <code>/etc/fstab</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/fstab</span><br></pre></td></tr></table></figure><h3 id="步骤-3：添加新的挂载条目"><a href="#步骤-3：添加新的挂载条目" class="headerlink" title="步骤 3：添加新的挂载条目"></a>步骤 3：添加新的挂载条目</h3><p>根据需要添加新的挂载条目。例如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=xxxx-xxxx /mnt/data  ext4   defaults    0      2</span><br></pre></td></tr></table></figure><h3 id="步骤-4：保存并退出"><a href="#步骤-4：保存并退出" class="headerlink" title="步骤 4：保存并退出"></a>步骤 4：保存并退出</h3><p>编辑完成后，保存文件并退出编辑器。对于 <code>nano</code> 编辑器，按 <code>Ctrl+O</code> 保存文件，然后按 <code>Ctrl+X</code> 退出。</p><h3 id="步骤-5：验证配置"><a href="#步骤-5：验证配置" class="headerlink" title="步骤 5：验证配置"></a>步骤 5：验证配置</h3><p>使用以下命令验证 <code>fstab</code> 文件的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -a</span><br></pre></td></tr></table></figure><p>如果没有错误信息，说明配置正确。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>确保每个字段之间用空格或制表符分隔。</li><li>使用 <code>UUID</code> 或 <code>LABEL</code> 可以避免设备名称变化带来的问题。</li><li>错误的 <code>fstab</code> 配置可能导致系统无法启动，修改前务必备份。</li></ul><h2 id="常见挂载选项"><a href="#常见挂载选项" class="headerlink" title="常见挂载选项"></a>常见挂载选项</h2><ul><li><code>defaults</code>：使用默认挂载选项 <code>rw, suid, dev, exec, auto, nouser, async</code>。</li><li><code>ro</code>：只读挂载。</li><li><code>rw</code>：读写挂载。</li><li><code>noauto</code>：不自动挂载。</li><li><code>user</code>：允许普通用户挂载。</li><li><code>nouser</code>：只允许 root 用户挂载。</li><li><code>noexec</code>：禁止执行二进制文件。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><code>man fstab</code>：查看 <code>fstab</code> 的手册页。</li><li><code>man mount</code>：查看 <code>mount</code> 命令的手册页。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Iperf/Iperf3 进行网络性能测试</title>
      <link href="/2024/07/21/iperf_network_test/"/>
      <url>/2024/07/21/iperf_network_test/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Iperf-Iperf3-进行网络性能测试"><a href="#使用-Iperf-Iperf3-进行网络性能测试" class="headerlink" title="使用 Iperf&#x2F;Iperf3 进行网络性能测试"></a>使用 Iperf&#x2F;Iperf3 进行网络性能测试</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>详细介绍了如何使用Iperf或Iperf3工具进行网络性能测试。Iperf是一个功能强大且灵活的网络测试工具，能够测量网络的带宽、延迟、抖动和数据包丢失等关键指标。本文将包括Iperf&#x2F;Iperf3的安装、参数介绍、实际使用案例以及测试结果的解读。</p><h2 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="2. 适用范围"></a>2. 适用范围</h2><p>适用于网络管理员、系统管理员和开发人员，他们需要对局域网(LAN)、广域网(WAN)或其他网络环境的性能进行深入评估。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>网络管理员</strong>: 负责安装和配置Iperf&#x2F;Iperf3工具，并确保测试环境的稳定性。</li><li><strong>系统管理员</strong>: 配置并监控服务器和客户端之间的网络性能测试。</li><li><strong>开发人员</strong>: 利用Iperf&#x2F;Iperf3生成的网络性能数据，优化应用程序的网络使用效率。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>安装了Iperf或Iperf3的系统（包括测试服务器和客户端）。</li><li>目标网络的完全访问权限。</li><li>具备基本的网络知识，理解TCP&#x2F;IP协议、带宽、延迟等概念。</li><li>具备适当的权限进行网络测试，以避免影响生产网络。</li></ul><h2 id="5-参数介绍与使用示例"><a href="#5-参数介绍与使用示例" class="headerlink" title="5. 参数介绍与使用示例"></a>5. 参数介绍与使用示例</h2><h3 id="5-1-常用参数详解"><a href="#5-1-常用参数详解" class="headerlink" title="5.1 常用参数详解"></a>5.1 常用参数详解</h3><ul><li><strong><code>-s</code></strong>: 启动Iperf作为服务器模式，等待客户端连接。该模式下的Iperf不会发送数据，只负责接收并报告结果。</li><li><strong><code>-c &lt;服务器IP地址&gt;</code></strong>: 启动Iperf作为客户端，连接到指定的服务器IP地址。</li><li><strong><code>-u</code></strong>: 使用UDP协议进行测试。如果未指定该选项，Iperf默认使用TCP。</li><li><strong><code>-b &lt;带宽&gt;</code></strong>: 设定UDP测试的目标带宽，例如<code>-b 100M</code>表示目标带宽为100Mbps。对于TCP，该参数会限制发送速率。</li><li><strong><code>-P &lt;并发数&gt;</code></strong>: 指定同时运行的并发流数，通常用于测试多线程或多连接的网络性能。</li><li><strong><code>-t &lt;时间&gt;</code></strong>: 指定测试持续的时间，单位为秒，默认值为10秒。</li><li><strong><code>-i &lt;间隔时间&gt;</code></strong>: 设置报告输出的间隔时间，单位为秒。例如，<code>-i 1</code>表示每秒输出一次中间结果。</li><li><strong><code>--logfile &lt;文件名&gt;</code></strong>: 将测试结果保存到指定的日志文件中，便于后续分析。</li><li><strong><code>--json</code></strong>: 以JSON格式输出测试结果，便于集成到自动化工具或分析系统中。</li></ul><h3 id="5-2-安装-Iperf-Iperf3"><a href="#5-2-安装-Iperf-Iperf3" class="headerlink" title="5.2 安装 Iperf&#x2F;Iperf3"></a>5.2 安装 Iperf&#x2F;Iperf3</h3><ol><li><p><strong>在Linux上安装Iperf&#x2F;Iperf3</strong>:</p><ul><li>Iperf和Iperf3可以通过包管理器安装：<ul><li><strong>Iperf</strong>:<ul><li><strong>Debian&#x2F;Ubuntu</strong>: <code>sudo apt-get install iperf</code></li><li><strong>CentOS&#x2F;RHEL</strong>: <code>sudo yum install iperf</code></li></ul></li><li><strong>Iperf3</strong>:<ul><li><strong>Debian&#x2F;Ubuntu</strong>: <code>sudo apt-get install iperf3</code></li><li><strong>CentOS&#x2F;RHEL</strong>: <code>sudo yum install iperf3</code></li></ul></li></ul></li></ul></li><li><p><strong>验证安装</strong>:</p><ul><li>使用以下命令验证安装是否成功：<ul><li><strong>Iperf</strong>: <code>iperf --version</code></li><li><strong>Iperf3</strong>: <code>iperf3 --version</code></li></ul></li></ul></li></ol><h3 id="5-3-基本带宽测试"><a href="#5-3-基本带宽测试" class="headerlink" title="5.3 基本带宽测试"></a>5.3 基本带宽测试</h3><ol><li><p><strong>使用Iperf测试TCP带宽</strong></p><ul><li><strong>目的</strong>: 测量两台设备之间的最大TCP带宽。</li><li><strong>步骤</strong>:<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -s</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -c &lt;服务器IP地址&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li><strong>结果分析</strong>:<ul><li>测试结果显示客户端到服务器的TCP带宽，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[  3]  0.0-10.0 sec  1.12 GBytes  961 Mbits/sec</span><br></pre></td></tr></table></figure></li><li><code>961 Mbits/sec</code> 表示在10秒内平均带宽为961 Mbps。</li></ul></li></ul></li><li><p><strong>使用Iperf3测试TCP带宽</strong></p><ul><li><strong>目的</strong>: 测量两台设备之间的最大TCP带宽，类似于Iperf，但Iperf3提供了更多的选项和更详细的报告。</li><li><strong>步骤</strong>:<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -s</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;服务器IP地址&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li><strong>结果分析</strong>:<ul><li>结果会显示更多细节，包括每秒的带宽、重传等信息，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ ID] Interval           Transfer     Bandwidth       Retr</span><br><span class="line">[  5]   0.00-10.00  sec  1.11 GBytes  952 Mbits/sec  12   sender</span><br><span class="line">[  5]   0.00-10.00  sec  1.11 GBytes  952 Mbits/sec          receiver</span><br></pre></td></tr></table></figure></li><li><code>952 Mbits/sec</code> 表示TCP带宽，<code>12 Retr</code> 表示发生了12次重传。</li></ul></li></ul></li></ol><h3 id="5-4-UDP性能测试"><a href="#5-4-UDP性能测试" class="headerlink" title="5.4 UDP性能测试"></a>5.4 UDP性能测试</h3><ol><li><p><strong>使用Iperf测试UDP带宽和抖动</strong></p><ul><li><strong>目的</strong>: 测量UDP带宽、抖动和丢包率，这对于实时应用（如VoIP）尤为重要。</li><li><strong>步骤</strong>:<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -s -u</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -c &lt;服务器IP地址&gt; -u -b 100M</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>-b 100M</code> 表示发送100Mbps的UDP流量。</li></ul></li><li><strong>结果分析</strong>:<ul><li>测试结果显示UDP带宽、抖动和丢包率，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[  3]  0.0-10.0 sec  119 MBytes  100 Mbits/sec  0.025 ms  0/8501 (0%)</span><br></pre></td></tr></table></figure></li><li><code>0.025 ms</code> 是抖动值，<code>0/8501 (0%)</code> 表示没有发生丢包。</li></ul></li></ul></li><li><p><strong>使用Iperf3测试UDP性能</strong></p><ul><li><strong>目的</strong>: 类似于Iperf的UDP测试，但Iperf3提供了更详细的报告和控制。</li><li><strong>步骤</strong>:<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -s</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;服务器IP地址&gt; -u -b 50M</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>-b 50M</code> 表示发送50Mbps的UDP流量。</li></ul></li><li><strong>结果分析</strong>:<ul><li>结果显示了更详细的统计信息，包括UDP流量的丢包率和抖动，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ ID] Interval           Transfer     Bandwidth       Total Datagrams</span><br><span class="line">[  5]   0.00-10.00  sec  59.4 MBytes  49.8 Mbits/sec  7601</span><br><span class="line">[  5] Sent 7601 datagrams</span><br><span class="line">[  5] Server Report:</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams</span><br><span class="line">[  5]   0.00-10.00  sec  59.4 MBytes  49.8 Mbits/sec  0.043 ms  1/7601 (0.013%)</span><br></pre></td></tr></table></figure></li><li><code>0.043 ms</code> 是抖动值，<code>1/7601 (0.013%)</code> 表示丢失了1个数据包，丢包率为0.013%。</li></ul></li></ul></li></ol><h3 id="5-5-并发测试"><a href="#5-5-并发测试" class="headerlink" title="5.5 并发测试"></a>5.5 并发测试</h3><ol><li><strong>同时测试多个并发流</strong><ul><li><strong>目的</strong>: 测试多个并发TCP或UDP流对网络性能的影响，模拟多用户或多应用程序同时使用网络的情况。</li><li><strong>步骤</strong>:<ul><li><strong>TCP并发测试</strong>：<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -s</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;服务器IP地址&gt; -P 5</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>-P 5</code> 表示同时启动5个并发流。</li></ul></li><li><strong>UDP并发测试</strong>：<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -s</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;服务器IP地址&gt; -u -b 50M -P 5</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><strong>结果分析</strong>:<ul><li>每个流的带宽</li></ul></li></ul></li></ol><p>、抖动和丢包率都会被单独报告，分析总带宽和每个流的性能可以帮助理解网络在并发场景下的表现。<br>     - 例如：<br>       <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams</span><br><span class="line">[SUM]   0.00-10.00  sec  298 MBytes  250 Mbits/sec  0.090 ms  0/14900 (0%)</span><br></pre></td></tr></table></figure></p><h3 id="5-6-高级测试示例"><a href="#5-6-高级测试示例" class="headerlink" title="5.6 高级测试示例"></a>5.6 高级测试示例</h3><ol><li><p><strong>跨多个子网的测试</strong></p><ul><li><strong>目的</strong>: 测试跨多个子网的网络性能，评估路由器或防火墙的性能。</li><li><strong>步骤</strong>:<ul><li>在不同子网中的服务器和客户端分别运行Iperf3或Iperf。</li><li>例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;跨子网的服务器IP地址&gt; -P 5 -t 30</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>结果分析</strong>:<ul><li>通过分析延迟、带宽和丢包率，了解网络设备在跨子网环境下的表现。</li></ul></li></ul></li><li><p><strong>长时间稳定性测试</strong></p><ul><li><strong>目的</strong>: 进行长时间的网络性能测试，检查网络连接的稳定性和长期表现。</li><li><strong>步骤</strong>:<ul><li>运行长达数小时甚至数天的Iperf3测试：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;服务器IP地址&gt; -t 3600</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>结果分析</strong>:<ul><li>长时间测试结果有助于识别网络中的间歇性问题，如偶发的丢包或带宽波动。</li></ul></li></ul></li></ol><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul><li><a href="https://iperf.fr/">Iperf官方文档</a></li><li><a href="https://github.com/esnet/iperf">Iperf3 GitHub仓库</a></li><li><a href="https://www.redhat.com/en/topics/virtualization/network-performance">网络性能测试指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Proxy 设置</title>
      <link href="/2024/07/21/linux_proxy_config/"/>
      <url>/2024/07/21/linux_proxy_config/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-Proxy-设置"><a href="#Linux-Proxy-设置" class="headerlink" title="Linux Proxy 设置"></a>Linux Proxy 设置</h1><hr><h2 id="Terminal-全局-http-proxy-只在当前Session生效"><a href="#Terminal-全局-http-proxy-只在当前Session生效" class="headerlink" title="Terminal 全局 http proxy (只在当前Session生效)"></a>Terminal 全局 http proxy (只在当前Session生效)</h2><h3 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h3>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://&lt;ip address&gt;:&lt;port&gt;&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://&lt;ip address&gt;:&lt;port&gt;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h3>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> http_proxy</span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br></pre></td></tr></table></figure><h2 id="Proxychains"><a href="#Proxychains" class="headerlink" title="Proxychains"></a>Proxychains</h2><h3 id="安装-预先手动配置Terminal-proxy"><a href="#安装-预先手动配置Terminal-proxy" class="headerlink" title="安装 (预先手动配置Terminal proxy)"></a>安装 (预先手动配置Terminal proxy)</h3><ol><li><p>Debian</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install proxychains</span><br></pre></td></tr></table></figure></li><li><p>RHEL9</p><p><strong>x86_64</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install https://dl.fedoraproject.org/pub/epel/9/Everything/aarch64/Packages/p/proxychains-ng-4.17-1.el9.x86_64.rpm</span><br></pre></td></tr></table></figure><p><strong>ARM64</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install https://dl.fedoraproject.org/pub/epel/9/Everything/aarch64/Packages/p/proxychains-ng-4.17-1.el9.aarch64.rpm</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li>编辑 &#x2F;etc&#x2F;proxychains.conf</li><li>找到quiet_mode，去掉前面的#<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Quiet mode (no output from library)</span><br><span class="line">quiet_mode</span><br></pre></td></tr></table></figure></li><li>滚动到最下，注释原有的sock4<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line"># add proxy here ...</span><br><span class="line"># meanwile</span><br><span class="line"># defaults set to &quot;tor&quot;</span><br><span class="line">#socks4         127.0.0.1 9050</span><br></pre></td></tr></table></figure></li><li>增加要使用的代理<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line">http         192.168.1.147 58080</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>在要连接网络的命令或者脚本名之前加上proxychains即可<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains apt update</span><br><span class="line">proxychains apt install ipmitool</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Red Hat Enterprise Linux 9 YUM 本地源配置</title>
      <link href="/2024/07/16/rhel9_yum_repo/"/>
      <url>/2024/07/16/rhel9_yum_repo/</url>
      
        <content type="html"><![CDATA[<h1 id="准备安装ISO和挂载"><a href="#准备安装ISO和挂载" class="headerlink" title="准备安装ISO和挂载"></a>准备安装ISO和挂载</h1><hr><h2 id="Mount-RHEL9-iso"><a href="#Mount-RHEL9-iso" class="headerlink" title="Mount RHEL9.iso"></a>Mount RHEL9.iso</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount RHEL9.iso /mnt</span><br></pre></td></tr></table></figure><h1 id="创建repo"><a href="#创建repo" class="headerlink" title="创建repo"></a>创建repo</h1><h2 id="增加一个iso-repo到-etc-yum-repos-d-修改baseurl路径为iso-mount的文件夹"><a href="#增加一个iso-repo到-etc-yum-repos-d-修改baseurl路径为iso-mount的文件夹" class="headerlink" title="增加一个iso.repo到&#x2F;etc&#x2F;yum.repos.d, 修改baseurl路径为iso mount的文件夹."></a>增加一个iso.repo到&#x2F;etc&#x2F;yum.repos.d, 修改baseurl路径为iso mount的文件夹.</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/yum.repos.d/iso.repo</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[BaseOS]</span><br><span class="line">name=BaseOS Packages Red Hat Enterprise Linux 9</span><br><span class="line">metadata_expire=-1</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">baseurl=file:///mnt</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release</span><br><span class="line"></span><br><span class="line">[AppStream]</span><br><span class="line">name=AppStream Packages Red Hat Enterprise Linux 9</span><br><span class="line">metadata_expire=-1</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">baseurl=file:///mnt</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release</span><br></pre></td></tr></table></figure><h1 id="YUM-更新和安装"><a href="#YUM-更新和安装" class="headerlink" title="YUM 更新和安装"></a>YUM 更新和安装</h1><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ipmitool</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> RHEL </tag>
            
            <tag> YUM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 ARM 平台上安装、编译和运行 Mlucas 并进行 FFTs 测试</title>
      <link href="/2024/07/03/ARM_FFTs_test/"/>
      <url>/2024/07/03/ARM_FFTs_test/</url>
      
        <content type="html"><![CDATA[<h1 id="在-ARM-平台上安装、编译和运行-Mlucas-并进行-FFTs-测试"><a href="#在-ARM-平台上安装、编译和运行-Mlucas-并进行-FFTs-测试" class="headerlink" title="在 ARM 平台上安装、编译和运行 Mlucas 并进行 FFTs 测试"></a>在 ARM 平台上安装、编译和运行 Mlucas 并进行 FFTs 测试</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>Mlucas 是一个用 C 编写的开源软件，专门用于多平台架构的高性能梅森数素性测试。在 ARM 平台上，由于 prime95&#x2F;mprime 仅支持 x86 架构，Mlucas 成为理想的替代方案。详细介绍了如何在 ARM 平台上安装、编译并运行 Mlucas，包括对各类参数的深入介绍与示例，并结合硬件资源优化进行了详细的配置步骤。</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h2><p>适用于希望在 ARM 平台上执行 FFTs 测试并优化硬件性能的技术人员。本文主要针对运行 Debian 系统的 ARM64 设备，但同样适用于其他 Linux 发行版，步骤可能略有不同。</p><h2 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h2><ul><li><strong>系统管理员</strong>：确保 ARM 平台上所需的软件和库均已正确安装，具备系统管理权限。</li><li><strong>操作员</strong>：严格按照本 SOP 进行 Mlucas 的安装、编译、调优和运行。</li></ul><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h2><ul><li>ARM64 架构的设备，运行 Linux 操作系统（如 Debian 或 RHEL9）。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>有效的互联网连接以下载必要的软件包和源码。</li></ul><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><h3 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h3><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装必要的依赖包</strong></p><ul><li><p><strong>Debian</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential libgmp-dev libhwloc-dev git clang</span><br></pre></td></tr></table></figure></li><li><p><strong>RHEL9</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf group install <span class="string">&quot;Development Tools&quot;</span></span><br><span class="line">sudo dnf install gmp-devel hwloc-devel clang git</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-下载和准备-Mlucas"><a href="#2-下载和准备-Mlucas" class="headerlink" title="2. 下载和准备 Mlucas"></a>2. <strong>下载和准备 Mlucas</strong></h3><p>2.1 <strong>从 GitHub 克隆 Mlucas 源码</strong></p><ul><li>使用以下命令克隆 Mlucas 项目到本地目录。也可以从 <a href="https://github.com/primesearch/Mlucas/releases">Release 页面</a> 下载源码包。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/primesearch/Mlucas.git</span><br></pre></td></tr></table></figure></li></ul><p>2.2 <strong>进入 Mlucas 项目目录</strong><br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Mlucas</span><br></pre></td></tr></table></figure></p><h3 id="3-编译-Mlucas"><a href="#3-编译-Mlucas" class="headerlink" title="3. 编译 Mlucas"></a>3. <strong>编译 Mlucas</strong></h3><p>3.1 <strong>设置编译器</strong></p><ul><li>将编译器设置为 <code>clang</code> 以优化编译过程。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CC=clang</span><br></pre></td></tr></table></figure></li></ul><p>3.2 <strong>使用 makemake.sh 脚本编译 Mlucas</strong></p><ul><li>执行 <code>makemake.sh</code> 脚本，确保启用 <code>hwloc</code> 支持，以优化 CPU 绑定和内存访问性能。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash makemake.sh use_hwloc</span><br></pre></td></tr></table></figure></li></ul><p>3.3 <strong>确认编译成功</strong></p><ul><li>编译完成后，编译生成的可执行文件将位于 <code>obj</code> 目录中。使用以下命令查看生成的文件：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> obj</span><br></pre></td></tr></table></figure></li><li>生成的文件名可能会因编译选项的不同而变化，如 <code>Mlucas</code>.</li></ul><h3 id="4-性能调优：为您的机器进行优化"><a href="#4-性能调优：为您的机器进行优化" class="headerlink" title="4. 性能调优：为您的机器进行优化"></a>4. <strong>性能调优：为您的机器进行优化</strong></h3><p><strong>STEP 2 − PERFORMANCE-TUNE FOR YOUR MACHINE</strong></p><p>在 Mlucas 编译完成后，重要的是对软件进行调优，以便充分利用您的硬件资源。这一步骤涉及运行一系列测试，以确定适合您机器的最佳 FFT 长度和 CPU 绑定配置。</p><p>4.1 <strong>运行自检</strong></p><ul><li><p>自检测试将评估您的硬件性能，并生成配置文件，帮助确定适合的 FFT 长度和其他参数。运行以下命令：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Mlucas -s</span><br></pre></td></tr></table></figure></li><li><p>该命令将测试多个 FFT 长度和 CPU 配置，以确定最佳配置。测试结果将存储在生成的日志文件中。</p></li></ul><p>4.2 <strong>分析自检结果</strong></p><ul><li><p>自检完成后，打开并分析生成的日志文件（通常是 <code>mlucas.cfg</code> 或其他输出文件），查看不同 FFT 长度下的性能表现。</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> mlucas.cfg</span><br></pre></td></tr></table></figure></li><li><p>该文件会列出每个 FFT 长度的平均迭代时间。较短的时间意味着更优的性能。选择那些具有最短迭代时间的 FFT 长度和配置。</p></li></ul><p>4.3 <strong>配置 Mlucas</strong></p><ul><li>根据自检结果，手动编辑 <code>mlucas.cfg</code> 文件，以使用最佳配置进行实际测试。例如，设置合适的 FFT 长度和 CPU 绑定。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano mlucas.cfg</span><br></pre></td></tr></table></figure></li><li>在配置文件中指定最佳 FFT 长度和 CPU 核心分配，如：   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FFTlength=2048K</span><br><span class="line">CPU=0-7</span><br></pre></td></tr></table></figure></li></ul><p>4.4 <strong>再次测试并验证</strong></p><ul><li>使用优化后的配置重新运行 Mlucas，并通过日志文件验证性能是否有所提升。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Mlucas -s m -logfile optimized_test.log</span><br></pre></td></tr></table></figure></li><li>实时查看日志文件以确认测试正在按预期的配置进行：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f optimized_test.log</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-Mlucas-参数设置与执行-FFTs-测试"><a href="#5-Mlucas-参数设置与执行-FFTs-测试" class="headerlink" title="5. Mlucas 参数设置与执行 FFTs 测试"></a>5. <strong>Mlucas 参数设置与执行 FFTs 测试</strong></h3><p>5.1 <strong>获取系统的 CPU 信息</strong></p><ul><li>在执行测试之前，获取并了解测试机器的 CPU 配置情况。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure></li><li>例如，输出结果可能为：   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CPU(s):              32</span><br><span class="line">Thread(s) per core:  1</span><br><span class="line">NUMA node0 CPU(s):   0-15</span><br><span class="line">NUMA node1 CPU(s):   16-31</span><br></pre></td></tr></table></figure></li></ul><p>5.2 <strong>Mlucas 常用参数介绍</strong></p><ul><li><code>-s</code>：指定自检或特定素性测试模式。常见值包括：<ul><li><code>-s</code>：自检模式，测试系统性能并生成配置文件。</li><li><code>-s m</code>：启动梅森数的快速测试。</li><li><code>-s q</code>：启动快速素数测试（例如 Fermat 测试）。</li></ul></li><li><code>-cpu</code>：指定使用的 CPU 核心范围。格式为 <code>-cpu start:end</code>，例如 <code>-cpu 0:15</code> 表示使用 CPU 0 到 15 号核心。</li><li><code>-fftlen</code>：设置 FFT 长度。FFT 长度决定了可处理的最大数字大小。常见值为 1024K, 2048K, 4096K 等。</li><li><code>-iters</code>：设置每个测试的迭代次数。更高的迭代次数可提供更精确的结果，但需要更多时间。</li><li><code>-logfile</code>：指定日志文件路径。默认值为 <code>mlucas.log</code>。</li></ul><p>5.3 <strong>FFT 测试的参数示例</strong></p><ul><li>自检模式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Mlucas -s</span><br></pre></td></tr></table></figure></li><li>运行 FFTs 测试并指定 CPU 核心范围：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Mlucas -s m -cpu 0:3 -fftlen 2048K -iters 10000 -logfile fft_test.log</span><br></pre></td></tr></table></figure></li><li>对不同核心组运行 FFTs 测试：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./Mlucas -s m -cpu 0:3</span><br><span class="line">./Mlucas -s m -cpu 4:7</span><br><span class="line">./Mlucas -s m -cpu 8:11</span><br><span class="line">./Mlucas -s m -cpu 12:15</span><br><span class="line">./Mlucas -s m -cpu 16:19</span><br><span class="line">./Mlucas -s m -cpu 20:23</span><br><span class="line">./Mlucas -s m -cpu 24:27</span><br><span class="line">./Mlucas -s m -cpu 28:31</span><br></pre></td></tr></table></figure></li></ul><p>5.4 <strong>监控测试进度</strong></p><ul><li>Mlucas 运行过程中会生成日志文件，可以使用以下命令实时查看日志以监控测试进度和性能表现：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f mlucas.log</span><br></pre></td></tr></table></figure></li></ul><p>5.5 <strong>常见优化建议</strong></p><ul><li><strong>调整 FFT 长度</strong>：根据硬件配置和测试目标，选择适合的 FFT 长度。较大的 FFT 长度通常适用于处理更大的数字，但可能会增加计算时间。</li><li><strong>核心绑定</strong>：通过 <code>-cpu</code> 参数绑定特定核心组，以避免不同进程争夺相同的 CPU 资源，从而提升性能。</li></ul><h3 id="6-优化与维护"><a href="#6-优化与维护" class="headerlink" title="6. 优化与维护"></a>6. <strong>优化与维护</strong></h3><p>6.1 <strong>优化 CPU 绑定</strong></p><ul><li>根据测试需求和系统资源，调整 <code>-cpu</code> 参数中的核心范围，以进一步优化计算性能。</li></ul><p>6.2 <strong>定期更新</strong></p><ul><li>通过定期从 GitHub 仓库获取最新的源码，并重新编译，以确保使用最新版的 Mlucas 并获得最新的性能优化。</li></ul><h3 id="7-自动化测试脚本"><a href="#7-自动化测试脚本" class="headerlink" title="7. 自动化测试脚本"></a>7. <strong>自动化测试脚本</strong></h3><p>7.1 <strong>编写自动化测试脚本</strong></p><ul><li>以下是 Bash 脚本<code>run_mlucas.sh</code>的详细说明，用于自动化 Mlucas 的测试过程。该脚本支持两种 FFT 模式 (<code>small</code> 和 <code>large</code>)，根据 CPU 核心数量自动分配核心组，并并行运行多个 Mlucas 实例。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 FFT 模式和其他关键参数</span></span><br><span class="line">fft_mode=<span class="string">&quot;small&quot;</span>  <span class="comment"># 默认模式为 small，可以通过传入参数修改</span></span><br><span class="line">fft_mode=<span class="variable">$1</span>  <span class="comment"># 接收传入的 FFT 模式参数</span></span><br><span class="line">mlucas_dir=<span class="string">&quot;/Mlucas&quot;</span>  <span class="comment"># 定义 Mlucas 目录路径</span></span><br><span class="line">s_mode=<span class="string">&quot;l&quot;</span></span><br><span class="line">duration=60  <span class="comment"># 定义测试持续时间</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$mlucas_dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义配置文件和核心分配策略</span></span><br><span class="line">small_cfg_file=<span class="string">&quot;mlucas_small.cfg&quot;</span></span><br><span class="line">large_cfg_file=<span class="string">&quot;mlucas_large.cfg&quot;</span></span><br><span class="line">cores_per_group=2  <span class="comment"># 每组分配的核心数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除旧的配置文件</span></span><br><span class="line"><span class="built_in">rm</span> mlucas.cfg -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查并初始化 small FFT 配置文件</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">&quot;<span class="variable">$small_cfg_file</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Basic testing - small FFTs...&quot;</span></span><br><span class="line">    ./obj_asimd/Mlucas -s small -cpu 0:$((cores_per_group-<span class="number">1</span>)) &gt;&amp; small_test.log</span><br><span class="line">    <span class="built_in">mv</span> mlucas.cfg mlucas_small.cfg</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Initialized mlucas_small.cfg.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查并初始化 large FFT 配置文件</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">&quot;<span class="variable">$large_cfg_file</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Basic testing - large FFTs, this will take a long time...&quot;</span></span><br><span class="line">    ./obj_asimd/Mlucas -s large -cpu 0:$((cores_per_group-<span class="number">1</span>)) &gt;&amp; large_test.log</span><br><span class="line">    <span class="built_in">mv</span> mlucas.cfg mlucas_large.cfg</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Initialized mlucas_large.cfg.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果两个配置文件都存在，提取相关信息</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$small_cfg_file</span>&quot;</span> ] &amp;&amp; [ -f <span class="string">&quot;<span class="variable">$large_cfg_file</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$small_cfg_file</span> and <span class="variable">$large_cfg_file</span> are existed.&quot;</span></span><br><span class="line">    small_fft=$(<span class="built_in">tail</span> -n 1 mlucas_small.cfg | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">    small_fft_radix=$(<span class="built_in">tail</span> -n 1 mlucas_small.cfg | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $11&#125;&#x27;</span>)</span><br><span class="line">    small_fft_time=$(<span class="built_in">tail</span> -n 1 mlucas_small.cfg | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    large_fft=$(<span class="built_in">tail</span> -n 1 mlucas_large.cfg | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">    large_fft_radix=$(<span class="built_in">tail</span> -n 1 mlucas_large.cfg | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $11&#125;&#x27;</span>)</span><br><span class="line">    large_fft_time=$(<span class="built_in">tail</span> -n 1 mlucas_large.cfg | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    small_fft_iter=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$small_fft_time</span> 1000 <span class="variable">$duration</span>&quot;</span> | awk <span class="string">&#x27;&#123;printf &quot;%.0f\n&quot;, $3 / ($1 / $2)/ 2&#125;&#x27;</span>)</span><br><span class="line">    large_fft_iter=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$large_fft_time</span> 1000 <span class="variable">$duration</span>&quot;</span> | awk <span class="string">&#x27;&#123;printf &quot;%.0f\n&quot;, $3 / ($1 / $2)/ 2&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据模式设置链接和参数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$fft_mode</span>&quot;</span> = <span class="string">&quot;large&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    instance_count=1</span><br><span class="line">    <span class="built_in">ln</span> -s mlucas_large.cfg mlucas.cfg</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    instance_count=2</span><br><span class="line">    <span class="built_in">ln</span> -s mlucas_small.cfg mlucas.cfg</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据模式选择 FFT 配置</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$fft_mode</span>&quot;</span> = <span class="string">&quot;large&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    fft=<span class="variable">$large_fft</span></span><br><span class="line">    fft_radix=<span class="variable">$large_fft_radix</span></span><br><span class="line">    iter=<span class="variable">$large_fft_iter</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    fft=<span class="variable">$small_fft</span></span><br><span class="line">    fft_radix=<span class="variable">$small_fft_radix</span></span><br><span class="line">    iter=<span class="variable">$small_fft_iter</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> fft: <span class="variable">$fft</span> fft_radix: <span class="variable">$fft_radix</span> iter: <span class="variable">$iter</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建运行环境</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Creating env...&quot;</span></span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$mlucas_dir</span>/runset -rf</span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$mlucas_dir</span>/jobs.sh -f</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$mlucas_dir</span>/runset</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#!/bin/bash&quot;</span> &gt;&gt; jobs.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 CPU 核心数量</span></span><br><span class="line">cores=$(<span class="built_in">cat</span> /proc/cpuinfo | grep processor | <span class="built_in">wc</span> -l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算总共需要多少组</span></span><br><span class="line">num_groups=$((cores / cores_per_group))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环输出每组的核心范围并生成任务脚本</span></span><br><span class="line"><span class="keyword">for</span> ((i = <span class="number">0</span>; i &lt; num_groups; i++)); <span class="keyword">do</span></span><br><span class="line">    start=$((i * cores_per_group))</span><br><span class="line">    end=$((start + cores_per_group - <span class="number">1</span>))</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Group <span class="variable">$i</span>: <span class="variable">$start</span>:<span class="variable">$end</span>&quot;</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="variable">$mlucas_dir</span>/runset/run<span class="variable">$i</span></span><br><span class="line">    <span class="keyword">for</span> ((j = <span class="number">0</span>; j &lt; instance_count; j++)); <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;cd <span class="variable">$mlucas_dir</span>/runset/run<span class="variable">$i</span> &amp;&amp; nohup ../../obj_asimd/Mlucas -fft <span class="variable">$fft</span> -iters <span class="variable">$iter</span> -maxalloc 50 -cpu <span class="variable">$start</span>:<span class="variable">$end</span> -radset 1 &gt;&gt; <span class="variable">$mlucas_dir</span>/runset/run<span class="variable">$i</span>/test<span class="variable">$j</span>.log 2&gt;&amp;1 &amp;&quot;</span> &gt;&gt; jobs.sh</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行生成的任务脚本</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running jobs.sh...&quot;</span></span><br><span class="line">bash jobs.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;jobs.sh running in background.&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&#x27;pkill -x Mlucas&#x27; to end testing.&quot;</span></span><br></pre></td></tr></table></figure><p>7.2 <strong>脚本运行说明</strong></p><ul><li>该脚本在启动时会根据传入的参数选择 FFT 模式（small 或 large），并自动初始化相应的配置文件。</li><li>脚本自动检测系统中的 CPU 核心数量，并将核心划分为多个组，每组运行一个或多个 Mlucas 实例。</li><li>生成的任务脚本 <code>jobs.sh</code> 会在后台启动所有的 Mlucas 实例，并记录测试日志。</li></ul><p>7.3 <strong>执行脚本</strong></p><ul><li>在终端中执行脚本，传入所需的 FFT 模式（如 <code>small</code> 或 <code>large</code>）。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash run_mlucas.sh small</span><br></pre></td></tr></table></figure></li></ul><p>7.4 <strong>监控日志</strong></p><ul><li>脚本将测试日志记录在每个核心组的 <code>test.log</code> 文件中，可以通过以下命令实时监控日志：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f /Mlucas/runset/run0/test0.<span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ul><p>7.5 <strong>停止测试</strong></p><ul><li>如果需要终止测试，可以使用以下命令终止所有正在运行的 Mlucas 实例：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -x Mlucas</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://www.mersenneforum.org/mayer/README.html">Mlucas README</a></li><li><a href="https://github.com/primesearch/Mlucas">Mlucas GitHub Repository</a></li><li><a href="https://www.arm.com/resources/developer/guide">ARM64 Linux Compilation Guides</a></li><li><a href="https://linuxconfig.org/bash-scripting-tutorial-for-beginners">Bash Scripting Basics</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Memtester 进行内存测试</title>
      <link href="/2024/07/03/memtester_test/"/>
      <url>/2024/07/03/memtester_test/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Memtester-进行内存测试"><a href="#使用-Memtester-进行内存测试" class="headerlink" title="使用 Memtester 进行内存测试"></a>使用 Memtester 进行内存测试</h1><hr><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>详细介绍了如何使用 Memtester 工具进行内存的稳定性和健康检查。Memtester 是一个内存测试工具，它通过对内存执行各种读写操作来检测可能存在的内存错误。它可以在操作系统运行时对内存进行测试，是诊断内存故障的有效工具。</p><h2 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="2. 适用范围"></a>2. 适用范围</h2><p>适用于系统管理员、硬件技术人员和其他需要检测和诊断内存问题的用户，尤其是在Linux和类Unix操作系统环境中。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>系统管理员</strong>: 负责安装和运行 Memtester 工具，并根据测试结果采取必要的维护或更换操作。</li><li><strong>硬件技术人员</strong>: 评估内存的物理健康状况，尤其是在发生系统崩溃或不稳定性时。</li><li><strong>开发人员</strong>: 在开发高负载应用程序时，利用 Memtester 测试内存的稳定性。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>具有 root 或 sudo 权限的系统账户。</li><li>系统内存的足够可用空间以进行测试（通常建议至少有一半以上的空闲内存）。</li><li>系统对 Memtester 工具的支持和安装（通常在大多数 Linux 发行版的包管理器中可用）。</li></ul><h2 id="5-流程和示例"><a href="#5-流程和示例" class="headerlink" title="5. 流程和示例"></a>5. 流程和示例</h2><h3 id="5-1-安装-Memtester"><a href="#5-1-安装-Memtester" class="headerlink" title="5.1 安装 Memtester"></a>5.1 安装 Memtester</h3><ol><li><p><strong>在Linux上安装Memtester</strong>:</p><ul><li>Memtester 可以通过包管理器安装：<ul><li><strong>Debian&#x2F;Ubuntu</strong>: <code>sudo apt-get install memtester</code></li><li><strong>CentOS&#x2F;RHEL</strong>: <code>sudo yum install memtester</code></li><li><strong>Fedora</strong>: <code>sudo dnf install memtester</code></li></ul></li></ul></li><li><p><strong>验证安装</strong>:</p><ul><li>使用以下命令验证安装是否成功：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memtester --version</span><br></pre></td></tr></table></figure></li><li>如果成功安装，Memtester 会返回版本号信息。</li></ul></li></ol><h3 id="5-2-基本内存测试"><a href="#5-2-基本内存测试" class="headerlink" title="5.2 基本内存测试"></a>5.2 基本内存测试</h3><ol><li><strong>运行Memtester</strong>:<ul><li><strong>目的</strong>: 测试指定大小的内存块以检测潜在的内存错误。</li><li><strong>步骤</strong>:<ol><li>以 root 或具有 sudo 权限的用户运行 Memtester：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo memtester &lt;测试内存大小&gt; &lt;测试次数&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>例如，要测试 1 GB 的内存并运行 5 次测试循环：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo memtester 1G 5</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>结果分析</strong>:<ul><li>Memtester 会显示内存测试的详细过程，包括每次测试的结果和通过或失败的标志。</li><li>输出示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">memtester version 4.3.0 (64-bit)</span><br><span class="line">Copyright (C) 2004 Charles Cazabon.</span><br><span class="line">Licensed under the GNU General Public License version 2 (only).</span><br><span class="line"></span><br><span class="line">pagesize is 4096</span><br><span class="line">pagesizemask is 0xfffffffffffff000</span><br><span class="line">want 1024MB (1073741824 bytes)</span><br><span class="line">got  1024MB (1073741824 bytes), trying mlock ...locked.</span><br><span class="line">Loop 1/5:</span><br><span class="line">Stuck Address       : ok</span><br><span class="line">Random Value        : ok</span><br><span class="line">Compare XOR         : ok</span><br><span class="line">Compare SUB         : ok</span><br><span class="line">Compare MUL         : ok</span><br><span class="line">Compare DIV         : ok</span><br><span class="line">Compare OR          : ok</span><br><span class="line">Compare AND         : ok</span><br><span class="line">Sequential Increment: ok</span><br><span class="line">Solid Bits          : ok</span><br><span class="line">Block Sequential    : ok</span><br><span class="line">Checkerboard        : ok</span><br><span class="line">Bit Spread          : ok</span><br><span class="line">Bit Flip            : ok</span><br><span class="line">Walking Ones        : ok</span><br><span class="line">Walking Zeroes      : ok</span><br><span class="line">8-bit Writes        : ok</span><br><span class="line">16-bit Writes       : ok</span><br></pre></td></tr></table></figure></li><li><code>ok</code> 表示该测试项通过。如果有任何测试未通过，Memtester 会在输出中标记错误。</li></ul></li></ul></li></ol><h3 id="5-3-高级内存测试"><a href="#5-3-高级内存测试" class="headerlink" title="5.3 高级内存测试"></a>5.3 高级内存测试</h3><ol><li><p><strong>测试所有可用内存</strong>:</p><ul><li><strong>目的</strong>: 在不指定内存大小的情况下，测试系统中所有可用的空闲内存。</li><li><strong>步骤</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo memtester $(free -m | grep -oP <span class="string">&#x27;\\d+&#x27;</span> | <span class="built_in">head</span> -n 1)M 1</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li>该命令会自动检测并使用系统的所有可用内存进行测试。</li><li>如果在测试期间检测到错误，Memtester 会报告并建议进一步的物理检查或更换内存模块。</li></ul></li></ul></li><li><p><strong>连续运行内存测试以检测间歇性错误</strong>:</p><ul><li><strong>目的</strong>: 长时间连续运行内存测试以捕获间歇性或偶发的内存错误。</li><li><strong>步骤</strong>:<ul><li>使用较大内存块和更多的测试循环，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo memtester 2G 50</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>结果分析</strong>:<ul><li>通过连续的测试循环，Memtester 能够检测到由于热胀冷缩或电气干扰导致的间歇性错误。</li><li>如果发现任何错误，建议检查物理内存模块，并考虑在不同的插槽中进行测试。</li></ul></li></ul></li></ol><h3 id="5-4-多任务环境中的内存测试"><a href="#5-4-多任务环境中的内存测试" class="headerlink" title="5.4 多任务环境中的内存测试"></a>5.4 多任务环境中的内存测试</h3><ol><li><strong>在多任务系统中运行Memtester</strong>:<ul><li><strong>目的</strong>: 在多任务负载下测试内存的稳定性。</li><li><strong>步骤</strong>:<ul><li>在进行内存测试时，可以让系统继续运行其他任务，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo memtester 512M 10 &amp;</span><br><span class="line">stress --cpu 4 --<span class="built_in">timeout</span> 600</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>结果分析</strong>:<ul><li>Memtester 与其他高负载任务（如 CPU 压力测试）同时运行，可以有效检测内存模块在高压力下的可靠性。</li><li>如果 Memtester 报告错误或系统崩溃，表明可能存在内存不稳定的情况。</li></ul></li></ul></li></ol><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul><li><a href="https://pyropus.ca/software/memtester/">Memtester 官方文档</a></li><li><a href="https://www.memtest86.com/troubleshooting.htm">内存测试与诊断指南</a></li><li><a href="https://www.redhat.com/en/topics/linux/hardware-diagnostics">系统硬件诊断最佳实践</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> Memtester </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stressapptest 测试</title>
      <link href="/2024/07/03/stressapptest_test/"/>
      <url>/2024/07/03/stressapptest_test/</url>
      
        <content type="html"><![CDATA[<h1 id="在-ARM-平台上使用-Stressapptest-进行压力测试"><a href="#在-ARM-平台上使用-Stressapptest-进行压力测试" class="headerlink" title="在 ARM 平台上使用 Stressapptest 进行压力测试"></a>在 ARM 平台上使用 Stressapptest 进行压力测试</h1><hr><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p>Stressapptest 是一款专门用于内存和 I&#x2F;O 子系统压力测试的工具。它通过在系统上施加高负荷来发现硬件问题，特别是在内存和缓存方面的潜在故障。<br>详细介绍了在 ARM 平台上安装、配置并运行 Stressapptest 进行系统稳定性和性能测试的过程。</p><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h4><p>适用于希望在平台上验证硬件稳定性和性能的技术人员，特别是在内存和 I&#x2F;O 方面的测试。</p><h4 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h4><ul><li><strong>系统管理员</strong>：确保系统已正确安装所有必需的依赖包，并具备执行测试所需的权限。</li><li><strong>操作员</strong>：按照本 SOP 正确执行 Stressapptest，确保测试顺利进行。</li></ul><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h4><ul><li>运行 Linux 操作系统（如 Debian 或 RHEL9）。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>有效的互联网连接以下载必要的软件包和工具。</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h4><h5 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h5><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装 Stressapptest</strong></p><ul><li><p><strong>在 Debian&#x2F;Ubuntu 系统上使用 <code>apt</code> 安装 Stressapptest：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install stressapptest</span><br></pre></td></tr></table></figure></li><li><p><strong>在 RHEL&#x2F;CentOS 系统上使用 <code>yum</code> 安装 Stressapptest：</strong></p><ul><li>首先，启用 EPEL 仓库（如果尚未启用）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure></li><li>然后安装 Stressapptest：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install stressapptest</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-手动下载并编译-Stressapptest"><a href="#2-手动下载并编译-Stressapptest" class="headerlink" title="2. 手动下载并编译 Stressapptest"></a>2. <strong>手动下载并编译 Stressapptest</strong></h5><blockquote><p>注意：如果通过包管理器安装 Stressapptest 不可行或需要最新版，可以通过手动编译安装。</p></blockquote><p>2.1 <strong>从 GitHub 克隆 Stressapptest 源码</strong></p><ul><li>使用以下命令从 GitHub 克隆 Stressapptest 项目到本地目录。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/stressapptest/stressapptest.git</span><br></pre></td></tr></table></figure></li></ul><p>2.2 <strong>进入项目目录</strong><br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> stressapptest</span><br></pre></td></tr></table></figure></p><p>2.3 <strong>编译 Stressapptest</strong></p><ul><li>使用以下命令编译 Stressapptest。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li></ul><p>2.4 <strong>安装 Stressapptest</strong></p><ul><li>编译完成后，可以选择将其安装到系统中，便于全局使用。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-配置与运行-Stressapptest"><a href="#3-配置与运行-Stressapptest" class="headerlink" title="3. 配置与运行 Stressapptest"></a>3. <strong>配置与运行 Stressapptest</strong></h5><p>3.1 <strong>运行基本测试</strong></p><ul><li>在默认配置下运行 Stressapptest。此命令将在默认设置下运行一个 20 分钟的压力测试：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stressapptest -s 1200 -M 1024 -W</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>-s 1200</code>：指定测试时长为 1200 秒（即 20 分钟）。</li><li><code>-M 1024</code>：使用 1024 MB 内存进行测试。</li><li><code>-W</code>：使测试过程的 I&#x2F;O 操作更具挑战性。</li></ul></li></ul><p>3.2 <strong>测试所有可用内存</strong></p><ul><li>为了测试系统的所有可用内存，使用 <code>-m</code> 选项指定测试内存的百分比。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stressapptest -s 1800 -m 90</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>-m 90</code>：使用 90% 的系统内存进行测试。</li><li><code>-s 1800</code>：测试时长为 1800 秒（即 30 分钟）。</li></ul></li></ul><p>3.3 <strong>并行运行多个测试实例</strong></p><ul><li>在多核系统上，可以并行运行多个测试实例，以加大测试负荷。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stressapptest -s 3600 -M 512 -m 80 -C 16</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>-C 16</code>：使用 16 个 CPU 核心进行测试。</li><li><code>-M 512</code>：每个测试实例使用 512 MB 内存。</li></ul></li></ul><h5 id="4-监控与分析测试结果"><a href="#4-监控与分析测试结果" class="headerlink" title="4. 监控与分析测试结果"></a>4. <strong>监控与分析测试结果</strong></h5><p>4.1 <strong>监控测试进度</strong></p><ul><li>在测试过程中，可以实时查看输出，了解测试进度和当前的系统状态。</li></ul><p>4.2 <strong>分析测试结果</strong></p><ul><li>测试完成后，Stressapptest 将生成一份测试报告，显示任何检测到的内存错误或 I&#x2F;O 错误。检查输出中的错误报告，以确定是否存在硬件问题。</li></ul><p>4.3 <strong>保存测试日志</strong></p><ul><li>可以将测试日志保存到文件中，以便后续分析：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stressapptest -s 3600 -M 1024 -W &gt; stressapptest_log.txt</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-优化与维护"><a href="#5-优化与维护" class="headerlink" title="5. 优化与维护"></a>5. <strong>优化与维护</strong></h5><p>5.1 <strong>定期测试</strong></p><ul><li>建议定期运行 Stressapptest，特别是在系统进行重大变更（如硬件升级或系统更新）之后，以确保系统的持续稳定性。</li></ul><p>5.2 <strong>调整参数</strong></p><ul><li>根据测试结果，调整 Stressapptest 的参数，以便更好地检测系统潜在问题。</li></ul><h5 id="6-常见问题与故障排除"><a href="#6-常见问题与故障排除" class="headerlink" title="6. 常见问题与故障排除"></a>6. <strong>常见问题与故障排除</strong></h5><p>6.1 <strong>测试失败或系统崩溃</strong></p><ul><li>如果在测试过程中系统崩溃或测试失败，请检查系统日志以确定故障原因。可能需要降低测试负荷，或排查硬件问题。</li></ul><p>6.2 <strong>内存不足</strong></p><ul><li>如果在测试过程中出现内存不足的错误，考虑减少分配给测试的内存量，或增加系统的虚拟内存。</li></ul><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h4><ul><li><a href="https://github.com/stressapptest/stressapptest">Stressapptest GitHub Repository</a></li><li><a href="https://linux.die.net/man/1/stressapptest">Linux Performance Tools</a></li><li><a href="https://linuxconfig.org/bash-scripting-tutorial-for-beginners">Bash Scripting Basics</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> Stressapptest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基本命令操作</title>
      <link href="/2024/07/02/linux_common_commands/"/>
      <url>/2024/07/02/linux_common_commands/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-基本命令操作"><a href="#Linux-基本命令操作" class="headerlink" title="Linux 基本命令操作"></a>Linux 基本命令操作</h1><hr><h2 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h2><ol><li><p><strong>列出目录内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file1.txt  file2.txt  directory1  directory2</span><br></pre></td></tr></table></figure></li><li><p><strong>切换到指定目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> directory1</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(无输出，仅切换目录)</span><br></pre></td></tr></table></figure></li><li><p><strong>显示当前工作目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/user/directory1</span><br></pre></td></tr></table></figure></li><li><p><strong>创建新目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> new_directory</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(无输出，仅创建目录)</span><br></pre></td></tr></table></figure></li><li><p><strong>删除文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> file1.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(无输出，仅删除文件)</span><br></pre></td></tr></table></figure></li></ol><h2 id="文件内容查看和编辑"><a href="#文件内容查看和编辑" class="headerlink" title="文件内容查看和编辑"></a>文件内容查看和编辑</h2><ol><li><p><strong>显示文件内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> file2.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is the content of file2.txt.</span><br></pre></td></tr></table></figure></li><li><p><strong>分页显示文件内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more file2.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the content of file2.txt.</span><br><span class="line">--More-- (按空格键翻页)</span><br></pre></td></tr></table></figure></li><li><p><strong>编辑文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano file2.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(进入 nano 编辑界面)</span><br></pre></td></tr></table></figure></li></ol><h2 id="文件权限和所有权"><a href="#文件权限和所有权" class="headerlink" title="文件权限和所有权"></a>文件权限和所有权</h2><ol><li><p><strong>更改文件权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 file2.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(无输出，仅更改权限)</span><br></pre></td></tr></table></figure></li><li><p><strong>更改文件所有者</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> newuser file2.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(无输出，仅更改所有者)</span><br></pre></td></tr></table></figure></li></ol><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><ol><li><p><strong>显示当前运行的进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> PID TTY          TIME CMD</span><br><span class="line">1056 pts/0    00:00:00 bash</span><br><span class="line">1082 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure></li><li><p><strong>实时显示系统资源使用情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top - 10:45:14 up 2 days,  4:22,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks: 118 total,   1 running, 117 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.7 us,  0.3 sy,  0.0 ni, 99.0 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  2048576 total,   192652 free,  1298964 used,   556960 buff/cache</span><br><span class="line">KiB Swap:  1048572 total,  1048572 free,        0 used.   652632 avail Mem </span><br></pre></td></tr></table></figure></li><li><p><strong>清除journalctl系统日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --flush --rotate --vacuum-time=1s</span><br></pre></td></tr></table></figure></li><li><p><strong>显示磁盘使用情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1        20G  9.3G  9.1G  51% /</span><br><span class="line">tmpfs           996M  1.2M  995M   1% /run</span><br></pre></td></tr></table></figure></li><li><p><strong>关机或重启系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo shutdown -h now</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(系统会显示关机通知并在几秒钟后关机)</span><br></pre></td></tr></table></figure></li></ol><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><ol><li><p><strong>检测网络连接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping google.com</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PING google.com (172.217.164.110) 56(84) bytes of data.</span><br><span class="line">64 bytes from lga25s61-in-f14.1e100.net (172.217.164.110): icmp_seq=1 ttl=54 time=10.8 ms</span><br></pre></td></tr></table></figure></li><li><p><strong>设置 terminal proxy</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://192.168.50.1:58080&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://192.168.50.1:58080&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 proxychains proxy</strong></p><p>A. 安装 proxychains</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install proxychains</span><br></pre></td></tr></table></figure><p>B. 修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/proxychains.conf</span><br><span class="line"><span class="comment"># Quiet mode (no output from library)</span></span><br><span class="line">quiet_mode</span><br><span class="line"></span><br><span class="line">[ProxyList]</span><br><span class="line"><span class="comment"># add proxy here ...</span></span><br><span class="line"><span class="comment"># meanwile</span></span><br><span class="line"><span class="comment"># defaults set to &quot;tor&quot;</span></span><br><span class="line"><span class="comment">#socks4         127.0.0.1 9050</span></span><br><span class="line">http    192.168.50.1    58080</span><br></pre></td></tr></table></figure><p>C. 使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains apt update</span><br></pre></td></tr></table></figure></li></ol><h2 id="软件安装相关"><a href="#软件安装相关" class="headerlink" title="软件安装相关"></a>软件安装相关</h2><ol><li><p><strong>apt 安装软件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install stress</span><br></pre></td></tr></table></figure></li><li><p><strong>apt 卸载软件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt remove stress</span><br></pre></td></tr></table></figure></li><li><p><strong>apt 搜索软件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search stress</span><br></pre></td></tr></table></figure></li><li><p><strong>dpkg 查看已安装软件信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l</span><br></pre></td></tr></table></figure></li><li><p><strong>编译安装</strong></p><p>A. 安装编译组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -y build-essential</span><br></pre></td></tr></table></figure><p>B. 下载并解压 source code</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://jaist.dl.sourceforge.net/project/smartmontools/smartmontools/7.4/smartmontools-7.4.tar.gz</span><br><span class="line">tar xvf smartmontools-7.4.tar.gz</span><br></pre></td></tr></table></figure><p>C. 编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> smartmontools-7.4/</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>D. 检查是否成功编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smartctl -v</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机迁移指南</title>
      <link href="/2024/06/30/VM_Migration_Guide_Full/"/>
      <url>/2024/06/30/VM_Migration_Guide_Full/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机迁移指南"><a href="#虚拟机迁移指南" class="headerlink" title="虚拟机迁移指南"></a>虚拟机迁移指南</h1><hr><h2 id="1-确保虚拟机是持久化的"><a href="#1-确保虚拟机是持久化的" class="headerlink" title="1. 确保虚拟机是持久化的"></a>1. 确保虚拟机是持久化的</h2><p>虚拟机必须是持久化的才能进行迁移。如果虚拟机是临时的（transient），需要先将其配置为持久化。</p><h3 id="将临时虚拟机转换为持久化虚拟机"><a href="#将临时虚拟机转换为持久化虚拟机" class="headerlink" title="将临时虚拟机转换为持久化虚拟机"></a>将临时虚拟机转换为持久化虚拟机</h3><p>如果虚拟机是临时的，可以使用以下命令将其转换为持久化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh dumpxml mgtest &gt; /tmp/mgtest.xml</span><br><span class="line">sudo virsh define /tmp/mgtest.xml</span><br></pre></td></tr></table></figure><h2 id="2-在线迁移虚拟机"><a href="#2-在线迁移虚拟机" class="headerlink" title="2. 在线迁移虚拟机"></a>2. 在线迁移虚拟机</h2><h3 id="确保虚拟机磁盘缓存设置为-none-或-directsync"><a href="#确保虚拟机磁盘缓存设置为-none-或-directsync" class="headerlink" title="确保虚拟机磁盘缓存设置为 none 或 directsync"></a>确保虚拟机磁盘缓存设置为 none 或 directsync</h3><p>编辑虚拟机的 XML 配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh edit mgtest</span><br></pre></td></tr></table></figure><p>在 <code>&lt;disk&gt;</code> 部分中添加或修改 <code>&lt;driver&gt;</code> 部分，将 <code>cache</code> 设置为 <code>none</code> 或 <code>directsync</code>，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span> <span class="attr">device</span>=<span class="string">&#x27;disk&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&#x27;qemu&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;qcow2&#x27;</span> <span class="attr">cache</span>=<span class="string">&#x27;none&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&#x27;/mnt/nfs_share/mgtest.qcow2&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;vda&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;virtio&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x04&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br></pre></td></tr></table></figure><p>保存并退出编辑器。</p><h3 id="重启虚拟机"><a href="#重启虚拟机" class="headerlink" title="重启虚拟机"></a>重启虚拟机</h3><p>为了使配置生效，需要重启虚拟机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh shutdown mgtest</span><br><span class="line">sudo virsh start mgtest</span><br></pre></td></tr></table></figure><h3 id="进行在线迁移"><a href="#进行在线迁移" class="headerlink" title="进行在线迁移"></a>进行在线迁移</h3><p>使用以下命令进行在线迁移：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh migrate --live mgtest qemu+ssh://192.168.50.235/system</span><br></pre></td></tr></table></figure><h2 id="3-离线迁移虚拟机"><a href="#3-离线迁移虚拟机" class="headerlink" title="3. 离线迁移虚拟机"></a>3. 离线迁移虚拟机</h2><h3 id="确保虚拟机是持久化的"><a href="#确保虚拟机是持久化的" class="headerlink" title="确保虚拟机是持久化的"></a>确保虚拟机是持久化的</h3><p>如果虚拟机是临时的，可以使用以下命令将其转换为持久化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh dumpxml mgtest &gt; /tmp/mgtest.xml</span><br><span class="line">sudo virsh define /tmp/mgtest.xml</span><br></pre></td></tr></table></figure><h3 id="关闭虚拟机"><a href="#关闭虚拟机" class="headerlink" title="关闭虚拟机"></a>关闭虚拟机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh shutdown mgtest</span><br></pre></td></tr></table></figure><h3 id="进行离线迁移"><a href="#进行离线迁移" class="headerlink" title="进行离线迁移"></a>进行离线迁移</h3><p>执行离线迁移命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh migrate --offline --persistent mgtest qemu+ssh://192.168.50.235/system</span><br></pre></td></tr></table></figure><h2 id="4-示例流程"><a href="#4-示例流程" class="headerlink" title="4. 示例流程"></a>4. 示例流程</h2><h3 id="检查虚拟机状态"><a href="#检查虚拟机状态" class="headerlink" title="检查虚拟机状态"></a>检查虚拟机状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh list --all</span><br></pre></td></tr></table></figure><h3 id="将临时虚拟机转换为持久化（如果需要）"><a href="#将临时虚拟机转换为持久化（如果需要）" class="headerlink" title="将临时虚拟机转换为持久化（如果需要）"></a>将临时虚拟机转换为持久化（如果需要）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh dumpxml mgtest &gt; /tmp/mgtest.xml</span><br><span class="line">sudo virsh define /tmp/mgtest.xml</span><br></pre></td></tr></table></figure><h3 id="关闭虚拟机-1"><a href="#关闭虚拟机-1" class="headerlink" title="关闭虚拟机"></a>关闭虚拟机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh shutdown mgtest</span><br></pre></td></tr></table></figure><h3 id="进行在线迁移-1"><a href="#进行在线迁移-1" class="headerlink" title="进行在线迁移"></a>进行在线迁移</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh migrate --live mgtest qemu+ssh://192.168.50.235/system</span><br></pre></td></tr></table></figure><h3 id="进行离线迁移-1"><a href="#进行离线迁移-1" class="headerlink" title="进行离线迁移"></a>进行离线迁移</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh migrate --offline --persistent mgtest qemu+ssh://192.168.50.235/system</span><br></pre></td></tr></table></figure><h2 id="5-NFS-配置步骤"><a href="#5-NFS-配置步骤" class="headerlink" title="5. NFS 配置步骤"></a>5. NFS 配置步骤</h2><h3 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h3><ol><li><p><strong>安装NFS服务器：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure></li><li><p><strong>创建共享目录：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /srv/nfs_share</span><br><span class="line">sudo <span class="built_in">chown</span> nobody:nogroup /srv/nfs_share</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 /srv/nfs_share</span><br></pre></td></tr></table></figure></li><li><p><strong>配置NFS导出：</strong></p><p>编辑 <code>/etc/exports</code> 文件，添加共享目录的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/exports</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/srv/nfs_share 192.168.50.0/24(rw,sync,no_subtree_check,no_root_squash)</span><br></pre></td></tr></table></figure></li><li><p><strong>导出NFS共享目录：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo exportfs -ra</span><br></pre></td></tr></table></figure></li><li><p><strong>启动并启用NFS服务：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nfs-kernel-server</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> nfs-kernel-server</span><br></pre></td></tr></table></figure></li></ol><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><ol><li><p><strong>安装NFS客户端：</strong></p><p>在两个主机上分别安装NFS客户端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nfs-common</span><br></pre></td></tr></table></figure></li><li><p><strong>创建挂载点目录：</strong></p><p>在两个主机上分别创建挂载点目录，例如 <code>/mnt/nfs_share</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /mnt/nfs_share</span><br></pre></td></tr></table></figure></li><li><p><strong>挂载NFS共享目录：</strong></p><p>在两个主机上分别执行以下命令，将NFS共享目录挂载到本地目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t nfs -o rw 192.168.50.100:/srv/nfs_share /mnt/nfs_share</span><br></pre></td></tr></table></figure></li><li><p><strong>配置自动挂载（可选）：</strong></p><p>为了在系统重启后自动挂载NFS共享目录，可以编辑 <code>/etc/fstab</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/fstab</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.50.100:/srv/nfs_share /mnt/nfs_share nfs defaults 0 0</span><br></pre></td></tr></table></figure></li></ol><h3 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h3><ol><li><p><strong>验证挂载：</strong></p><p>在两个主机上分别执行以下命令，确认NFS共享目录是否成功挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure></li><li><p><strong>测试读写权限：</strong></p><p>在两个主机上分别尝试在挂载的共享目录中创建文件，确保读写权限正常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">touch</span> /mnt/nfs_share/testfile</span><br><span class="line"><span class="built_in">ls</span> -l /mnt/nfs_share/testfile</span><br></pre></td></tr></table></figure></li></ol><p>通过以上步骤，可以配置和验证NFS共享目录，以便在虚拟机迁移过程中使用。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>禁用 Debian 系统的屏幕锁定和自动睡眠</title>
      <link href="/2024/06/30/disable_screen_lock_and_sleep/"/>
      <url>/2024/06/30/disable_screen_lock_and_sleep/</url>
      
        <content type="html"><![CDATA[<h1 id="禁用-Debian-系统的屏幕锁定和自动睡眠"><a href="#禁用-Debian-系统的屏幕锁定和自动睡眠" class="headerlink" title="禁用 Debian 系统的屏幕锁定和自动睡眠"></a>禁用 Debian 系统的屏幕锁定和自动睡眠</h1><p>本文档提供了禁用 Debian 系统屏幕锁定和自动睡眠功能的详细步骤。</p><h2 id="1-禁用屏幕锁定"><a href="#1-禁用屏幕锁定" class="headerlink" title="1. 禁用屏幕锁定"></a>1. 禁用屏幕锁定</h2><p>首先，确保屏幕锁定被禁用。你可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.screensaver lock-enabled <span class="literal">false</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.screensaver idle-activation-enabled <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="2-禁用系统睡眠"><a href="#2-禁用系统睡眠" class="headerlink" title="2. 禁用系统睡眠"></a>2. 禁用系统睡眠</h2><p>要禁用系统的自动睡眠功能，可以通过 <code>systemd</code> 的配置文件来实现。编辑 <code>/etc/systemd/logind.conf</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/logind.conf</span><br></pre></td></tr></table></figure><p>找到并修改以下行：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#HandleLidSwitch=suspend</span></span><br><span class="line"><span class="attr">HandleLidSwitch</span>=ignore</span><br><span class="line"><span class="comment">#HandleLidSwitchDocked=ignore</span></span><br><span class="line"><span class="attr">HandleLidSwitchDocked</span>=ignore</span><br><span class="line"><span class="comment">#HandleSuspendKey=suspend</span></span><br><span class="line"><span class="attr">HandleSuspendKey</span>=ignore</span><br><span class="line"><span class="comment">#HandleHibernateKey=hibernate</span></span><br><span class="line"><span class="attr">HandleHibernateKey</span>=ignore</span><br><span class="line"><span class="comment">#HandleLidSwitchExternalPower=suspend</span></span><br><span class="line"><span class="attr">HandleLidSwitchExternalPower</span>=ignore</span><br><span class="line"><span class="comment">#HandleLidSwitchDockedExternalPower=ignore</span></span><br><span class="line"><span class="attr">HandleLidSwitchDockedExternalPower</span>=ignore</span><br></pre></td></tr></table></figure><p>保存文件并重启 <code>systemd-logind</code> 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart systemd-logind</span><br></pre></td></tr></table></figure><h2 id="3-禁用-GNOME-电源设置中的自动睡眠"><a href="#3-禁用-GNOME-电源设置中的自动睡眠" class="headerlink" title="3. 禁用 GNOME 电源设置中的自动睡眠"></a>3. 禁用 GNOME 电源设置中的自动睡眠</h2><p>打开终端，使用以下命令禁用 GNOME 电源设置中的自动睡眠：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.power sleep-inactive-ac-timeout 0</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.power sleep-inactive-battery-timeout 0</span><br></pre></td></tr></table></figure><h2 id="4-确认配置"><a href="#4-确认配置" class="headerlink" title="4. 确认配置"></a>4. 确认配置</h2><p>再次检查这些配置是否已经生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gsettings get org.gnome.desktop.screensaver lock-enabled</span><br><span class="line">gsettings get org.gnome.desktop.screensaver idle-activation-enabled</span><br><span class="line">gsettings get org.gnome.settings-daemon.plugins.power sleep-inactive-ac-timeout</span><br><span class="line">gsettings get org.gnome.settings-daemon.plugins.power sleep-inactive-battery-timeout</span><br></pre></td></tr></table></figure><h2 id="5-检查日志信息"><a href="#5-检查日志信息" class="headerlink" title="5. 检查日志信息"></a>5. 检查日志信息</h2><p>如果问题依旧存在，请检查系统日志以获取更多信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -xe</span><br></pre></td></tr></table></figure><p>通过以上步骤，你应该能够成功禁用 Debian 系统中的屏幕锁定和自动睡眠功能。如果需要更多帮助，请提供更详细的信息以便进一步排查。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World!</title>
      <link href="/2024/06/30/hello-world/"/>
      <url>/2024/06/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> template </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POST TEMPLATE</title>
      <link href="/2024/06/30/post_template/"/>
      <url>/2024/06/30/post_template/</url>
      
        <content type="html"><![CDATA[<p>写法解释<br>title【必需】文章标题<br>date【必需】文章创建日期<br>updated【可选】文章更新日期<br>tags【可选】文章标签<br>categories【可选】文章分类<br>keywords【可选】文章关键字<br>description【可选】文章描述<br>top_img【可选】文章顶部图片<br>cover【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false&#x2F;图片地址&#x2F;留空)<br>comments【可选】显示文章评论模块(默认 true)<br>toc【可选】显示文章TOC(默认为设置中toc的enable配置)<br>toc_number【可选】显示toc_number(默认为设置中toc的number配置)<br>toc_style_simple【可选】显示 toc 简洁模式<br>copyright【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)<br>copyright_author【可选】文章版权模块的文章作者<br>copyright_author_href【可选】文章版权模块的文章作者链接<br>copyright_url【可选】文章版权模块的文章连结链接<br>copyright_info【可选】文章版权模块的版权声明文字<br>mathjax【可选】显示mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false )<br>katex【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false )<br>aplayer【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置<br>highlight_shrink【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中 highlight_shrink 的配置)<br>aside【可选】显示侧边栏 (默认 true)<br>abcjs【可选】加载 abcjs (当设置 abcjs 的 per_page: false 时，才需要配置，默认 false )</p><p>作者: Jerry<br>連結: <a href="https://butterfly.js.org/posts/dc584b87/#Post-Front-matter">https://butterfly.js.org/posts/dc584b87/#Post-Front-matter</a><br>來源: Butterfly<br>著作權歸作者所有。商業轉載請聯繫作者獲得授權，非商業轉載請註明出處。</p>]]></content>
      
      
      
        <tags>
            
            <tag> template </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Template</title>
      <link href="/2024/06/28/README/"/>
      <url>/2024/06/28/README/</url>
      
        <content type="html"><![CDATA[<img src="https://raw.githubusercontent.com/hexojs/logo/master/hexo-logo-avatar.png" alt="Hexo logo" width="100" height="100" align="right" /><h1 id="Hexo-Template"><a href="#Hexo-Template" class="headerlink" title="Hexo Template"></a>Hexo Template</h1><blockquote><p>A fast, simple &amp; powerful blog framework, powered by <a href="https://nodejs.org/">Node.js</a>. Here is the template of it.</p></blockquote><p><a href="https://mmdjiji.github.io/hexo-template">Demo</a> |<br><a href="https://hexo.io/">Official Website</a> |<br><a href="https://hexo.io/docs/">Documentation</a> |<br><a href="https://github.com/mmdjiji/hexo-template">GitHub</a></p><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><p>There are two lines to modify in <code>_config.yml</code>:</p><ol><li><p>Set your site url at <strong>line 16</strong>. For example, if you use GitHub Page, set url as <code>https://username.github.io/project</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://jiji.pro/hexo-template</span></span><br></pre></td></tr></table></figure></li><li><p>Set your project name at <strong>line 107</strong>, if your project name is <code>username</code> or <code>username.github.io</code>, just remove it at the end of <code>_config.yml</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">root:</span> <span class="string">/hexo-template</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h2><p>This repository uses GitHub Actions for CI&#x2F;CD. You don’t need to build your documents manually. Just commit your documents (then run <code>git push</code>), and then turn on the GitHub Pages in the settings to access your online documents. (For this demo is <a href="https://mmdjiji.github.io/hexo-template">https://mmdjiji.github.io/hexo-template</a>)</p><h2 id="Hexo-Features"><a href="#Hexo-Features" class="headerlink" title="Hexo Features"></a>Hexo Features</h2><ul><li>Blazing fast generating</li><li>Support for GitHub Flavored Markdown and most Octopress plugins</li><li>One-command deploy to GitHub Pages, Heroku, etc.</li><li>Powerful API for limitless extensibility</li><li>Hundreds of <a href="https://hexo.io/themes/">themes</a> &amp; <a href="https://hexo.io/plugins/">plugins</a></li></ul><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><p><strong>Install Hexo</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>Install with <a href="https://brew.sh/">brew</a> on macOS and Linux:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install hexo</span><br></pre></td></tr></table></figure><p><strong>Setup your blog</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br></pre></td></tr></table></figure><p><strong>Start the server</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p><strong>Create a new post</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;Hello Hexo&quot;</span></span><br></pre></td></tr></table></figure><p><strong>Generate static files</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h2 id="More-Information"><a href="#More-Information" class="headerlink" title="More Information"></a>More Information</h2><ul><li>Read the <a href="https://hexo.io/">documentation</a></li><li>Visit the <a href="https://github.com/hexojs/awesome-hexo">Awesome Hexo</a> list</li><li>Find solutions in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a></li><li>Join discussion on <a href="https://groups.google.com/group/hexo">Google Group</a>, <a href="https://discord.gg/teM2Anj">Discord</a>, <a href="https://gitter.im/hexojs/hexo">Gitter</a> or <a href="https://t.me/hexojs">Telegram</a></li><li>See the <a href="https://hexo.io/plugins/">plugin list</a> and the <a href="https://hexo.io/themes/">theme list</a> on wiki</li><li>Follow <a href="https://twitter.com/hexojs">@hexojs</a> for latest news</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Follows <a href="https://github.com/hexojs/hexo">hexojs&#x2F;hexo</a> , use <a href="LICENSE">MIT License</a>.</p><p><a href="https://app.fossa.com/projects/git%2Bgithub.com%2Fhexojs%2Fhexo?ref=badge_large"><img src="https://app.fossa.com/api/projects/git%2Bgithub.com%2Fhexojs%2Fhexo.svg?type=large" alt="FOSSA Status"></a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Template </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
