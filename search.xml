<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PCIe高级错误报告</title>
      <link href="/2024/10/31/pcie_aer/"/>
      <url>/2024/10/31/pcie_aer/</url>
      
        <content type="html"><![CDATA[<h1 id="PCIe高级错误报告（AER）"><a href="#PCIe高级错误报告（AER）" class="headerlink" title="PCIe高级错误报告（AER）"></a>PCIe高级错误报告（AER）</h1><p>PCIe（Peripheral Component Interconnect Express）高级错误报告（AER）是一种机制，用于监控和报告在PCIe设备和链路上发生的错误。AER旨在提供更详细的错误信息，从而帮助工程师快速识别和解决问题。</p><h2 id="AER-的主要功能"><a href="#AER-的主要功能" class="headerlink" title="AER 的主要功能"></a>AER 的主要功能</h2><ol><li><strong>错误检测</strong>：实时监测PCIe设备中的错误情况。</li><li><strong>错误报告</strong>：通过状态寄存器报告不同类型的错误。</li><li><strong>错误处理</strong>：支持自动或手动错误恢复机制。</li></ol><h2 id="AER-寄存器"><a href="#AER-寄存器" class="headerlink" title="AER 寄存器"></a>AER 寄存器</h2><p>AER通过几个关键寄存器来实现其功能：</p><ol><li><p><strong>UESta（不可校正错误状态寄存器）</strong>：</p><ul><li><p>指示发生的不可校正错误类型，包括多个错误类型的位域。</p></li><li><p><strong>功能</strong>：用于指示不可校正错误的状态。</p></li><li><p><strong>寄存器字段</strong>：</p><ul><li><strong>Bit 0</strong>：<strong>不可校正错误检测</strong>。设置为1表示检测到不可校正错误。</li><li><strong>Bit 1</strong>：<strong>事务层超时</strong>。表示事务层操作超时。</li><li><strong>Bit 2</strong>：<strong>接收器溢出</strong>。指示接收器缓冲区溢出。</li><li><strong>Bit 3</strong>：<strong>格式错误的TLP</strong>。表示收到格式错误的事务层包（TLP）。</li><li><strong>Bit 4</strong>：<strong>ECRC错误</strong>。指示外部循环冗余校验失败。</li><li><strong>Bit 5</strong>：<strong>不支持的请求</strong>。表示收到不支持的请求类型。</li><li><strong>Bit 6</strong>：<strong>AER不可校正错误</strong>。通过AER报告的不可校正错误。</li></ul></li><li><p>示例：<code>UESta: DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-</code> 表示当前没有检测到不可校正错误。</p></li></ul></li><li><p><strong>UEMsk（不可校正错误掩码寄存器）</strong>：</p><ul><li><p>控制哪些不可校正错误被掩码（忽略）。</p></li><li><p><strong>功能</strong>：控制哪些不可校正错误可以被报告。</p></li><li><p><strong>寄存器字段</strong>：</p><ul><li><strong>Bit 0</strong>：<strong>不可校正错误掩码</strong>。设置为1表示掩码此类错误。</li><li><strong>Bit 1</strong>：<strong>事务层超时掩码</strong>。</li><li><strong>Bit 2</strong>：<strong>接收器溢出掩码</strong>。</li><li><strong>Bit 3</strong>：<strong>格式错误的TLP掩码</strong>。</li><li><strong>Bit 4</strong>：<strong>ECRC错误掩码</strong>。</li><li><strong>Bit 5</strong>：<strong>不支持的请求错误掩码</strong>。</li></ul></li><li><p>示例：<code>UEMsk: DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-</code> 表示没有错误被掩码，所有不可校正错误均可报告。</p></li></ul></li><li><p><strong>UESvrt（不可校正错误服务寄存器）</strong>：</p><ul><li>指示哪些不可校正错误已被处理。</li><li>示例：<code>UESvrt: DLP+ SDES+ TLP- FCP+</code> 表示DLP和FCP错误已被处理。</li></ul></li><li><p><strong>CESta（可校正错误状态寄存器）</strong>：</p><ul><li><p>指示发生的可校正错误类型。</p></li><li><p><strong>功能</strong>：用于报告可校正错误的状态。</p></li><li><p><strong>寄存器字段</strong>：</p><ul><li><strong>Bit 0</strong>：<strong>可校正错误检测</strong>。设置为1表示检测到可校正错误。</li><li><strong>Bit 1</strong>：<strong>数据链路层可校正错误</strong>。</li><li><strong>Bit 2</strong>：<strong>重播超时错误</strong>。</li><li><strong>Bit 3</strong>：<strong>接收错误</strong>。</li><li><strong>Bit 4</strong>：<strong>格式错误的TLP</strong>。</li><li><strong>Bit 5</strong>：<strong>ECRC错误</strong>。</li><li><strong>Bit 6</strong>：<strong>不支持的请求错误</strong>。</li></ul></li><li><p>示例：<code>CESta: RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr-</code> 表示当前没有可校正错误被检测到。</p></li></ul></li><li><p><strong>CEMsk（可校正错误掩码寄存器）</strong>：</p><ul><li><p>控制哪些可校正错误被掩码。</p></li><li><p><strong>功能</strong>：控制哪些可校正错误可以被报告。</p></li><li><p><strong>寄存器字段</strong>：</p><ul><li><strong>Bit 0</strong>：<strong>可校正错误掩码</strong>。设置为1表示掩码此类错误。</li><li><strong>Bit 1</strong>：<strong>数据链路层错误掩码</strong>。</li><li><strong>Bit 2</strong>：<strong>重播超时错误掩码</strong>。</li><li><strong>Bit 3</strong>：<strong>接收错误掩码</strong>。</li><li><strong>Bit 4</strong>：<strong>格式错误的TLP掩码</strong>。</li><li><strong>Bit 5</strong>：<strong>ECRC错误掩码</strong>。</li></ul></li><li><p>示例：<code>CEMsk: RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+</code> 表示所有可校正错误均可报告，但<code>AdvNonFatalErr</code>将被掩码。</p></li></ul></li><li><p><strong>AERCap（AER能力寄存器）</strong>：</p><ul><li>提供设备支持的AER功能的详细信息，如ECRC生成和检查能力。</li><li>示例：<code>AERCap: First Error Pointer: 00, ECRCGenCap+ ECRCGenEn-</code> 表示设备支持ECRC生成但未启用。</li></ul></li><li><p><strong>HeaderLog（头部日志）</strong>：</p><ul><li>用于记录错误的日志，帮助故障排查。</li><li>示例：<code>HeaderLog: 00000000 00000000 00000000 00000000</code> 表示当前没有错误日志。</li></ul></li><li><p><strong>RootCmd（根命令寄存器）</strong>：</p><ul><li>控制根复杂设备的错误报告功能。</li><li>示例：<code>RootCmd: CERptEn+ NFERptEn+ FERptEn+</code> 表示所有错误报告功能已启用。</li></ul></li><li><p><strong>RootSta（根状态寄存器）</strong>：</p><ul><li>显示接收到的错误消息的状态。</li><li>示例：<code>RootSta: CERcvd- MultCERcvd- UERcvd-</code> 表示没有接收到错误消息。</li></ul></li><li><p><strong>ErrorSrc（错误源寄存器）</strong>：</p><ul><li>指示当前的错误来源，包括可校正和不可校正错误。</li><li>示例：<code>ErrorSrc: ERR_COR: 0000 ERR_FATAL/NONFATAL: 0000</code> 表示没有检测到可校正或不可校正错误来源。</li></ul></li></ol><h2 id="常见错误类型"><a href="#常见错误类型" class="headerlink" title="常见错误类型"></a>常见错误类型</h2><p>在AER报告中，错误类型通常以缩写形式列出，具体包括：</p><ol><li><p><strong>DLP</strong> (Data Link Protocol Error)</p><ul><li>指数据链路层协议错误，这类错误通常是由于数据包在传输过程中未能成功到达目标。</li></ul></li><li><p><strong>SDES</strong> (Surprise Down Error Status)</p><ul><li>表示突发断开错误状态，通常是由于设备突然失去连接或出现故障引起的。</li></ul></li><li><p><strong>TLP</strong> (Transaction Layer Protocol Error)</p><ul><li>指事务层协议错误，通常涉及到数据包的事务处理过程中的错误。</li></ul></li><li><p><strong>FCP</strong> (Flow Control Protocol Error)</p><ul><li>指流控制协议错误，这种错误可能发生在流控制机制出现问题时，例如未能正确地发送或接收流控制信号。</li></ul></li><li><p><strong>CmpltTO</strong> (Completion Timeout)</p><ul><li>表示完成超时，通常是指在规定时间内未能收到请求的操作的完成响应。</li></ul></li><li><p><strong>CmpltAbrt</strong> (Completion Aborted)</p><ul><li>指完成操作被中止，可能由于设备错误或其他原因导致请求未能成功完成。</li></ul></li><li><p><strong>UnxCmplt</strong> (Unexpected Completion)</p><ul><li>表示意外的完成，通常是指收到的完成包与发出的请求不匹配。</li></ul></li><li><p><strong>RxOF</strong> (Receive Overflow)</p><ul><li>表示接收溢出，通常发生在接收缓冲区已满但仍尝试接收更多数据时。</li></ul></li><li><p><strong>MalfTLP</strong> (Malformed TLP)</p><ul><li>指格式错误的事务层包（TLP），这通常意味着包的结构不符合协议规范。</li></ul></li><li><p><strong>ECRC</strong> (ECRC Error)</p><ul><li>指ECRC（End-to-End CRC）错误，这是数据完整性检查的一部分，当发现数据传输错误时会触发。</li></ul></li><li><p><strong>UnsupReq</strong> (Unsupported Request)</p><ul><li>表示收到不支持的请求，可能是因为设备不支持该请求的类型或参数。</li></ul></li><li><p><strong>ACSViol</strong> (Access Control Service Violation)</p><ul><li>指访问控制服务违规，通常涉及安全或权限问题，表示某个操作未能遵循预定义的访问控制规则。</li></ul></li></ol><h2 id="错误处理流程"><a href="#错误处理流程" class="headerlink" title="错误处理流程"></a>错误处理流程</h2><p>AER机制的有效性依赖于对寄存器的监控与响应，以下是一个典型的错误处理流程：</p><h3 id="步骤-1：检测错误"><a href="#步骤-1：检测错误" class="headerlink" title="步骤 1：检测错误"></a>步骤 1：检测错误</h3><p>使用<code>lspci</code>命令查看设备的错误状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -vvv -s &lt;device_id&gt;</span><br></pre></td></tr></table></figure><p>在输出中，查找<code>CESta</code>和<code>CEMsk</code>、<code>UESta</code>和<code>UEMsk</code>部分。</p><h3 id="步骤-2：分析寄存器状态"><a href="#步骤-2：分析寄存器状态" class="headerlink" title="步骤 2：分析寄存器状态"></a>步骤 2：分析寄存器状态</h3><ul><li><strong>CESta</strong>：检查哪些可校正错误被检测到。</li><li><strong>CEMsk</strong>：检查哪些可校正错误被掩码。</li><li><strong>UESta</strong>：检查哪些不可校正错误被检测到。</li><li><strong>UEMsk</strong>：检查哪些不可校正错误被掩码。</li></ul><h3 id="步骤-3：判断和响应"><a href="#步骤-3：判断和响应" class="headerlink" title="步骤 3：判断和响应"></a>步骤 3：判断和响应</h3><ul><li><p><strong>对于可校正错误</strong>：</p><ul><li>如果<code>CESta</code>中的位为1且<code>CEMsk</code>中的对应位为0，表示该可校正错误被检测到并会被报告。可以考虑记录该错误并分析原因。</li><li>如果<code>CEMsk</code>中的位为1，表示该错误被掩码，主机不会报告。可以根据需求决定是否解除掩码。</li></ul></li><li><p><strong>对于不可校正错误</strong>：</p><ul><li>如果<code>UESta</code>中的位为1且<code>UEMsk</code>中的对应位为0，表示检测到不可校正错误并将被报告。这通常需要更紧急的响应，例如设备重置或硬件检查。</li><li>如果<code>UEMsk</code>中的位为1，表示该错误被掩码，不会被报告。此时可以考虑是否需要调整掩码设置以捕获重要的错误信息。</li></ul></li></ul><h2 id="使用-lspci-检查-AER-状态"><a href="#使用-lspci-检查-AER-状态" class="headerlink" title="使用 lspci 检查 AER 状态"></a>使用 <code>lspci</code> 检查 AER 状态</h2><p>可以使用<code>lspci</code>命令来查看PCIe设备的AER状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -vvv -s &lt;device_id&gt;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="AER-状态分析"><a href="#AER-状态分析" class="headerlink" title="AER 状态分析"></a>AER 状态分析</h3><h4 id="1-AER-能力（Capabilities）"><a href="#1-AER-能力（Capabilities）" class="headerlink" title="1. AER 能力（Capabilities）"></a>1. AER 能力（Capabilities）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Capabilities: [100 v2] Advanced Error Reporting</span><br></pre></td></tr></table></figure><ul><li>这表示设备支持AER，并且是版本2。</li></ul><h4 id="2-不可校正错误状态寄存器（UESta）"><a href="#2-不可校正错误状态寄存器（UESta）" class="headerlink" title="2. 不可校正错误状态寄存器（UESta）"></a>2. 不可校正错误状态寄存器（UESta）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UESta:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-</span><br></pre></td></tr></table></figure><ul><li>此寄存器用于指示是否检测到不可校正错误。</li><li><code>DLP-</code>、<code>SDES-</code>等前面的<code>-</code>表示这些错误类型未被检测到。</li><li>所有项均未设置，表示当前没有不可校正错误。</li></ul><h4 id="3-不可校正错误掩码寄存器（UEMsk）"><a href="#3-不可校正错误掩码寄存器（UEMsk）" class="headerlink" title="3. 不可校正错误掩码寄存器（UEMsk）"></a>3. 不可校正错误掩码寄存器（UEMsk）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UEMsk:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-</span><br></pre></td></tr></table></figure><ul><li>此寄存器控制哪些不可校正错误被掩码。</li><li>同样，所有项前的<code>-</code>表示没有错误被掩码，所有不可校正错误均可报告。</li></ul><h4 id="4-不可校正错误源寄存器（UESvrt）"><a href="#4-不可校正错误源寄存器（UESvrt）" class="headerlink" title="4. 不可校正错误源寄存器（UESvrt）"></a>4. 不可校正错误源寄存器（UESvrt）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UESvrt: DLP+ SDES+ TLP- FCP+ CmpltTO- CmpltAbrt- UnxCmplt- RxOF+ MalfTLP+ ECRC- UnsupReq- ACSViol-</span><br></pre></td></tr></table></figure><ul><li>此寄存器表示哪些不可校正错误被服务。</li><li><code>DLP+</code>、<code>FCP+</code>、<code>RxOF+</code>、<code>MalfTLP+</code>表示这些错误类型已被服务（即被处理）。</li><li>其他项未被服务，表示没有检测到这些类型的错误。</li></ul><h4 id="5-可校正错误状态寄存器（CESta）"><a href="#5-可校正错误状态寄存器（CESta）" class="headerlink" title="5. 可校正错误状态寄存器（CESta）"></a>5. 可校正错误状态寄存器（CESta）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CESta:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr-</span><br></pre></td></tr></table></figure><ul><li>该寄存器显示检测到的可校正错误状态。</li><li>所有项均为<code>-</code>，表示当前没有可校正错误被检测到。</li></ul><h4 id="6-可校正错误掩码寄存器（CEMsk）"><a href="#6-可校正错误掩码寄存器（CEMsk）" class="headerlink" title="6. 可校正错误掩码寄存器（CEMsk）"></a>6. 可校正错误掩码寄存器（CEMsk）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CEMsk:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+</span><br></pre></td></tr></table></figure><ul><li>此寄存器控制哪些可校正错误被掩码。</li><li>除了<code>AdvNonFatalErr+</code>外，其他项均为<code>-</code>，表示所有其他类型的可校正错误将被报告。</li></ul><h4 id="7-AER-能力寄存器（AERCap）"><a href="#7-AER-能力寄存器（AERCap）" class="headerlink" title="7. AER 能力寄存器（AERCap）"></a>7. AER 能力寄存器（AERCap）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AERCap: First Error Pointer: 00, ECRCGenCap+ ECRCGenEn- ECRCChkCap+ ECRCChkEn-</span><br><span class="line">        MultHdrRecCap+ MultHdrRecEn- TLPPfxPres- HdrLogCap-</span><br></pre></td></tr></table></figure><ul><li><strong>First Error Pointer</strong>: 00 — 表示最近的错误指针位置。</li><li><strong>ECRCGenCap+</strong>: 支持生成ECRC。</li><li><strong>ECRCGenEn-</strong>: 生成ECRC功能未启用。</li><li><strong>ECRCChkCap+</strong>: 支持ECRC检查。</li><li><strong>ECRCChkEn-</strong>: ECRC检查功能未启用。</li><li><strong>MultHdrRecCap+</strong>: 支持多个头部接收。</li><li><strong>MultHdrRecEn-</strong>: 多个头部接收功能未启用。</li><li><strong>TLPPfxPres</strong>: 事务层前缀保留功能。</li><li><strong>HdrLogCap-</strong>: 头部日志能力未启用。</li></ul><h4 id="8-头部日志（HeaderLog）"><a href="#8-头部日志（HeaderLog）" class="headerlink" title="8. 头部日志（HeaderLog）"></a>8. 头部日志（HeaderLog）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HeaderLog: 00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure><ul><li>头部日志显示为零，表示没有错误日志可用。</li></ul><h4 id="9-根命令（RootCmd）"><a href="#9-根命令（RootCmd）" class="headerlink" title="9. 根命令（RootCmd）"></a>9. 根命令（RootCmd）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RootCmd: CERptEn+ NFERptEn+ FERptEn+</span><br></pre></td></tr></table></figure><ul><li>指示根命令的错误报告功能均已启用（CERptEn、NFERptEn、FERptEn）。</li></ul><h4 id="10-根状态（RootSta）"><a href="#10-根状态（RootSta）" class="headerlink" title="10. 根状态（RootSta）"></a>10. 根状态（RootSta）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RootSta: CERcvd- MultCERcvd- UERcvd- MultUERcvd-</span><br><span class="line">         FirstFatal- NonFatalMsg- FatalMsg- IntMsg 0</span><br></pre></td></tr></table></figure><ul><li>这些字段指示各种错误状态。当前无错误被接收（CERcvd-、UERcvd-）。</li></ul><h4 id="11-错误源（ErrorSrc）"><a href="#11-错误源（ErrorSrc）" class="headerlink" title="11. 错误源（ErrorSrc）"></a>11. 错误源（ErrorSrc）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ErrorSrc: ERR_COR: 0000 ERR_FATAL/NONFATAL: 0000</span><br></pre></td></tr></table></figure><ul><li>表示当前没有可校正错误和不可校正错误来源。</li></ul><h3 id="示例分析1"><a href="#示例分析1" class="headerlink" title="示例分析1"></a>示例分析1</h3><p>假设读取到的寄存器状态如下：</p><ul><li><code>CESta</code>: <code>00000111</code>（可校正错误位0、1和2被设置）</li><li><code>CEMsk</code>: <code>00000001</code>（可校正错误掩码位0被设置）</li><li><code>UESta</code>: <code>00000001</code>（不可校正错误位0被设置）</li><li><code>UEMsk</code>: <code>00000000</code>（不可校正错误掩码位0未设置）</li></ul><p><strong>分析</strong>：</p><ul><li><p><strong>可校正错误</strong>：</p><ul><li><code>CESta</code>中的Bit 0（可校正错误检测）为1，表示检测到可校正错误，但由于<code>CEMsk</code>中对应位为1，因此不会报告。</li><li><code>CESta</code>中的Bit 1和2为1，表示数据链路层可校正错误和重播超时错误被检测到，且<code>CEMsk</code>中的对应位均为0，这些错误将被报告。</li></ul></li><li><p><strong>不可校正错误</strong>：</p><ul><li><code>UESta</code>中的Bit 0（不可校正错误检测）为1且<code>UEMsk</code>中对应位为0，表示检测到不可校正错误并将被报告。这需要立即关注和处理。</li></ul></li></ul><h3 id="示例分析2"><a href="#示例分析2" class="headerlink" title="示例分析2"></a>示例分析2</h3><p>假设运行<code>lspci -vvv -s 00:1f.6</code>，得到以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Capabilities: [100 v2] Advanced Error Reporting</span><br><span class="line">    UESta:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-</span><br><span class="line">    UEMsk:  DLP- SDES- TLP- FCP- CmpltTO- CmpltAbrt- UnxCmplt- RxOF- MalfTLP- ECRC- UnsupReq- ACSViol-</span><br><span class="line">    CESta:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr-</span><br><span class="line">    CEMsk:  RxErr- BadTLP- BadDLLP- Rollover- Timeout- AdvNonFatalErr+</span><br><span class="line">    AERCap: First Error Pointer: 00, ECRCGenCap+ ECRCGenEn- ECRCChkCap+ ECRCChkEn-</span><br><span class="line">            MultHdrRecCap+ MultHdrRecEn- TLPPfxPres- HdrLogCap-</span><br><span class="line">    HeaderLog: 00000000 00000000 00000000 00000000</span><br><span class="line">    RootCmd: CERptEn+ NFERptEn+ FERptEn+</span><br><span class="line">    RootSta: CERcvd- MultCERcvd- UERcvd- MultUERcvd-</span><br><span class="line">             FirstFatal- NonFatalMsg- FatalMsg- IntMsg 0</span><br><span class="line">    ErrorSrc: ERR_COR: 0000 ERR_FATAL/NONFATAL: 0000</span><br></pre></td></tr></table></figure><ul><li><strong>UESta</strong>：无不可校正错误。</li><li><strong>UEMsk</strong>：所有不可校正错误可报告。</li><li><strong>CESta</strong>：无可校正错误。</li><li><strong>CEMsk</strong>：大部分可校正错误可报告。</li><li><strong>AERCap</strong>：显示支持的AER功能，如ECRC。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PCIe AER是一个强大的工具，用于检测和报告PCIe设备的错误。通过监控AER寄存器，能够及时发现和处理潜在的问题，确保系统的稳定性和性能。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> AER </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux搭建HTTP代理服务器</title>
      <link href="/2024/10/31/proxy_server_setup/"/>
      <url>/2024/10/31/proxy_server_setup/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux搭建HTTP代理服务器"><a href="#Linux搭建HTTP代理服务器" class="headerlink" title="Linux搭建HTTP代理服务器"></a>Linux搭建HTTP代理服务器</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在 Ubuntu 和 RHEL 系统上搭建代理服务器并配置防火墙，以确保网络安全和访问控制。本文主要使用 Squid 作为代理服务器软件，并使用 UFW（Ubuntu）和 firewalld（RHEL）来管理防火墙。</p><h2 id="2-范围"><a href="#2-范围" class="headerlink" title="2. 范围"></a>2. 范围</h2><p>适用于希望通过代理服务器安全地访问互联网的用户和组织，适合 Ubuntu 和 RHEL 系统。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>系统管理员</strong>：负责安装和配置代理服务器及防火墙，确保其安全性和正常运行。</li><li><strong>用户</strong>：负责通过代理服务器访问互联网，并遵循公司网络安全政策。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>具备 Ubuntu 或 RHEL 操作系统的服务器或计算机。</li><li>具备管理员权限。</li></ul><h2 id="5-过程"><a href="#5-过程" class="headerlink" title="5. 过程"></a>5. 过程</h2><h3 id="步骤-1-更新系统"><a href="#步骤-1-更新系统" class="headerlink" title="步骤 1: 更新系统"></a>步骤 1: 更新系统</h3><p>在终端中运行以下命令以确保系统软件包是最新的：</p><ul><li><p><strong>Ubuntu</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade -y</span><br></pre></td></tr></table></figure></li><li><p><strong>RHEL</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update -y</span><br></pre></td></tr></table></figure></li></ul><h3 id="步骤-2-安装-Squid"><a href="#步骤-2-安装-Squid" class="headerlink" title="步骤 2: 安装 Squid"></a>步骤 2: 安装 Squid</h3><p>在终端中运行以下命令以安装 Squid：</p><ul><li><p><strong>Ubuntu</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install squid -y</span><br></pre></td></tr></table></figure></li><li><p><strong>RHEL</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install squid -y</span><br></pre></td></tr></table></figure></li></ul><h3 id="步骤-3-配置-Squid"><a href="#步骤-3-配置-Squid" class="headerlink" title="步骤 3: 配置 Squid"></a>步骤 3: 配置 Squid</h3><ol><li>编辑 Squid 配置文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/squid/squid.conf</span><br></pre></td></tr></table></figure></li><li>配置访问控制列表（ACL）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acl localnet src 192.168.1.0/24  # 适配局域网IP段</span><br><span class="line">http_access allow localnet</span><br><span class="line">http_access deny all</span><br></pre></td></tr></table></figure></li><li>设置代理端口（默认为 3128）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_port 3128</span><br></pre></td></tr></table></figure></li></ol><h3 id="步骤-4-安装和配置防火墙"><a href="#步骤-4-安装和配置防火墙" class="headerlink" title="步骤 4: 安装和配置防火墙"></a>步骤 4: 安装和配置防火墙</h3><ul><li><p><strong>Ubuntu 使用 UFW</strong>:</p><ol><li>安装 UFW（如果未安装）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ufw -y</span><br></pre></td></tr></table></figure></li><li>允许通过代理端口访问：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 3128/tcp</span><br></pre></td></tr></table></figure></li><li>启用 UFW：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure></li><li>检查 UFW 状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure></li></ol></li><li><p><strong>RHEL 使用 firewalld</strong>:</p><ol><li>启用 firewalld：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start firewalld</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> firewalld</span><br></pre></td></tr></table></figure></li><li>允许通过代理端口访问：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=3128/tcp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li>检查 firewalld 状态：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --state</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="步骤-5-重启-Squid-服务"><a href="#步骤-5-重启-Squid-服务" class="headerlink" title="步骤 5: 重启 Squid 服务"></a>步骤 5: 重启 Squid 服务</h3><p>在修改配置后，重启 Squid 以应用更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart squid</span><br></pre></td></tr></table></figure><h3 id="步骤-6-检查-Squid-状态"><a href="#步骤-6-检查-Squid-状态" class="headerlink" title="步骤 6: 检查 Squid 状态"></a>步骤 6: 检查 Squid 状态</h3><p>确保 Squid 正在运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status squid</span><br></pre></td></tr></table></figure><h3 id="步骤-7-配置客户端"><a href="#步骤-7-配置客户端" class="headerlink" title="步骤 7: 配置客户端"></a>步骤 7: 配置客户端</h3><p>在客户端计算机上，将网络代理设置为服务器的 IP 地址和配置的端口（例如，<code>http://&lt;server-ip&gt;:3128</code>）。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://cybrix.ai/workflow_diagrams/static/a444ca81-4fd1-4550-8fa9-876bb5205063.png" alt="代理服务器搭建流程图"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Proxy </tag>
            
            <tag> Squid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Linux上使用 `grep`</title>
      <link href="/2024/10/21/linux_grep_command/"/>
      <url>/2024/10/21/linux_grep_command/</url>
      
        <content type="html"><![CDATA[<h1 id="在Linux上使用-grep"><a href="#在Linux上使用-grep" class="headerlink" title="在Linux上使用 grep"></a>在Linux上使用 <code>grep</code></h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p><code>grep</code> 是一个强大的命令行工具，用于搜索文件中的文本模式。通过使用正则表达式，用户可以高效地查找和过滤数据。</p><h2 id="2-范围"><a href="#2-范围" class="headerlink" title="2. 范围"></a>2. 范围</h2><p>适用于需要处理和分析文本数据的用户，包括系统管理员、开发人员和数据分析师。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>用户</strong>：进行 <code>grep</code> 的使用和操作。</li><li><strong>系统管理员</strong>：负责维护系统环境，确保 <code>grep</code> 工具可用。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>系统需安装 Unix&#x2F;Linux 或者支持 <code>grep</code> 命令的环境。</li><li>基础的命令行操作知识。</li></ul><h2 id="5-过程"><a href="#5-过程" class="headerlink" title="5. 过程"></a>5. 过程</h2><h3 id="5-1-基本用法"><a href="#5-1-基本用法" class="headerlink" title="5.1 基本用法"></a>5.1 基本用法</h3><p>使用 <code>grep</code> 命令的基本语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] <span class="string">&#x27;模式&#x27;</span> 文件名</span><br></pre></td></tr></table></figure><h3 id="5-2-常见选项及示例"><a href="#5-2-常见选项及示例" class="headerlink" title="5.2 常见选项及示例"></a>5.2 常见选项及示例</h3><ol><li><p><strong>忽略大小写</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i <span class="string">&#x27;hello&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>反向匹配</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v <span class="string">&#x27;hello&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>递归搜索</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r <span class="string">&#x27;hello&#x27;</span> /path/to/directory/</span><br></pre></td></tr></table></figure></li><li><p><strong>显示行号</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n <span class="string">&#x27;hello&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>列出文件名</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -l <span class="string">&#x27;hello&#x27;</span> *.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>统计匹配行数</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -c <span class="string">&#x27;hello&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>仅显示匹配部分</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -o <span class="string">&#x27;hello&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>高亮匹配部分</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep --color <span class="string">&#x27;hello&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p><strong>使用扩展正则表达式</strong>：<br>使用 <code>-E</code> 选项可启用扩展正则表达式，支持更复杂的匹配。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;hello|world&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><p><code>-E</code> 参数用于启用扩展正则表达式（ERE），使得可以使用更多复杂的匹配模式。与基本正则表达式（BRE）相比，扩展正则表达式支持更多的元字符和语法简化。</p><p>9.1. <strong>扩展正则表达式的特点</strong></p><ul><li><strong>无需转义的元字符</strong>：在扩展正则表达式中，一些元字符（如 <code>+</code>, <code>?</code>, <code>|</code>, <code>&#123;&#125;</code>）可以直接使用，而不需要用 <code>\</code> 转义。</li></ul><p>9.2. 常见的元字符</p><ul><li><code>|</code>：表示“或”操作符。</li><li><code>+</code>：表示前面的字符可以出现一次或多次。</li><li><code>?</code>：表示前面的字符可以出现零次或一次。</li><li><code>&#123;n&#125;</code>：表示前面的字符出现精确的 n 次。</li><li><code>&#123;n,&#125;</code>：表示前面的字符出现至少 n 次。</li><li><code>&#123;n,m&#125;</code>：表示前面的字符出现 n 次到 m 次。</li></ul><p>9.3. 使用示例</p><ol><li><p><strong>匹配多个词</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;cat|dog&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><p>这将匹配文件中包含“cat”或“dog”的行。</p></li><li><p><strong>匹配一个或多个字符</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;he+llo&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><p>这将匹配“hello”， “heeeeeello”等。</p></li><li><p><strong>匹配可选字符</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;colou?r&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><p>这将匹配“color”或“colour”。</p></li><li><p><strong>使用花括号指定数量</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;a&#123;2,5&#125;&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><p>这将匹配包含两个到五个连续“a”的行，如“aa”，“aaa”，“aaaa”，“aaaaa”。</p></li><li><p><strong>组合使用</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">&#x27;^[A-Z]+|[0-9]&#123;3&#125;$&#x27;</span> file.txt</span><br></pre></td></tr></table></figure><p>这将匹配以大写字母开头的行或以三个数字结尾的行。</p></li></ol></li></ol><h3 id="5-3-使用正则表达式"><a href="#5-3-使用正则表达式" class="headerlink" title="5.3 使用正则表达式"></a>5.3 使用正则表达式</h3><p><code>grep</code> 支持基本和扩展的正则表达式，可以进行复杂的匹配：</p><ul><li><strong>匹配任意单个字符</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;h.llo&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><strong>匹配零个或多个字符</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;he*llo&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><strong>匹配行的开头</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;^hello&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li><li><strong>匹配行的结尾</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;hello$&#x27;</span> file.txt</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-4-管道与-grep"><a href="#5-4-管道与-grep" class="headerlink" title="5.4 管道与 grep"></a>5.4 管道与 <code>grep</code></h3><p>可以将其他命令的输出传递给 <code>grep</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep <span class="string">&#x27;nginx&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="5-5-实际应用示例"><a href="#5-5-实际应用示例" class="headerlink" title="5.5 实际应用示例"></a>5.5 实际应用示例</h3><ol><li><p><strong>查找进程</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep <span class="string">&#x27;nginx&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>过滤日志文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f /var/log/syslog | grep <span class="string">&#x27;error&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>查看配置文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i <span class="string">&#x27;listen&#x27;</span> /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul><li><a href="https://www.gnu.org/software/grep/manual/grep.html">GNU Grep Manual</a></li><li><a href="https://linuxcommand.org/">Linux Command Line</a></li></ul><p><img src="https://cybrix.ai/workflow_diagrams/static/8e5d225f-1873-4bc3-a9ef-98f192d1f01d.png" alt="grep 使用流程图"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Memory Rank/Channel/DPC</title>
      <link href="/2024/09/25/memory_dpc_rank_channel/"/>
      <url>/2024/09/25/memory_dpc_rank_channel/</url>
      
        <content type="html"><![CDATA[<h1 id="Memory-Rank-Channel-DPC"><a href="#Memory-Rank-Channel-DPC" class="headerlink" title="Memory Rank&#x2F;Channel&#x2F;DPC"></a>Memory Rank&#x2F;Channel&#x2F;DPC</h1><p>内存 <strong>Rank</strong>、<strong>Channel</strong> 和 <strong>DPC（DIMMs per Channel）</strong> 这三个概念一起决定了系统的内存配置、性能和带宽。让我们从各自的定义和相互关系来讨论它们：</p><h3 id="1-Memory-Rank（内存Rank）"><a href="#1-Memory-Rank（内存Rank）" class="headerlink" title="1. Memory Rank（内存Rank）"></a>1. <strong>Memory Rank（内存Rank）</strong></h3><p>内存 Rank 指的是一条内存条上有多少组内存芯片，这些组可以独立访问。Rank 决定了内存条的内部组织结构。</p><ul><li>**Single Rank (单Rank)**：一条内存条中的内存芯片被划分为一个逻辑组，所有芯片可以同时被访问。</li><li>**Dual Rank (双Rank)**：一条内存条中的内存芯片分为两个逻辑组，内存控制器一次只能访问一个组。双Rank内存一般比单Rank内存的性能稍好，但对系统的支持要求较高。</li><li>**Quad Rank (四Rank)**：内存条中的内存芯片分为四个逻辑组，通常用于大容量内存条。</li></ul><p><strong>Rank的影响</strong>：更多的Rank通常意味着内存容量更大，能够提升内存带宽，但也可能导致系统延迟增加，兼容性变差。某些主板限制了支持的 Rank 数量。</p><p><img src="https://www.oempcworld.com/wordpress/wp-content/uploads/2020/02/SinglevsDualvsQuadRAM.jpg" alt="Memory Rank"></p><p><img src="https://i0.wp.com/blog.memory4less.com/wp-content/uploads/2022/09/single-rank-vs-dual-rank-memory.jpg" alt="Memory Rank"></p><h3 id="2-Memory-Channel（内存通道）"><a href="#2-Memory-Channel（内存通道）" class="headerlink" title="2. Memory Channel（内存通道）"></a>2. <strong>Memory Channel（内存通道）</strong></h3><p>Memory Channel 指的是主板与内存之间的数据通道数量，决定了主板与内存通信的并行能力。</p><ul><li><strong>单通道（Single Channel）</strong>：只有一个通道用于与内存通信，带宽较低。</li><li><strong>双通道（Dual Channel）</strong>：两个通道用于与内存通信，带宽是单通道的两倍。</li><li><strong>四通道（Quad Channel）</strong>：四个通道同时工作，大幅提高内存带宽，多用于高性能的工作站和服务器。</li></ul><p><strong>Channel的影响</strong>：更多的通道可以增加内存带宽，提升数据传输效率，降低瓶颈。现代主板通常支持双通道甚至四通道配置。<br><img src="https://infohub.delltechnologies.com/static/media/9198938f-8c47-5a0e-82d9-6db6a62cd3f7/DAM-df9ef174-c6d7-41d7-9876-fd664ccd00e2/out/1856.009.png" alt="Memory Channel"></p><h3 id="3-DPC-DIMMs-per-Channel"><a href="#3-DPC-DIMMs-per-Channel" class="headerlink" title="3. DPC (DIMMs per Channel)"></a>3. <strong>DPC (DIMMs per Channel)</strong></h3><p>DPC 是指每个内存通道上安装的内存条数量。常见的配置有：</p><ul><li>**1DPC (One DIMM per Channel)**：每个内存通道只有一条内存条。这种配置下内存频率较高，系统的性能和稳定性通常更好。</li><li>**2DPC (Two DIMMs per Channel)**：每个内存通道上有两条内存条。这种配置可以增加系统的内存容量，但由于多个内存条共享同一个通道，内存频率可能会下降，延迟增加。</li><li><strong>更多的DPC</strong>：一些高端服务器主板支持每个通道上多达 3DPC 或 4DPC 的配置，但这样的配置更常用于需要超大内存容量的系统。</li></ul><p><strong>DPC的影响</strong>：1DPC 配置通常性能最好，频率较高；2DPC 增加了容量，但频率和性能可能会受到影响，特别是在高频内存配置下。</p><p><img src="https://www.intel.com/content/dam/support/us/en/images/processors/88926_image1.png" alt="Memory DPC"></p><h3 id="内存-Rank、Channel-和-DPC-之间的关系"><a href="#内存-Rank、Channel-和-DPC-之间的关系" class="headerlink" title="内存 Rank、Channel 和 DPC 之间的关系"></a><strong>内存 Rank、Channel 和 DPC 之间的关系</strong></h3><p>这三个概念在内存系统中相互作用，影响着整体的内存性能、容量和带宽。</p><ol><li><p><strong>Rank 和 Channel 的关系</strong>：</p><ul><li><strong>Rank</strong> 和 <strong>Channel</strong> 是独立的概念。你可以在单通道配置中使用多Rank内存条，或在双通道配置中使用单Rank内存条。更多的通道通常意味着更高的带宽，而更多的Rank可以提升内存控制器的访问效率。</li><li>例如，双通道 + 双Rank配置可以同时使用两条内存条中的多个Rank，提高数据传输的并行性。</li></ul></li><li><p><strong>Rank 和 DPC 的关系</strong>：</p><ul><li><strong>Rank</strong> 决定了每条内存条的逻辑分组，而 <strong>DPC</strong> 则决定了每个通道上有多少条内存。如果一个通道上有两条双Rank内存条（即2DPC+双Rank），系统会处理多个Rank和多个内存条，这种配置可能会增加延迟，但也能带来更大的内存容量。</li><li>使用多Rank内存条的同时增加DPC数量，系统在处理多个Rank时需要更复杂的控制机制，频率可能下降，稳定性也可能受到影响。</li></ul></li><li><p><strong>Channel 和 DPC 的关系</strong>：</p><ul><li><strong>Channel</strong> 决定了并行传输的能力，而 <strong>DPC</strong> 决定了每个通道上有多少内存条。比如，在双通道配置中，每个通道上都可以有一条（1DPC）或两条（2DPC）内存条。如果你在双通道上使用2DPC，那么系统中将有4条内存条，并且带宽会增加，但频率可能会下降。</li></ul></li></ol><h3 id="示例配置："><a href="#示例配置：" class="headerlink" title="示例配置："></a><strong>示例配置</strong>：</h3><ul><li><strong>双通道 + 1DPC + 单Rank</strong>：两个内存通道，每个通道上有一条单Rank内存。这种配置具有高带宽和高频率，适合追求性能的系统。</li><li><strong>双通道 + 2DPC + 双Rank</strong>：两个内存通道，每个通道上有两条双Rank内存。这种配置提供更大的内存容量，但可能会导致内存频率下降，延迟增加。</li><li><strong>四通道 + 1DPC + Quad Rank</strong>：四个内存通道，每个通道上有一条四Rank内存条，常见于需要超大内存容量的高端服务器。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>Memory Rank</strong>：决定了单条内存条的内部结构和容量，影响性能。</li><li><strong>Memory Channel</strong>：决定了系统与内存之间的并行通信路径数量，更多的通道提高了内存带宽。</li><li>**DPC (DIMMs per Channel)**：决定了每个通道上有多少条内存条，增加DPC数量通常能提高内存容量，但可能降低频率和性能。</li></ul><p>这三个因素共同作用，影响内存的容量、带宽、延迟和整体系统性能。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RHEL9 切换默认启动内核</title>
      <link href="/2024/09/25/rhel9_kernel_switch/"/>
      <url>/2024/09/25/rhel9_kernel_switch/</url>
      
        <content type="html"><![CDATA[<h1 id="RHEL9-切换默认启动内核"><a href="#RHEL9-切换默认启动内核" class="headerlink" title="RHEL9 切换默认启动内核"></a>RHEL9 切换默认启动内核</h1><hr><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 Red Hat Enterprise Linux 9 (RHEL9) 中切换默认启动内核的详细操作步骤。在某些情况下，切换默认内核可能是必要的，比如为了测试、提高性能或增强安全性。</p><hr><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>适用于负责管理和维护 RHEL9 系统的系统管理员。</p><hr><h2 id="职责"><a href="#职责" class="headerlink" title="职责"></a>职责</h2><ul><li>系统管理员需要确保在切换默认内核后，系统的稳定性和功能性。</li><li>执行这些命令需要 root 权限或管理员权限。</li><li>在修改启动设置之前，建议进行备份以防止系统故障。</li></ul><hr><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>RHEL9 系统</li><li>root 或管理员权限</li><li>已安装的所有内核版本信息</li><li>基本的 Linux 启动流程知识</li></ul><hr><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li><p><strong>查看所有已安装的内核</strong></p><ul><li>在设置默认内核之前，首先需要查看系统中已安装的内核列表。</li><li>执行以下命令来查看所有可用的内核：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grubby --info=ALL</span><br></pre></td></tr></table></figure></li><li>示例输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index=0</span><br><span class="line">kernel=&quot;/boot/vmlinuz-5.14.0-70.17.1.el9_0.x86_64&quot;</span><br><span class="line">...</span><br><span class="line">index=1</span><br><span class="line">kernel=&quot;/boot/vmlinuz-5.14.0-50.12.2.el9.x86_64&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>设置默认启动内核</strong></p><ul><li>从上一步输出中，找到所需设置为默认的内核的完整路径，通常类似于 <code>/boot/vmlinuz-&lt;版本号&gt;</code> 的形式。</li><li>使用以下命令设置默认启动内核：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grubby --set-default /boot/vmlinuz-&lt;版本号&gt;</span><br></pre></td></tr></table></figure></li><li>示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grubby --set-default /boot/vmlinuz-5.14.0-70.17.1.el9_0.x86_64</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>验证默认启动内核</strong></p><ul><li>设置完成后，可以通过以下命令验证默认启动的内核：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-editenv list</span><br></pre></td></tr></table></figure></li><li>示例输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saved_entry=5.14.0-70.17.1.el9_0.x86_64</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="其他示例"><a href="#其他示例" class="headerlink" title="其他示例"></a>其他示例</h2><ul><li><p><strong>查看当前正在运行的内核</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.14.0-70.17.1.el9_0.x86_64</span><br></pre></td></tr></table></figure></li><li><p><strong>列出所有已安装的内核（带详细信息）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep kernel</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kernel-5.14.0-50.12.2.el9.x86_64</span><br><span class="line">kernel-5.14.0-70.17.1.el9_0.x86_64</span><br></pre></td></tr></table></figure></li><li><p><strong>删除旧内核（保持两个内核版本）</strong><br>在确保新的内核可以正常工作后，可以删除旧的内核来节省磁盘空间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf remove kernel-&lt;旧版本号&gt;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/">Red Hat 官方文档：GRUB2 启动加载器</a></li><li><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/">RHEL9 内核管理指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> RHEL </tag>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字证书、证书颁发机构 (CA)、私钥、公钥和数字签名</title>
      <link href="/2024/08/14/Digital_Certificate_SOP/"/>
      <url>/2024/08/14/Digital_Certificate_SOP/</url>
      
        <content type="html"><![CDATA[<h1 id="数字证书、证书颁发机构-CA-、私钥、公钥和数字签名"><a href="#数字证书、证书颁发机构-CA-、私钥、公钥和数字签名" class="headerlink" title="数字证书、证书颁发机构 (CA)、私钥、公钥和数字签名"></a>数字证书、证书颁发机构 (CA)、私钥、公钥和数字签名</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>概述了使用数字证书、证书颁发机构 (CA)、私钥、公钥和数字签名的基本概念和程序。这些组件对于确保通信安全、验证数字数据的真实性和完整性至关重要。</p><h2 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="2. 适用范围"></a>2. 适用范围</h2><p>适用于组织内负责管理、部署和使用数字证书和加密技术的IT安全专业人员、系统管理员和开发人员。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>IT安全团队</strong>：管理数字证书的生命周期，包括颁发、更新和吊销，确保符合安全策略。</li><li><strong>系统管理员</strong>：配置系统以使用数字证书，并管理私钥的安全存储。</li><li><strong>开发人员</strong>：在应用程序中集成公钥和私钥，以实现安全通信协议。</li><li><strong>终端用户</strong>：使用配置了有效和可信证书的系统。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>可信的证书颁发机构 (CA) 或内部CA设置。</li><li>生成加密密钥对的工具（例如OpenSSL）。</li><li>私钥的安全存储机制，如硬件安全模块 (HSM) 或加密文件。</li><li>配置为支持TLS&#x2F;SSL协议的应用程序或系统，用于安全的数据传输。</li></ul><h2 id="5-流程"><a href="#5-流程" class="headerlink" title="5. 流程"></a>5. 流程</h2><p><img src="https://lilinth.github.io/picx-images-hosting/8740f369-7073-4439-9658-d2729bdfb355[1].13lp5jsm8r.webp" alt="8740f369-7073-4439-9658-d2729bdfb355[1]"></p><h3 id="5-1-生成密钥对"><a href="#5-1-生成密钥对" class="headerlink" title="5.1 生成密钥对"></a>5.1 生成密钥对</h3><ol><li><p><strong>生成私钥</strong>：</p><ul><li>使用加密工具（如OpenSSL）创建私钥。</li><li>示例命令：<code>openssl genpkey -algorithm RSA -out private_key.pem -aes256</code></li><li>私钥必须安全存储，因为它对于加密和签名创建至关重要。</li></ul></li><li><p><strong>派生公钥</strong>：</p><ul><li>从私钥中提取公钥，可与他人共享。</li><li>示例命令：<code>openssl rsa -pubout -in private_key.pem -out public_key.pem</code></li><li>公钥用于加密和验证数字签名。</li></ul></li></ol><h3 id="5-2-创建证书签名请求-CSR"><a href="#5-2-创建证书签名请求-CSR" class="headerlink" title="5.2 创建证书签名请求 (CSR)"></a>5.2 创建证书签名请求 (CSR)</h3><ol><li><strong>生成CSR</strong>：<ul><li>使用私钥创建包含公钥和组织信息的CSR。</li><li>示例命令：<code>openssl req -new -key private_key.pem -out csr.pem</code></li><li>将CSR提交给CA进行验证和证书颁发。</li></ul></li></ol><h3 id="5-3-证书颁发机构-CA-操作"><a href="#5-3-证书颁发机构-CA-操作" class="headerlink" title="5.3 证书颁发机构 (CA) 操作"></a>5.3 证书颁发机构 (CA) 操作</h3><ol><li><p><strong>签署CSR</strong>：</p><ul><li>CA审核CSR，验证后进行签名并颁发数字证书。</li><li>该证书用于服务器在安全通信中验证其身份。</li><li>内部CA的示例命令：<code>openssl x509 -req -days 365 -in csr.pem -signkey ca_private_key.pem -out certificate.pem</code></li></ul></li><li><p><strong>证书更新</strong>：</p><ul><li>在证书过期之前，生成新的CSR并提交给CA。</li><li>CA颁发新的证书，并更新有效期。</li></ul></li></ol><h3 id="5-4-数字签名和验证"><a href="#5-4-数字签名和验证" class="headerlink" title="5.4 数字签名和验证"></a>5.4 数字签名和验证</h3><ol><li><p><strong>创建数字签名</strong>：</p><ul><li>通过对消息或文档进行哈希处理并使用私钥加密哈希值来签名。</li><li>这可确保消息的完整性和真实性。</li><li>示例：<code>openssl dgst -sha256 -sign private_key.pem -out signature.sig file_to_sign.txt</code></li></ul></li><li><p><strong>验证数字签名</strong>：</p><ul><li>使用发送方的公钥解密哈希值，并将其与根据收到的文档计算的哈希值进行比较，以验证签名的真实性。</li><li>示例：<code>openssl dgst -sha256 -verify public_key.pem -signature signature.sig file_to_verify.txt</code></li></ul></li></ol><h3 id="5-5-管理证书吊销"><a href="#5-5-管理证书吊销" class="headerlink" title="5.5 管理证书吊销"></a>5.5 管理证书吊销</h3><ol><li><strong>吊销证书</strong>：<ul><li>如果证书被泄露，应立即通过CA吊销。</li><li>CA会将证书添加到证书吊销列表 (CRL) 中，系统会检查CRL以避免使用被泄露的证书。</li><li>创建CRL的示例命令：<code>openssl ca -gencrl -out crl.pem</code></li></ul></li></ol><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul><li><a href="https://www.openssl.org/docs/">OpenSSL文档</a></li><li><a href="https://www.digicert.com/ssl/">理解数字证书</a></li><li><a href="https://www.globalsign.com/en/blog/what-is-a-certificate-authority">证书颁发机构概述</a></li><li><a href="https://www.cloudflare.com/learning/ssl/what-is-public-key-infrastructure-pki/">PKI和数字签名</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Certificate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Fio 工具进行性能测试</title>
      <link href="/2024/08/14/fio_test/"/>
      <url>/2024/08/14/fio_test/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Fio-工具进行性能测试"><a href="#使用-Fio-工具进行性能测试" class="headerlink" title="使用 Fio 工具进行性能测试"></a>使用 Fio 工具进行性能测试</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>详细介绍如何使用Fio（Flexible I&#x2F;O Tester）工具进行存储性能测试。Fio是一款广泛应用的工具，能够测试块设备和文件系统的读写性能。本文将结合多个实际示例，逐步说明如何配置和运行Fio测试，并解析每个测试结果。</p><h2 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="2. 适用范围"></a>2. 适用范围</h2><p>适用于系统管理员、存储工程师和开发人员，他们需要对各种存储设备（如HDD、SSD、RAID阵列、SAN和NAS设备）进行性能评估。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>系统管理员</strong>: 负责安装和配置Fio工具，确保测试环境的稳定性和一致性。</li><li><strong>存储工程师</strong>: 设计测试参数和负载模型，以模拟实际使用场景。</li><li><strong>开发人员</strong>: 使用Fio生成性能数据，帮助优化应用程序的I&#x2F;O操作。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>安装了Fio工具的系统。</li><li>对目标存储设备的完全访问权限。</li><li>理解存储设备和文件系统的基本原理。</li><li>适当的权限执行性能测试，以避免影响生产环境。</li></ul><h2 id="5-流程和示例"><a href="#5-流程和示例" class="headerlink" title="5. 流程和示例"></a>5. 流程和示例</h2><h3 id="5-1-安装-Fio"><a href="#5-1-安装-Fio" class="headerlink" title="5.1 安装 Fio"></a>5.1 安装 Fio</h3><ol><li><p><strong>在Linux上安装Fio</strong>:</p><ul><li>大多数Linux发行版可以通过包管理器安装Fio。</li><li>使用以下命令安装Fio:<ul><li><strong>Debian&#x2F;Ubuntu</strong>: <code>sudo apt-get install fio</code></li><li><strong>CentOS&#x2F;RHEL</strong>: <code>sudo yum install fio</code></li><li><strong>Fedora</strong>: <code>sudo dnf install fio</code></li></ul></li></ul></li><li><p><strong>验证安装</strong>:</p><ul><li>使用命令 <code>fio --version</code> 验证Fio是否成功安装。</li></ul></li></ol><h3 id="5-2-基本测试命令"><a href="#5-2-基本测试命令" class="headerlink" title="5.2 基本测试命令"></a>5.2 基本测试命令</h3><ol><li><strong>运行简单的读写测试</strong>:<ul><li>以下命令将在指定的文件或设备上运行基本的顺序写入和读取测试。</li><li>示例命令: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=basic_test --filename=/path/to/testfile --size=1G --rw=readwrite --bs=4k --ioengine=libaio --numjobs=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure></li><li>参数说明:<ul><li><code>--name=basic_test</code>: 测试任务的名称。</li><li><code>--filename=/path/to/testfile</code>: 测试的目标文件或设备。</li><li><code>--size=1G</code>: 文件大小为1GB。</li><li><code>--rw=readwrite</code>: 读写混合测试。</li><li><code>--bs=4k</code>: 块大小为4KB。</li><li><code>--ioengine=libaio</code>: 使用Linux异步I&#x2F;O引擎。</li><li><code>--numjobs=1</code>: 使用单个工作线程。</li><li><code>--runtime=60</code>: 运行时间为60秒。</li><li><code>--group_reporting</code>: 汇总报告输出。</li></ul></li></ul></li></ol><h3 id="5-3-复杂测试"><a href="#5-3-复杂测试" class="headerlink" title="5.3 复杂测试"></a>5.3 复杂测试</h3><ol><li><p><strong>运行随机读写测试</strong>:</p><ul><li>对存储设备进行随机读写测试，以模拟实际工作负载。</li><li>示例命令:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=random_test --filename=/path/to/testfile --size=2G --rw=randrw --bs=4k --ioengine=libaio --numjobs=4 --runtime=120 --rwmixread=70 --group_reporting</span><br></pre></td></tr></table></figure></li><li>额外参数:<ul><li><code>--rw=randrw</code>: 随机读写测试。</li><li><code>--rwmixread=70</code>: 设置读操作占比为70%。</li></ul></li></ul></li><li><p><strong>测试多线程性能</strong>:</p><ul><li>使用多个工作线程同时对设备进行读写，以测试多线程性能。</li><li>示例命令:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=multithread_test --filename=/path/to/testfile --size=4G --rw=randwrite --bs=8k --ioengine=libaio --numjobs=8 --runtime=180 --group_reporting</span><br></pre></td></tr></table></figure></li><li>该命令使用8个线程，每个线程执行随机写操作。</li></ul></li></ol><h3 id="5-4-分析结果"><a href="#5-4-分析结果" class="headerlink" title="5.4 分析结果"></a>5.4 分析结果</h3><ol><li><p><strong>查看测试报告</strong>:</p><ul><li>Fio的输出会包含每个测试的详细报告，包括吞吐量、IOPS、延迟等指标。</li><li>示例输出分析:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Run status group 0 (all jobs):</span><br><span class="line">  READ: io=1048576KB, bw=17496KB/s, iops=4374, runt= 60001msec</span><br><span class="line">  WRITE: io=1048576KB, bw=17496KB/s, iops=4374, runt= 60001msec</span><br></pre></td></tr></table></figure></li><li><code>bw</code>表示带宽（吞吐量），<code>iops</code>表示每秒I&#x2F;O操作次数，<code>runt</code>表示测试运行时间。</li></ul></li><li><p><strong>保存结果</strong>:</p><ul><li>可以将结果输出保存到文件中进行进一步分析。</li><li>使用 <code>--output=&lt;filename&gt;</code> 参数保存报告，例如:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=basic_test --filename=/path/to/testfile --size=1G --rw=readwrite --bs=4k --ioengine=libaio --numjobs=1 --runtime=60 --group_reporting --output=fio_report.txt</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="6-更多示例"><a href="#6-更多示例" class="headerlink" title="6. 更多示例"></a>6. 更多示例</h2><h3 id="6-1-基本顺序读写测试"><a href="#6-1-基本顺序读写测试" class="headerlink" title="6.1 基本顺序读写测试"></a>6.1 基本顺序读写测试</h3><ol><li><p><strong>顺序写入测试</strong></p><ul><li><strong>目的</strong>: 测试存储设备在顺序写入数据时的性能，这对数据仓库或视频存储系统等大文件顺序写入场景非常重要。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=seq_write --filename=/path/to/testfile --size=10G --rw=write --bs=1M --direct=1 --ioengine=libaio --numjobs=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>bw</code>: 测试期间的平均带宽，反映了设备的顺序写入速度。</li><li><code>iops</code>: 每秒I&#x2F;O操作次数，通常用于衡量设备的响应能力。</li><li>例如，如果 <code>bw=500MB/s</code> 和 <code>iops=500</code>，这表明设备在此测试中能够维持500MB&#x2F;s的顺序写入速度。</li></ul></li></ul></li><li><p><strong>顺序读取测试</strong></p><ul><li><strong>目的</strong>: 测试存储设备在顺序读取数据时的性能，适用于需要大量顺序读取操作的场景，如视频播放或数据分析。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=seq_read --filename=/path/to/testfile --size=10G --rw=<span class="built_in">read</span> --bs=1M --direct=1 --ioengine=libaio --numjobs=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>bw</code>: 测试期间的平均读取带宽。</li><li>例如，<code>bw=600MB/s</code> 表示设备能够以600MB&#x2F;s的速度顺序读取数据，这对于顺序数据访问模式的应用非常理想。</li></ul></li></ul></li></ol><h3 id="6-2-随机读写测试"><a href="#6-2-随机读写测试" class="headerlink" title="6.2 随机读写测试"></a>6.2 随机读写测试</h3><ol><li><p><strong>随机写入测试</strong></p><ul><li><strong>目的</strong>: 测试设备在随机写入数据时的性能，模拟数据库写入、日志记录等需要频繁写入小块数据的场景。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=rand_write --filename=/path/to/testfile --size=5G --rw=randwrite --bs=4k --direct=1 --ioengine=libaio --numjobs=4 --runtime=120 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>iops</code>: 随机写入操作的IOPS通常是关注的重点，反映了设备在处理小块随机写入时的能力。</li><li><code>lat</code>: 延迟时间，表示每次I&#x2F;O操作的平均时间，延迟越低越好。</li><li>例如，<code>iops=20000</code> 和 <code>lat=0.1ms</code> 表示设备在随机写入小块数据时表现良好。</li></ul></li></ul></li><li><p><strong>随机读取测试</strong></p><ul><li><strong>目的</strong>: 测试存储设备在随机读取数据时的性能，适用于OLTP数据库或高并发读取的应用场景。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=rand_read --filename=/path/to/testfile --size=5G --rw=randread --bs=4k --direct=1 --ioengine=libaio --numjobs=4 --runtime=120 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>iops</code> 和 <code>lat</code> 是评估设备随机读取性能的重要指标。</li><li>例如，如果 <code>iops=50000</code> 和 <code>lat=0.08ms</code>，这表明设备在高负载下也能快速响应随机读取请求。</li></ul></li></ul></li><li><p><strong>随机读写混合测试</strong></p><ul><li><strong>目的</strong>: 测试读写混合场景下的存储性能，常见于需要同时处理读取和写入请求的系统，如文件服务器或虚拟化环境。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=rand_rw_mix --filename=/path/to/testfile --size=5G --rw=randrw --bs=4k --direct=1 --ioengine=libaio --numjobs=4 --runtime=120 --rwmixread=70 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>rwmixread=70</code> 设置读写比例为70%读和30%写，这能测试出设备在读写混合负载下的表现。</li><li>观察 <code>iops</code> 和 <code>lat</code> 来评估在这种混合场景下的性能。</li></ul></li></ul></li></ol><h3 id="6-3-多线程和多进程测试"><a href="#6-3-多线程和多进程测试" class="headerlink" title="6.3 多线程和多进程测试"></a>6.3 多线程和多进程测试</h3><ol><li><p><strong>多线程顺序读写测试</strong></p><ul><li><strong>目的</strong>: 评估存储设备在多线程情况下的顺序读写性能，模拟多用户并发访问的场景。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=multithread_seq --filename=/path/to/testfile --size=10G --rw=write --bs=1M --direct=1 --ioengine=libaio --numjobs=8 --runtime=180 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>bw</code> 和 <code>iops</code> 在多线程情况下可能会有所增加，但也可能因锁争用或I&#x2F;O调度影响而下降。</li><li>对比单线程和多线程结果，可以评估设备在并发负载下的扩展性。</li></ul></li></ul></li><li><p><strong>多进程随机写入测试</strong></p><ul><li><strong>目的</strong>: 测试在多个进程同时进行随机写入时的性能，适用于模拟数据库集群或并行计算环境。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=multiprocess_rand_write --filename=/path/to/testfile --size=10G --rw=randwrite --bs=4k --direct=1 --ioengine=libaio --numjobs=8 --runtime=180 --group_reporting --gtod_reduce=1</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li>多进程下的 <code>iops</code> 和 <code>lat</code> 是关键指标，注意观察是否有瓶颈产生。</li><li>例如，如果 <code>iops=45000</code> 和 <code>lat=0.15ms</code>，则表示设备在高并发写入场景下表现较为稳定。</li></ul></li></ul></li></ol><h3 id="6-4-文件系统缓存的影响"><a href="#6-4-文件系统缓存的影响" class="headerlink" title="6.4 文件系统缓存的影响"></a>6.4 文件系统缓存的影响</h3><ol><li><p><strong>开启缓存的随机写入测试</strong></p><ul><li><strong>目的</strong>: 测试文件系统缓存对写操作的影响，模拟常规写入操作。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=cached_rand_write --filename=/path/to/testfile --size=2G --rw=randwrite --bs=4k --ioengine=<span class="built_in">sync</span> --numjobs=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>iops</code> 可能会因为缓存的作用而显著提高，<code>lat</code> 也可能减少。</li><li>例如，如果 <code>iops=35000</code> 和 <code>lat=0.05ms</code>，这表明文件系统缓存对性能有积极影响。</li></ul></li></ul></li><li><p><strong>禁用缓存的随机写入测试</strong></p><ul><li><strong>目的</strong>: 禁用缓存直接写入到磁盘，评估纯粹的硬件性能。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=direct_rand_write --filename=/path/to/testfile --size=2G --rw=randwrite --bs=4k --direct=1 --ioengine=libaio --numjobs=1 --runtime=60 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li>禁用缓存后，<code>iops</code> 和 <code>lat</code> 反映了设备的实际性能。</li><li>例如，<code>iops=15000</code> 和 <code>lat=0.3ms</code> 表示在无缓存情况下，设备的硬件性能。</li></ul></li></ul></li></ol><h3 id="6-5-RAID阵列性能测试"><a href="#6-5-RAID阵列性能测试" class="headerlink" title="6.5 RAID阵列性能测试"></a>6.5 RAID阵列性能测试</h3><ol><li><p><strong>顺序读取RAID性能</strong></p><ul><li><strong>目的</strong>: 评估RAID阵列的顺序读取性能，适用于高吞吐量需求的应用，如视频编辑或数据备份。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=raid_seq_read --filename=/dev/md0 --size=10G --rw=<span class="built_in">read</span> --bs=1M --direct=1 --ioengine=libaio --numjobs=1 --runtime=300 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li><code>bw</code> 是主要关注点，反映了RAID阵列在顺序读取任务中的吞吐能力。</li><li>例如，<code>bw=800MB/s</code> 表示RAID阵列在该测试中表现良好。</li></ul></li></ul></li><li><p><strong>随机写入RAID性能</strong></p><ul><li><strong>目的</strong>: 测试RAID阵列的随机写入性能，适用于需要高I&#x2F;O吞吐的环境，如虚拟化平台。</li><li><strong>命令</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fio --name=raid_rand_write --filename=/dev/md0 --size=5G --rw=randwrite --bs=4k --direct=1 --ioengine=libaio --numjobs=4 --runtime=300 --group_reporting</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li>关注 <code>iops</code> 和 <code>lat</code> 指标，评估RAID在并发随机写入下的性能。</li><li>例如，如果 <code>iops=30000</code> 和 <code>lat=0.2ms</code>，则表示RAID阵列能够在随机写入场景下保持较高的性能。</li></ul></li></ul></li></ol><h2 id="7-一些Tips"><a href="#7-一些Tips" class="headerlink" title="7. 一些Tips"></a>7. 一些Tips</h2><ul><li>Q: 指定运行FIO的时间，但是提前就结束了。</li><li>A: 加上参数 <code>-time_base</code>即可</li></ul><h2 id="8-参考文献"><a href="#8-参考文献" class="headerlink" title="8. 参考文献"></a>8. 参考文献</h2><ul><li><a href="https://fio.readthedocs.io/">Fio官方文档</a></li><li><a href="https://www.redhat.com/en/resources/storage-performance-testing-best-practices">存储性能测试最佳实践</a></li><li><a href="https://www.intel.com/content/www/us/en/support/articles/000005791/memory-and-storage.html">RAID性能优化指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 RHEL 9.4 上配置 ARM64 虚拟机</title>
      <link href="/2024/08/14/rhel9.4_arm_vm/"/>
      <url>/2024/08/14/rhel9.4_arm_vm/</url>
      
        <content type="html"><![CDATA[<h1 id="在-RHEL-9-4-上配置-ARM64-虚拟机"><a href="#在-RHEL-9-4-上配置-ARM64-虚拟机" class="headerlink" title="在 RHEL 9.4 上配置 ARM64 虚拟机"></a>在 RHEL 9.4 上配置 ARM64 虚拟机</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>在 RHEL 9.4 上配置 ARM64 虚拟机可以帮助用户在物理服务器上模拟 ARM64 环境，用于测试和开发适用于 ARM64 架构的软件。详细介绍了如何在 RHEL 9.4 系统上配置和运行 ARM64 虚拟机的过程。</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h2><p>适用于在 RHEL 9.4 系统上需要模拟 ARM64 虚拟机环境的技术人员。主要涉及 QEMU、KVM 和相关工具的安装与配置。</p><h2 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h2><ul><li><strong>系统管理员</strong>：负责确保系统已安装必要的软件包，并具备运行虚拟机的权限。</li><li><strong>操作员</strong>：按照正确配置和运行 ARM64 虚拟机。</li></ul><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h2><ul><li>运行 RHEL 9.4 操作系统的物理服务器或虚拟主机。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>有效的互联网连接以下载必要的软件包和工具。</li></ul><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><h3 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h3><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf update -y</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装 QEMU、KVM 和相关工具</strong></p><ul><li>使用 <code>dnf</code> 安装 QEMU 和 KVM 以及相关的虚拟化管理工具：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install qemu-kvm qemu-img libvirt virt-install virt-manager -y</span><br><span class="line">sudo dnf install libguestfs-tools -y  <span class="comment"># 用于管理虚拟机磁盘镜像</span></span><br></pre></td></tr></table></figure></li></ul><p>1.3 <strong>启动并启用 KVM 和 Libvirt 服务</strong></p><ul><li>确保 KVM 和 Libvirt 服务已启动并运行：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start libvirtd</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> libvirtd</span><br></pre></td></tr></table></figure></li></ul><p>1.4 <strong>检查 KVM 是否已启用</strong></p><ul><li>使用以下命令检查 KVM 是否正常启用(有些情况下虽然没有列出KVM，但是仍然是支持的)：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsmod | grep kvm</span><br></pre></td></tr></table></figure></li><li>如果输出中包含 <code>kvm</code> 和 <code>kvm_intel</code> 或 <code>kvm_amd</code>，则表示 KVM 已正确启用。</li><li>实际测试，不包含<code>kvm</code>也可以使用，具体问题具体分析。</li></ul><h3 id="2-获取和准备-ARM64-镜像"><a href="#2-获取和准备-ARM64-镜像" class="headerlink" title="2. 获取和准备 ARM64 镜像"></a>2. <strong>获取和准备 ARM64 镜像</strong></h3><p>2.1 <strong>下载 RHEL 9.4 ARM64 操作系统镜像</strong></p><ul><li>从 Red Hat 官方网站或客户门户下载 RHEL 9.4 ARM64 ISO 镜像。确保您有适当的订阅以访问镜像。</li></ul><p>2.2 <strong>创建虚拟机磁盘镜像</strong></p><ul><li>使用 <code>qemu-img</code> 创建虚拟机磁盘镜像：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f qcow2 rhel9-arm64.qcow2 20G</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>-f qcow2</code>：指定磁盘镜像格式为 QCOW2。</li><li><code>20G</code>：设置磁盘大小为 20GB。</li></ul></li></ul><h3 id="3-创建和配置-ARM64-虚拟机"><a href="#3-创建和配置-ARM64-虚拟机" class="headerlink" title="3. 创建和配置 ARM64 虚拟机"></a>3. <strong>创建和配置 ARM64 虚拟机</strong></h3><p>3.1 <strong>启动虚拟机并进行安装</strong></p><ul><li>使用以下命令启动虚拟机，并从 ISO 镜像进行安装：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virt-install --name myvm --ram 2048 --vcpus 2 --disk path=/var/lib/libvirt/images/myvm.qcow2,size=20  --os-variant rhel9.4 --network bridge=virbr0 --graphics none --console pty,target_type=serial --cdrom /path/to/your/iso/file.iso</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>virt-install</code>：命令行工具，用于创建新的虚拟机。</li><li><code>--name myvm</code>：指定虚拟机的名称为 myvm。这个名称将用于管理和识别该虚拟机。</li><li><code>--ram 2048</code>：分配给虚拟机的内存大小，以 MB 为单位。这意味着为虚拟机分配了 2048 MB（2 GB）的内存。</li><li><code>--vcpus 2</code>：指定虚拟机的虚拟 CPU 数量为 2 个。这决定了虚拟机可以使用的 CPU 核心数。</li><li><code>--disk path=/var/lib/libvirt/images/arm64vm.qcow2,size=20</code>：path&#x3D;&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images&#x2F;arm64vm.qcow2：定义虚拟机的磁盘映像文件路径和文件名。此文件将存储虚拟机的虚拟硬盘。</li><li><code>size=20</code>：为虚拟机的磁盘分配 20 GB 的存储空间。</li><li><code>--os-variant generic</code>：指定操作系统的具体版本或变体为 generic，即通用版本。这意味着该配置适用于多种 Linux 发行版。可以使用 osinfo-query os 命令查看可用的具体操作系统变体。</li><li><code>--arch aarch64</code>：指定虚拟机的架构为 ARM64（aarch64）。这意味着虚拟机将仿真或使用 ARM64 架构的硬件。</li><li><code>--machine virt</code>：指定虚拟机的机器类型为 virt，这是 QEMU 用于 ARM 仿真的通用机器类型，适用于多种 ARM64 设备。</li><li><code>--network bridge=virbr0</code>：将虚拟机连接到名为 virbr0 的桥接网络接口。这允许虚拟机与主机及网络中的其他设备进行通信。</li><li><code>--graphics none</code>：指定虚拟机不使用图形界面（无图形输出），以纯命令行方式运行。这通常用于服务器或嵌入式系统的设置。</li><li><code>--console pty,target_type=serial</code>：设置虚拟机的控制台为伪终端（PTY），并将其连接到虚拟机的串行端口。这允许通过命令行的方式直接与虚拟机进行交互。</li><li><code>--cdrom /path/to/your/arm64.iso</code>：指定要加载的 ISO 文件路径，这通常是操作系统安装镜像的路径。虚拟机启动时会从这个 ISO 镜像中引导，并开始安装操作系统。<ul><li>也可以使用图形界面<code>virtual machine manager</code>进行安装</li></ul></li></ul></li></ul><p>3.2 <strong>安装操作系统</strong></p><ul><li>当虚拟机启动后，按照屏幕提示安装 RHEL 9.4 操作系统。安装过程与在物理机上的安装类似。</li></ul><p>3.3 <strong>完成安装后，重启虚拟机</strong></p><ul><li>完成安装后，可以使用以下命令进入虚拟机：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh console myvm</span><br></pre></td></tr></table></figure>   当提示 <code>Escape character is ^]</code> 时，按 <code>Enter</code> 键进入虚拟机的命令行。如果要退出控制台，您可以使用 <code>Ctrl + ]</code>。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure></li><li>解释：此命令省略了安装 CD-ROM 部分，仅使用已安装的磁盘镜像启动虚拟机。</li></ul><h3 id="4-维护与管理-ARM64-虚拟机"><a href="#4-维护与管理-ARM64-虚拟机" class="headerlink" title="4. 维护与管理 ARM64 虚拟机"></a>4. <strong>维护与管理 ARM64 虚拟机</strong></h3><p>4.1 <strong>快照管理</strong></p><ul><li>使用 <code>qemu-img</code> 管理虚拟机快照，便于恢复到之前的状态：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qemu-img snapshot -c snap1 rhel9-arm64.qcow2  <span class="comment"># 创建快照</span></span><br><span class="line">qemu-img snapshot -l rhel9-arm64.qcow2        <span class="comment"># 列出所有快照</span></span><br><span class="line">qemu-img snapshot -a snap1 rhel9-arm64.qcow2  <span class="comment"># 恢复到快照</span></span><br></pre></td></tr></table></figure></li></ul><p>4.2 <strong>备份虚拟机</strong></p><ul><li>通过复制 QCOW2 镜像文件来备份虚拟机：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> rhel9-arm64.qcow2 rhel9-arm64-backup.qcow2</span><br></pre></td></tr></table></figure></li></ul><p>4.3 <strong>调整虚拟机资源</strong></p><ul><li>停止虚拟机后，可以编辑启动命令来调整虚拟机的 CPU 和内存分配，以满足不同的测试需求。</li></ul><h3 id="5-常见问题与故障排除"><a href="#5-常见问题与故障排除" class="headerlink" title="5. 常见问题与故障排除"></a>5. <strong>常见问题与故障排除</strong></h3><p>5.1 <strong>虚拟机性能较差</strong></p><ul><li>如果发现虚拟机性能较差，可以考虑增加分配给虚拟机的 CPU 核心和内存，或启用 KVM 加速（如果支持）。</li></ul><p>5.2 <strong>无法启动虚拟机</strong></p><ul><li>检查启动命令中的文件路径和参数是否正确，确保 BIOS 和磁盘镜像文件存在且可访问。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://www.qemu.org/documentation/">QEMU Documentation</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9">Red Hat Enterprise Linux 9 Documentation</a></li><li><a href="https://libvirt.org/documentation.html">Libvirt Documentation</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> 虚拟机 </tag>
            
            <tag> VM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 PF 直通 (Passthrough)</title>
      <link href="/2024/08/14/rhel9.4_mlx_pf/"/>
      <url>/2024/08/14/rhel9.4_mlx_pf/</url>
      
        <content type="html"><![CDATA[<h1 id="在-ARM64-平台的-RHEL-9-4-上配置-Mellanox-ConnectX-6-网卡的-PF-直通-Passthrough"><a href="#在-ARM64-平台的-RHEL-9-4-上配置-Mellanox-ConnectX-6-网卡的-PF-直通-Passthrough" class="headerlink" title="在 ARM64 平台的 RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 PF 直通 (Passthrough)"></a>在 ARM64 平台的 RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 PF 直通 (Passthrough)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>在虚拟化环境中，Mellanox ConnectX-6 网卡的物理功能 (Physical Function, PF) 直通（Passthrough）配置允许将整个物理网卡直接分配给虚拟机，从而获得接近裸机的网络性能。此配置特别适用于高性能网络需求的虚拟化应用场景。##详细介绍了如何在 ARM64 平台的 RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 PF 直通。</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h2><p>适用于系统管理员和虚拟化技术人员，帮助他们在 RHEL 9.4 ARM64 系统上配置 Mellanox ConnectX-6 网卡的 PF 直通功能，以优化虚拟化环境中的网络性能。</p><h2 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h2><ul><li><strong>系统管理员</strong>：确保系统已正确安装必要的软件包，且系统硬件支持 IOMMU 和 PF 直通功能。</li><li><strong>操作员</strong>：按照##配置 Mellanox ConnectX-6 网卡的 PF 直通，并确保其正确运行。</li></ul><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h2><ul><li>运行 RHEL 9.4 操作系统的 ARM64 服务器。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>Mellanox ConnectX-6 网卡，并确保服务器固件支持 IOMMU 和直通功能。</li></ul><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><h3 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h3><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf update -y</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装必要的驱动和工具</strong></p><ul><li><p>安装 Mellanox 网卡的驱动程序和相关工具：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install -y mlnx-ofed-basic</span><br></pre></td></tr></table></figure></li><li><p>安装完毕后，重启服务器以加载新安装的驱动：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></li></ul><p>1.3 <strong>检查 IOMMU 支持</strong></p><ul><li><p>确保系统的固件（Firmware&#x2F;BIOS）设置中已启用 IOMMU 支持。</p></li><li><p>确认 IOMMU 已在内核启动参数中启用：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo grubby --update-kernel=ALL --args=<span class="string">&quot;iommu.passthrough=on&quot;</span></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></li><li><p>重启后，使用以下命令确认 IOMMU 已启用：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i iommu</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-配置-Mellanox-ConnectX-6-的-PF-直通"><a href="#2-配置-Mellanox-ConnectX-6-的-PF-直通" class="headerlink" title="2. 配置 Mellanox ConnectX-6 的 PF 直通"></a>2. <strong>配置 Mellanox ConnectX-6 的 PF 直通</strong></h3><p>2.1 <strong>识别 Mellanox 网卡</strong></p><ul><li>使用 <code>lspci</code> 命令找到 Mellanox ConnectX-6 网卡的 PCI 总线地址：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep Mellanox</span><br></pre></td></tr></table></figure></li><li>记下类似 <code>0000:03:00.0</code> 的总线地址，这个地址表示网卡的物理功能（PF）。</li></ul><p>2.2 <strong>解除网卡绑定</strong></p><ul><li>在将网卡的 PF 直通给虚拟机之前，需要将其从主机系统中解除绑定：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:00.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/devices/0000:03:00.0/driver/unbind</span><br></pre></td></tr></table></figure></li></ul><p>2.3 <strong>绑定到 VFIO 驱动</strong></p><ul><li><p>将网卡的 PF 绑定到 VFIO 驱动以启用直通：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe vfio-pci</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:00.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/drivers/vfio-pci/bind</span><br></pre></td></tr></table></figure></li><li><p>确认绑定成功：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -nnk -d 15b3: | grep <span class="string">&quot;Kernel driver in use&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>输出应显示 <code>vfio-pci</code> 作为内核驱动。</p></li></ul><h3 id="3-配置-PF-直通到虚拟机"><a href="#3-配置-PF-直通到虚拟机" class="headerlink" title="3. 配置 PF 直通到虚拟机"></a>3. <strong>配置 PF 直通到虚拟机</strong></h3><p>3.1 <strong>编辑虚拟机配置</strong></p><ul><li>使用 <code>virsh edit</code> 或 <code>virt-manager</code> 将 PF 设备直接分配给虚拟机。示例 XML 配置：   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hostdev</span> <span class="attr">mode</span>=<span class="string">&#x27;subsystem&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">managed</span>=<span class="string">&#x27;yes&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x03&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x05&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hostdev</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>该配置将 Mellanox 网卡的 PF 设备直通给虚拟机。</li></ul><p>3.2 <strong>启用并启动虚拟机</strong></p><ul><li>编辑并保存虚拟机配置后，启动虚拟机：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh start &lt;vm_name&gt;</span><br></pre></td></tr></table></figure></li><li>在虚拟机中，使用 <code>ip link show</code> 或类似命令验证已分配的 PF 网卡。</li></ul><h3 id="4-维护与管理"><a href="#4-维护与管理" class="headerlink" title="4. 维护与管理"></a>4. <strong>维护与管理</strong></h3><p>4.1 <strong>释放 PF 资源</strong></p><ul><li>如果需要将 PF 资源从虚拟机中释放并返回主机，可以先关闭虚拟机并解除 VFIO 绑定：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virsh shutdown &lt;vm_name&gt;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:00.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/drivers/vfio-pci/unbind</span><br></pre></td></tr></table></figure></li></ul><p>4.2 <strong>重新绑定网卡到主机</strong></p><ul><li>将网卡重新绑定回主机操作系统的 Mellanox 驱动：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:00.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/drivers/mlx5_core/bind</span><br></pre></td></tr></table></figure></li></ul><p>4.3 <strong>定期更新驱动</strong></p><ul><li>确保定期更新 Mellanox 驱动程序和固件，以获取最新的功能和性能改进：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf upgrade -y mlnx-ofed-basic</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-常见问题与故障排除"><a href="#5-常见问题与故障排除" class="headerlink" title="5. 常见问题与故障排除"></a>5. <strong>常见问题与故障排除</strong></h3><p>5.1 <strong>PF 无法绑定到虚拟机</strong></p><ul><li>检查是否已正确启用 IOMMU 和 VFIO 驱动，确保 PF 已成功解除绑定并分配给虚拟机。</li></ul><p>5.2 <strong>虚拟机中无法识别 PF 网卡</strong></p><ul><li>检查虚拟机内的网络配置，确认 PF 是否已正确加载，并安装必要的驱动程序。</li></ul><p>5.3 <strong>性能问题</strong></p><ul><li>确保虚拟机配置中启用了 KVM 和 VFIO 驱动程序，确保最佳性能。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://docs.mellanox.com/">Mellanox ConnectX-6 Documentation</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9">Red Hat Enterprise Linux 9 Documentation</a></li><li><a href="https://libvirt.org/formatdomain.html">Libvirt Documentation</a></li><li><a href="https://www.qemu.org/documentation/">QEMU Documentation</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> PF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 SR-IOV VF 直通 (Passthrough)</title>
      <link href="/2024/08/14/rhel9.4_mlx_sriov_vf/"/>
      <url>/2024/08/14/rhel9.4_mlx_sriov_vf/</url>
      
        <content type="html"><![CDATA[<h1 id="在-ARM64-平台的-RHEL-9-4-上配置-Mellanox-ConnectX-6-网卡的-SR-IOV-VF-直通-Passthrough"><a href="#在-ARM64-平台的-RHEL-9-4-上配置-Mellanox-ConnectX-6-网卡的-SR-IOV-VF-直通-Passthrough" class="headerlink" title="在 ARM64 平台的 RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 SR-IOV VF 直通 (Passthrough)"></a>在 ARM64 平台的 RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 SR-IOV VF 直通 (Passthrough)</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>在虚拟化环境中，Mellanox ConnectX-6 网卡的单根输入输出虚拟化（SR-IOV）功能允许将网卡的虚拟功能（Virtual Functions, VFs）分配给虚拟机，从而实现高效的网络性能和资源隔离。详细介绍了如何在 ARM64 平台的 RHEL 9.4 上配置 Mellanox ConnectX-6 网卡的 SR-IOV 虚拟功能 (VF) 直通。</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h2><p>适用于系统管理员和虚拟化技术人员，帮助他们在 RHEL 9.4 ARM64 系统上配置 Mellanox ConnectX-6 网卡的 SR-IOV 虚拟功能 (VF) 直通，以优化虚拟化环境中的网络性能。</p><h2 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h2><ul><li><strong>系统管理员</strong>：确保系统已正确安装必要的软件包，且系统硬件支持 IOMMU 和 SR-IOV 功能。</li><li><strong>操作员</strong>：按照##配置 Mellanox ConnectX-6 网卡的 SR-IOV VF 直通，并确保其正确运行。</li></ul><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h2><ul><li>运行 RHEL 9.4 操作系统的 ARM64 服务器。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>Mellanox ConnectX-6 网卡，并确保服务器固件支持 IOMMU 和 SR-IOV 功能。</li></ul><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><h3 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h3><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf update -y</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装必要的驱动和工具</strong></p><ul><li><p>安装 Mellanox 网卡的驱动程序和相关工具(如果已经安装mlx驱动直接跳过)：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install -y mlnx-ofed-basic</span><br></pre></td></tr></table></figure></li><li><p>安装完毕后，重启服务器以加载新安装的驱动：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></li></ul><p>1.3 <strong>检查 IOMMU 支持</strong></p><ul><li><p>确保系统的固件（Firmware&#x2F;BIOS）设置中已启用 IOMMU 支持。</p></li><li><p>确认 IOMMU 已在内核启动参数中启用：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo grubby --update-kernel=ALL --args=<span class="string">&quot;iommu.passthrough=on&quot;</span></span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></li><li><p>重启后，使用以下命令确认 IOMMU 已启用：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i iommu</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-配置-Mellanox-ConnectX-6-的-SR-IOV"><a href="#2-配置-Mellanox-ConnectX-6-的-SR-IOV" class="headerlink" title="2. 配置 Mellanox ConnectX-6 的 SR-IOV"></a>2. <strong>配置 Mellanox ConnectX-6 的 SR-IOV</strong></h3><p>2.1 <strong>启用 SR-IOV 功能</strong></p><ul><li><p>使用 <code>lspci</code> 命令找到 Mellanox ConnectX-6 网卡的 PCI 总线地址：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep Mellanox</span><br></pre></td></tr></table></figure></li><li><p>记下类似 <code>0000:03:00.0</code> 的总线地址，这个地址表示网卡的物理功能（PF）。</p></li><li><p>在 <code>/sys/class/net/</code> 下找到对应的网卡接口（如 <code>enp3s0</code>），并配置启用 SR-IOV：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 8 | sudo <span class="built_in">tee</span> /sys/class/net/enp3s0/device/sriov_numvfs</span><br></pre></td></tr></table></figure></li><li><p>以上命令将在该网卡上启用 8 个虚拟功能（VFs）。可以根据需要调整数字。</p></li><li><p>可以通过下面的命令查询支持的最大值</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/class/net/enp3s0/device/sriov_totalvfs</span><br><span class="line">16</span><br></pre></td></tr></table></figure><p>2.2 <strong>验证 SR-IOV 配置</strong></p></li><li><p>使用 <code>ip link show</code> 或 <code>lspci | grep Mellanox</code> 命令，确认是否已创建 VFs：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip <span class="built_in">link</span> show enp3s0</span><br></pre></td></tr></table></figure></li><li><p>输出中应包含 <code>enp3s0</code> 及其下的 <code>vf 0</code> 至 <code>vf 7</code> 等信息。</p></li></ul><h3 id="3-配置-SR-IOV-VFs-的-Passthrough"><a href="#3-配置-SR-IOV-VFs-的-Passthrough" class="headerlink" title="3. 配置 SR-IOV VFs 的 Passthrough"></a>3. <strong>配置 SR-IOV VFs 的 Passthrough</strong></h3><p>3.1 <strong>识别并绑定 VF</strong></p><ul><li><p>使用 <code>lspci</code> 命令获取 SR-IOV VF 的 PCI 地址：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep Virtual</span><br></pre></td></tr></table></figure></li><li><p>将对应的 VF 通过 VFIO 驱动绑定：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe vfio</span><br><span class="line">sudo modprobe vfio-pci</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:02.0&quot;</span> &gt; /sys/bus/pci/devices/0000\:03\:02.0/driver/unbind</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;15b3 101e&quot;</span> &gt; /sys/bus/pci/drivers/vfio-pci/new_id</span><br></pre></td></tr></table></figure><p>   或者</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe vfio</span><br><span class="line">sudo modprobe vfio-pci</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:02.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/drivers/mlx5_core/unbind</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:02.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/drivers/vfio-pci/bind</span><br></pre></td></tr></table></figure></li><li><p>确认绑定成功：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci -nnk -d 15b3: | grep <span class="string">&quot;Kernel driver in use&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>输出应显示 <code>vfio-pci</code> 作为内核驱动。</p></li></ul><p>3.2 <strong>编辑虚拟机配置</strong></p><ul><li>使用 <code>virsh nodedev-list</code> 查找支持的设备   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pci_0000_03_02_0</span><br></pre></td></tr></table></figure></li><li>使用 <code>virsh nodedev-dumpxml pci_0000_03_02_0</code> 获取配置xml, 记录address   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;iommuGroup number=&#x27;62&#x27;&gt;</span><br><span class="line">  &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x03&#x27; slot=&#x27;0x02&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">&lt;/iommuGroup&gt;</span><br></pre></td></tr></table></figure></li><li>使用 <code>virsh edit</code> 或 <code>virt-manager</code> 将 VF 设备分配给虚拟机。示例 XML 配置：   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hostdev</span> <span class="attr">mode</span>=<span class="string">&#x27;subsystem&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">managed</span>=<span class="string">&#x27;yes&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x03&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x02&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x05&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hostdev</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>3.3 <strong>启用并启动虚拟机</strong></p><ul><li>编辑并保存虚拟机配置后，启动虚拟机：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virsh define /etc/libvirt/qemu/&lt;vm_name&gt;.xml</span><br><span class="line">virsh start &lt;vm_name&gt;</span><br></pre></td></tr></table></figure></li><li>在虚拟机中，使用 <code>ip link show</code> 或类似命令验证已分配的 VF 网卡。</li></ul><h3 id="4-维护与管理"><a href="#4-维护与管理" class="headerlink" title="4. 维护与管理"></a>4. <strong>维护与管理</strong></h3><p>4.1 <strong>释放 VF 资源</strong></p><ul><li>如果需要将 VF 资源从虚拟机中释放并返回主机，可以先关闭虚拟机并解除 VFIO 绑定：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">virsh shutdown &lt;vm_name&gt;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:02.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/drivers/vfio-pci/unbind</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;0000:03:02.0&quot;</span> | sudo <span class="built_in">tee</span> /sys/bus/pci/drivers/mlx5_core/bind</span><br></pre></td></tr></table></figure></li></ul><p>4.2 <strong>调整 VF 数量</strong></p><ul><li>如果需要更改启用的 VF 数量，可以编辑对应的 SR-IOV 配置：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &lt;new_number&gt; | sudo <span class="built_in">tee</span> /sys/class/net/enp3s0/device/sriov_numvfs</span><br></pre></td></tr></table></figure></li></ul><p>4.3 <strong>定期更新驱动</strong></p><ul><li>确保定期更新 Mellanox 驱动程序和固件，以获取最新的功能和性能改进：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf upgrade -y mlnx-ofed-basic</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-常见问题与故障排除"><a href="#5-常见问题与故障排除" class="headerlink" title="5. 常见问题与故障排除"></a>5. <strong>常见问题与故障排除</strong></h3><p>5.1 <strong>VF 无法绑定到虚拟机</strong></p><ul><li>检查是否已正确启用 IOMMU 和 SR-IOV 功能，确保 VFs 已成功创建并分配给虚拟机。</li></ul><p>5.2 <strong>虚拟机中无法识别 VF 网卡</strong></p><ul><li>检查虚拟机内的网络配置，确认 VF 是否已正确加载，并安装必要的驱动程序。</li></ul><p>5.3 <strong>性能问题</strong></p><ul><li>确保虚拟机配置中启用了 KVM 和 VFIO 驱动程序，确保最佳性能。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://docs.mellanox.com/">Mellanox ConnectX-6 Documentation</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9">Red Hat Enterprise Linux 9 Documentation</a></li><li><a href="https://libvirt.org/formatdomain.html">Libvirt Documentation</a></li><li><a href="https://www.qemu.org/documentation/">QEMU Documentation</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> SR-IOV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 `stress-ng` 进行系统压力测试</title>
      <link href="/2024/08/14/stress-ng_test/"/>
      <url>/2024/08/14/stress-ng_test/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-stress-ng-进行系统压力测试"><a href="#使用-stress-ng-进行系统压力测试" class="headerlink" title="使用 stress-ng 进行系统压力测试"></a>使用 <code>stress-ng</code> 进行系统压力测试</h1><hr><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p><code>stress-ng</code> 是一个功能强大的压力测试工具，能够对系统的 CPU、内存、I&#x2F;O、网络、磁盘等多个子系统进行深入测试。它可以帮助识别系统在极端条件下的稳定性问题，并用于评估硬件和软件的耐久性和性能。详细介绍了在 Linux 系统上安装、配置并运行 <code>stress-ng</code> 工具的过程，以进行全面的系统压力测试。</p><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h4><p>适用于需要验证系统硬件和软件稳定性的技术人员，尤其是需要测试 CPU、内存、I&#x2F;O、网络和磁盘性能的场景。</p><h4 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h4><ul><li><strong>系统管理员</strong>：确保系统已正确安装所有必需的依赖包，并具备执行测试所需的权限。</li><li><strong>操作员</strong>：按照本 SOP 正确执行 <code>stress-ng</code> 工具，确保测试顺利进行。</li></ul><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h4><ul><li>运行 Linux 操作系统的设备。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>有效的互联网连接以下载必要的软件包和工具。</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h4><h5 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h5><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装 <code>stress-ng</code> 工具</strong></p><ul><li><p><strong>在 Debian&#x2F;Ubuntu 系统上使用 <code>apt</code> 安装 <code>stress-ng</code>：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install stress-ng</span><br></pre></td></tr></table></figure></li><li><p><strong>在 RHEL&#x2F;CentOS 系统上使用 <code>yum</code> 安装 <code>stress-ng</code>：</strong></p><ul><li>首先，启用 EPEL 仓库（如果尚未启用）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure></li><li>然后安装 <code>stress-ng</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install stress-ng</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-配置与运行-stress-ng"><a href="#2-配置与运行-stress-ng" class="headerlink" title="2. 配置与运行 stress-ng"></a>2. <strong>配置与运行 <code>stress-ng</code></strong></h5><p>2.1 <strong>运行 CPU 压力测试</strong></p><ul><li>使用 <code>stress-ng</code> 工具对 CPU 进行压力测试。例如，以下命令将启动 4 个 CPU 工作线程，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --cpu 4 --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--cpu 4</code>：启动 4 个 CPU 工作线程。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.2 <strong>运行内存压力测试</strong></p><ul><li>对系统内存进行压力测试。例如，以下命令将启动 2 个内存工作线程，每个分配 256MB 内存，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --vm 2 --vm-bytes 256M --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--vm 2</code>：启动 2 个内存工作线程。</li><li><code>--vm-bytes 256M</code>：每个线程分配 256MB 内存。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.3 <strong>运行 I&#x2F;O 压力测试</strong></p><ul><li>对系统的 I&#x2F;O 操作进行压力测试。例如，以下命令将启动 4 个 I&#x2F;O 工作线程，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --io 4 --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--io 4</code>：启动 4 个 I&#x2F;O 工作线程。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.4 <strong>运行磁盘压力测试</strong></p><ul><li>对系统磁盘进行压力测试。例如，以下命令将启动 4 个磁盘工作线程，每个线程执行 10MB 的写操作，并持续运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --hdd 4 --hdd-bytes 10M --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--hdd 4</code>：启动 4 个磁盘工作线程。</li><li><code>--hdd-bytes 10M</code>：每个线程执行 10MB 的写操作。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.5 <strong>综合压力测试</strong></p><ul><li>运行包含多个子系统的综合压力测试。例如，以下命令将同时对 CPU、内存、I&#x2F;O 和磁盘进行压力测试，并持续运行 600 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --cpu 4 --vm 2 --vm-bytes 128M --io 2 --hdd 2 --hdd-bytes 5M --<span class="built_in">timeout</span> 600</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--cpu 4</code>：启动 4 个 CPU 工作线程。</li><li><code>--vm 2 --vm-bytes 128M</code>：启动 2 个内存工作线程，每个线程分配 128MB 内存。</li><li><code>--io 2</code>：启动 2 个 I&#x2F;O 工作线程。</li><li><code>--hdd 2 --hdd-bytes 5M</code>：启动 2 个磁盘工作线程，每个线程执行 5MB 的写操作。</li><li><code>--timeout 600</code>：测试持续 600 秒（10 分钟）。</li></ul></li></ul><p>2.6 <strong>生成性能报告</strong></p><ul><li>使用 <code>--metrics-brief</code> 选项生成一个简短的性能报告，显示测试的主要结果：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --cpu 4 --<span class="built_in">timeout</span> 300 --metrics-brief</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-监控与分析测试结果"><a href="#3-监控与分析测试结果" class="headerlink" title="3. 监控与分析测试结果"></a>3. <strong>监控与分析测试结果</strong></h5><p>3.1 <strong>监控测试进度</strong></p><ul><li>在测试过程中，可以在终端查看 <code>stress-ng</code> 的输出，监控测试的进展情况。</li></ul><p>3.2 <strong>分析测试结果</strong></p><ul><li><code>stress-ng</code> 工具本身可以生成详细的性能报告，您可以通过分析报告来了解系统在压力测试下的表现。</li></ul><p>3.3 <strong>保存测试日志</strong></p><ul><li>可以将测试日志保存到文件中，以便后续分析：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress-ng --cpu 4 --<span class="built_in">timeout</span> 300 --metrics-brief &gt; stress-ng-log.txt</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-优化与维护"><a href="#4-优化与维护" class="headerlink" title="4. 优化与维护"></a>4. <strong>优化与维护</strong></h5><p>4.1 <strong>定期测试</strong></p><ul><li>建议定期运行 <code>stress-ng</code> 工具，特别是在系统进行重大变更（如硬件升级或系统更新）之后，以确保系统的持续稳定性。</li></ul><p>4.2 <strong>调整参数</strong></p><ul><li>根据系统的具体需求和测试目标，调整 <code>stress-ng</code> 的参数，以便更好地检测系统潜在问题。</li></ul><h5 id="5-常见问题与故障排除"><a href="#5-常见问题与故障排除" class="headerlink" title="5. 常见问题与故障排除"></a>5. <strong>常见问题与故障排除</strong></h5><p>5.1 <strong>测试失败或系统崩溃</strong></p><ul><li>如果在测试过程中系统崩溃或测试失败，请检查系统日志以确定故障原因。可能需要降低测试负荷，或排查硬件问题。</li></ul><p>5.2 <strong>系统资源不足</strong></p><ul><li>如果在测试过程中出现内存或 CPU 资源不足的错误，考虑减少分配给测试的资源量，或调整系统配置。</li></ul><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h4><ul><li><a href="https://github.com/ColinIanKing/stress-ng">stress-ng GitHub Repository</a></li><li><a href="https://linux.die.net/man/1/stress-ng">Linux Performance Tools</a></li><li><a href="https://linuxconfig.org/bash-scripting-tutorial-for-beginners">Bash Scripting Basics</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> stress-ng </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 `stress` 进行系统压力测试</title>
      <link href="/2024/08/14/stress_test/"/>
      <url>/2024/08/14/stress_test/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-stress-进行系统压力测试"><a href="#使用-stress-进行系统压力测试" class="headerlink" title="使用 stress 进行系统压力测试"></a>使用 <code>stress</code> 进行系统压力测试</h1><hr><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p><code>stress</code> 是一个简单但功能强大的工具，用于对系统的 CPU、内存、I&#x2F;O 和磁盘进行压力测试。通过施加高负荷，它可以帮助识别系统在极端条件下的稳定性问题。详细介绍了在 Linux 系统上安装、配置并运行 <code>stress</code> 工具的过程，以进行全面的系统压力测试。</p><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h4><p>适用于需要验证系统硬件和软件稳定性的技术人员，尤其是在测试 CPU、内存、I&#x2F;O 和磁盘性能时使用。</p><h4 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h4><ul><li><strong>系统管理员</strong>：确保系统已正确安装所有必需的依赖包，并具备执行测试所需的权限。</li><li><strong>操作员</strong>：按照本 SOP 正确执行 <code>stress</code> 工具，确保测试顺利进行。</li></ul><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h4><ul><li>运行 Linux 操作系统的设备。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>有效的互联网连接以下载必要的软件包和工具。</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h4><h5 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h5><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装 Stress 工具</strong></p><ul><li><p><strong>在 Debian&#x2F;Ubuntu 系统上使用 <code>apt</code> 安装 <code>stress</code>：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install stress</span><br></pre></td></tr></table></figure></li><li><p><strong>在 RHEL&#x2F;CentOS 系统上使用 <code>yum</code> 安装 <code>stress</code>：</strong></p><ul><li>首先，启用 EPEL 仓库（如果尚未启用）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure></li><li>然后安装 <code>stress</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install stress</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-配置与运行-stress"><a href="#2-配置与运行-stress" class="headerlink" title="2. 配置与运行 stress"></a>2. <strong>配置与运行 <code>stress</code></strong></h5><p>2.1 <strong>运行 CPU 压力测试</strong></p><ul><li>使用 <code>stress</code> 工具对 CPU 进行压力测试。例如，以下命令将启动 4 个 CPU 工作线程，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --cpu 4 --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--cpu 4</code>：启动 4 个 CPU 工作线程。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.2 <strong>运行内存压力测试</strong></p><ul><li>对系统内存进行压力测试。例如，以下命令将启动 2 个内存工作线程，每个分配 256MB 内存，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --vm 2 --vm-bytes 256M --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--vm 2</code>：启动 2 个内存工作线程。</li><li><code>--vm-bytes 256M</code>：每个线程分配 256MB 内存。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.3 <strong>运行 I&#x2F;O 压力测试</strong></p><ul><li>对系统的 I&#x2F;O 操作进行压力测试。例如，以下命令将启动 4 个 I&#x2F;O 工作线程，并使其各自运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --io 4 --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--io 4</code>：启动 4 个 I&#x2F;O 工作线程。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><p>2.4 <strong>运行磁盘压力测试</strong></p><ul><li>对系统磁盘进行压力测试。例如，以下命令将启动 4 个磁盘工作线程，每个线程执行 10MB 的写操作，并持续运行 300 秒：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stress --hdd 4 --hdd-bytes 10M --<span class="built_in">timeout</span> 300</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>--hdd 4</code>：启动 4 个磁盘工作线程。</li><li><code>--hdd-bytes 10M</code>：每个线程执行 10MB 的写操作。</li><li><code>--timeout 300</code>：测试持续 300 秒（5 分钟）。</li></ul></li></ul><h5 id="3-监控与分析测试结果"><a href="#3-监控与分析测试结果" class="headerlink" title="3. 监控与分析测试结果"></a>3. <strong>监控与分析测试结果</strong></h5><p>3.1 <strong>监控测试进度</strong></p><ul><li>在测试过程中，可以在终端查看 <code>stress</code> 输出，监控测试的进展情况。</li></ul><p>3.2 <strong>分析测试结果</strong></p><ul><li><code>stress</code> 工具本身不会生成详细的测试报告，但可以通过系统日志和资源监控工具（如 <code>htop</code> 或 <code>dstat</code>）来分析系统在压力测试下的表现。</li></ul><h5 id="4-优化与维护"><a href="#4-优化与维护" class="headerlink" title="4. 优化与维护"></a>4. <strong>优化与维护</strong></h5><p>4.1 <strong>定期测试</strong></p><ul><li>建议定期运行 <code>stress</code> 工具，特别是在系统进行重大变更（如硬件升级或系统更新）之后，以确保系统的持续稳定性。</li></ul><p>4.2 <strong>调整参数</strong></p><ul><li>根据系统的具体需求和测试目标，调整 <code>stress</code> 的参数，以便更好地检测系统潜在问题。</li></ul><h5 id="5-常见问题与故障排除"><a href="#5-常见问题与故障排除" class="headerlink" title="5. 常见问题与故障排除"></a>5. <strong>常见问题与故障排除</strong></h5><p>5.1 <strong>测试失败或系统崩溃</strong></p><ul><li>如果在测试过程中系统崩溃或测试失败，请检查系统日志以确定故障原因。可能需要降低测试负荷，或排查硬件问题。</li></ul><p>5.2 <strong>系统资源不足</strong></p><ul><li>如果在测试过程中出现内存或 CPU 资源不足的错误，考虑减少分配给测试的资源量，或调整系统配置。</li></ul><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h4><ul><li><a href="https://github.com/stress-ng/stress-ng">Stress GitHub Repository</a></li><li><a href="https://linux.die.net/man/1/stress">Linux Performance Tools</a></li><li><a href="https://linuxconfig.org/bash-scripting-tutorial-for-beginners">Bash Scripting Basics</a></li></ul><hr><p>本 SOP 提供了使用 <code>stress</code> 工具进行系统压力测试的详细步骤，旨在帮助用户识别和解决潜在的系统稳定性问题。通过这些测试，您可以确保系统在高负荷下的性能表现，并及时采取措施修复可能的故障。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> stress </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPv4 和 IPv6 路由管理</title>
      <link href="/2024/08/07/IPv4_and_IPv6_Routing_Tutorial/"/>
      <url>/2024/08/07/IPv4_and_IPv6_Routing_Tutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="IPv4-和-IPv6-路由管理"><a href="#IPv4-和-IPv6-路由管理" class="headerlink" title="IPv4 和 IPv6 路由管理"></a>IPv4 和 IPv6 路由管理</h1><hr><p>Linux 系统中 IPv4 和 IPv6 路由的基本操作，包括查看、添加和删除路由。</p><h2 id="IPv4-路由"><a href="#IPv4-路由" class="headerlink" title="IPv4 路由"></a>IPv4 路由</h2><h3 id="1-查看-IPv4-路由表"><a href="#1-查看-IPv4-路由表" class="headerlink" title="1. 查看 IPv4 路由表"></a>1. 查看 IPv4 路由表</h3><p>使用下面的命令来查看当前的 IPv4 路由表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route</span><br></pre></td></tr></table></figure><h3 id="2-添加-IPv4-路由"><a href="#2-添加-IPv4-路由" class="headerlink" title="2. 添加 IPv4 路由"></a>2. 添加 IPv4 路由</h3><p>根据网络配置需求，可以使用以下命令添加路由：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route add [目的网络/掩码] via [网关地址] dev [网卡设备名]</span><br></pre></td></tr></table></figure><p>例如，如果想要所有发往 <code>192.168.1.0/24</code> 网络的数据包都通过网关 <code>192.168.0.1</code> 和网卡 <code>eth0</code> 发送，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route add 192.168.1.0/24 via 192.168.0.1 dev eth0</span><br></pre></td></tr></table></figure><h3 id="3-删除-IPv4-路由"><a href="#3-删除-IPv4-路由" class="headerlink" title="3. 删除 IPv4 路由"></a>3. 删除 IPv4 路由</h3><p>从路由表中删除一条路由，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route del [目的网络/掩码]</span><br></pre></td></tr></table></figure><p>例如，删除之前添加的路由：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route del 192.168.1.0/24</span><br></pre></td></tr></table></figure><h2 id="IPv6-路由"><a href="#IPv6-路由" class="headerlink" title="IPv6 路由"></a>IPv6 路由</h2><h3 id="1-查看-IPv6-路由表"><a href="#1-查看-IPv6-路由表" class="headerlink" title="1. 查看 IPv6 路由表"></a>1. 查看 IPv6 路由表</h3><p>使用下面的命令来查看当前的 IPv6 路由表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip -6 route</span><br></pre></td></tr></table></figure><h3 id="2-添加-IPv6-路由"><a href="#2-添加-IPv6-路由" class="headerlink" title="2. 添加 IPv6 路由"></a>2. 添加 IPv6 路由</h3><p>根据网络配置需求，可以使用以下命令添加路由：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip -6 route add [目的地址/前缀] via [网关地址] dev [网卡设备名]</span><br></pre></td></tr></table></figure><p>例如，如果想要所有发往 <code>2001:db8::/32</code> 网络的数据包都通过网关 <code>fe80::1</code> 和网卡 <code>eth0</code> 发送，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip -6 route add 2001:db8::/32 via fe80::1 dev eth0</span><br></pre></td></tr></table></figure><h3 id="3-删除-IPv6-路由"><a href="#3-删除-IPv6-路由" class="headerlink" title="3. 删除 IPv6 路由"></a>3. 删除 IPv6 路由</h3><p>从路由表中删除一条路由，可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip -6 route del [目的地址/前缀]</span><br></pre></td></tr></table></figure><p>例如，删除之前添加的路由：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip -6 route del 2001:db8::/32</span><br></pre></td></tr></table></figure><h2 id="持久化路由设置"><a href="#持久化路由设置" class="headerlink" title="持久化路由设置"></a>持久化路由设置</h2><p>为了使路由设置在系统重启后依然生效，可以将命令添加到启动脚本中，或者在配置文件中设置。这具体依赖于使用的 Linux 发行版。</p><h2 id="调试和故障排查"><a href="#调试和故障排查" class="headerlink" title="调试和故障排查"></a>调试和故障排查</h2><p>使用以下命令可以帮助调试和确认路由设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip route show</span><br><span class="line">ip -6 route show</span><br></pre></td></tr></table></figure><p>或者，使用 <code>ping</code> 或 <code>ping6</code> 测试网络连通性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping [IPv4地址]</span><br><span class="line">ping6 [IPv6地址]</span><br></pre></td></tr></table></figure><p>确保有适当的权限执行这些命令，特别是使用 <code>sudo</code> 来获取必要的管理员权限。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带宽和存储单位转换</title>
      <link href="/2024/08/07/bandwidth_storage_convert/"/>
      <url>/2024/08/07/bandwidth_storage_convert/</url>
      
        <content type="html"><![CDATA[<h1 id="带宽和存储单位转换"><a href="#带宽和存储单位转换" class="headerlink" title="带宽和存储单位转换"></a>带宽和存储单位转换</h1><h2 id="带宽单位转换（基于十进制）"><a href="#带宽单位转换（基于十进制）" class="headerlink" title="带宽单位转换（基于十进制）"></a>带宽单位转换（基于十进制）</h2><ol><li><strong>1 字节 (B) &#x3D; 8 比特 (b)</strong></li><li><strong>1 千比特 (Kb) &#x3D; 1000 比特 (b)</strong></li><li><strong>1 兆比特 (Mb) &#x3D; 1000 千比特 (Kb)</strong></li><li><strong>1 吉比特 (Gb) &#x3D; 1000 兆比特 (Mb)</strong></li><li><strong>1 太比特 (Tb) &#x3D; 1000 吉比特 (Gb)</strong></li></ol><h2 id="存储单位转换（基于二进制）"><a href="#存储单位转换（基于二进制）" class="headerlink" title="存储单位转换（基于二进制）"></a>存储单位转换（基于二进制）</h2><ol><li><strong>1 千字节 (KiB) &#x3D; 1024 字节 (B)</strong></li><li><strong>1 兆字节 (MiB) &#x3D; 1024 千字节 (KiB)</strong></li><li><strong>1 吉字节 (GiB) &#x3D; 1024 兆字节 (MiB)</strong></li><li><strong>1 太字节 (TiB) &#x3D; 1024 吉字节 (GiB)</strong></li></ol><h2 id="带宽和存储的相互转换"><a href="#带宽和存储的相互转换" class="headerlink" title="带宽和存储的相互转换"></a>带宽和存储的相互转换</h2><h3 id="示例1：带宽转存储"><a href="#示例1：带宽转存储" class="headerlink" title="示例1：带宽转存储"></a>示例1：带宽转存储</h3><p>假设有一个文件大小为100 MiB，下载速度为20 Mbps，需要多长时间下载完这个文件？</p><ol><li><p><strong>转换文件大小为比特</strong>：</p><ul><li>100 MiB &#x3D; 100 × 1024 × 1024 × 8 &#x3D; 838,860,800 比特 (b)</li></ul></li><li><p><strong>计算下载时间</strong>：</p><ul><li>时间 (秒) &#x3D; 文件大小 (比特) &#x2F; 带宽 (比特每秒)</li><li>时间 &#x3D; 838,860,800 b &#x2F; 20,000,000 bps &#x3D; 41.94 秒</li></ul></li></ol><h3 id="示例2：存储转带宽"><a href="#示例2：存储转带宽" class="headerlink" title="示例2：存储转带宽"></a>示例2：存储转带宽</h3><p>假设有一个网络带宽为50 Mbps，每秒能够传输多少 GiB 的数据？</p><ol><li><p><strong>转换带宽为字节每秒</strong>：</p><ul><li>50 Mbps &#x3D; 50 × 1000 × 1000 &#x2F; 8 &#x3D; 6,250,000 字节每秒 (Bps)</li></ul></li><li><p><strong>转换为GiB每秒</strong>：</p><ul><li>6,250,000 Bps &#x3D; 6,250,000 &#x2F; 1024 &#x2F; 1024 &#x2F; 1024 &#x3D; 0.0058 GiB 每秒</li></ul></li></ol><p>通过以上示例可以看到，带宽和存储单位可以通过字节和比特之间的转换进行相互转换。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numactl 操作流程</title>
      <link href="/2024/08/07/numactl_sop/"/>
      <url>/2024/08/07/numactl_sop/</url>
      
        <content type="html"><![CDATA[<h1 id="numactl-操作流程"><a href="#numactl-操作流程" class="headerlink" title="numactl 操作流程"></a><code>numactl</code> 操作流程</h1><hr><h2 id="1-检查NUMA节点信息"><a href="#1-检查NUMA节点信息" class="headerlink" title="1. 检查NUMA节点信息"></a>1. 检查NUMA节点信息</h2><p>在进行任何绑定操作之前，先检查系统的NUMA节点信息，以了解可用的CPU和内存节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --hardware</span><br></pre></td></tr></table></figure><p>记录输出信息，确保了解系统中所有NUMA节点及其CPU核心分布。</p><h2 id="2-确定需要绑定的CPU核心和NUMA节点"><a href="#2-确定需要绑定的CPU核心和NUMA节点" class="headerlink" title="2. 确定需要绑定的CPU核心和NUMA节点"></a>2. 确定需要绑定的CPU核心和NUMA节点</h2><p>根据应用程序的需求和系统的NUMA节点分布，确定需要绑定的CPU核心和内存节点。例如，假设需要绑定到CPU 2和3，并使用NUMA节点0上的内存。</p><h2 id="3-绑定CPU核心"><a href="#3-绑定CPU核心" class="headerlink" title="3. 绑定CPU核心"></a>3. 绑定CPU核心</h2><p>将应用程序绑定到特定的CPU核心，以提高CPU利用率和性能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --physcpubind=2,3 your_command</span><br></pre></td></tr></table></figure><p>例如，运行名为 <code>my_program</code> 的应用程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --physcpubind=2,3 ./my_program</span><br></pre></td></tr></table></figure><h2 id="4-绑定NUMA节点内存"><a href="#4-绑定NUMA节点内存" class="headerlink" title="4. 绑定NUMA节点内存"></a>4. 绑定NUMA节点内存</h2><p>如果还需要绑定到特定的NUMA节点内存，使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --membind=0 your_command</span><br></pre></td></tr></table></figure><p>例如，运行名为 <code>my_program</code> 的应用程序，并绑定到NUMA节点0的内存：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --physcpubind=2,3 --membind=0 ./my_program</span><br></pre></td></tr></table></figure><h2 id="5-验证绑定结果"><a href="#5-验证绑定结果" class="headerlink" title="5. 验证绑定结果"></a>5. 验证绑定结果</h2><p>运行以下命令来检查进程的CPU和内存绑定情况，确保绑定成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --show</span><br></pre></td></tr></table></figure><h2 id="6-测试和监控"><a href="#6-测试和监控" class="headerlink" title="6. 测试和监控"></a>6. 测试和监控</h2><p>运行应用程序后，监控其性能和资源使用情况，确保绑定操作达到了预期效果。可以使用以下工具进行监控：</p><ul><li><code>top</code></li><li><code>htop</code></li><li><code>numastat</code></li><li><code>perf</code></li></ul><h1 id="示例SOP"><a href="#示例SOP" class="headerlink" title="示例SOP"></a>示例SOP</h1><h2 id="步骤1：检查NUMA节点信息"><a href="#步骤1：检查NUMA节点信息" class="headerlink" title="步骤1：检查NUMA节点信息"></a>步骤1：检查NUMA节点信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --hardware</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">available: 2 nodes (0-1)</span><br><span class="line">node 0 cpus: 0 1 2 3</span><br><span class="line">node 0 size: 32632 MB</span><br><span class="line">node 0 free: 12345 MB</span><br><span class="line">node 1 cpus: 4 5 6 7</span><br><span class="line">node 1 size: 32768 MB</span><br><span class="line">node 1 free: 23456 MB</span><br></pre></td></tr></table></figure><h2 id="步骤2：确定绑定的CPU核心和NUMA节点"><a href="#步骤2：确定绑定的CPU核心和NUMA节点" class="headerlink" title="步骤2：确定绑定的CPU核心和NUMA节点"></a>步骤2：确定绑定的CPU核心和NUMA节点</h2><p>假设需要绑定到CPU 2和3，并使用NUMA节点0上的内存。</p><h2 id="步骤3：绑定CPU核心"><a href="#步骤3：绑定CPU核心" class="headerlink" title="步骤3：绑定CPU核心"></a>步骤3：绑定CPU核心</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --physcpubind=2,3 ./my_program</span><br></pre></td></tr></table></figure><h2 id="步骤4：绑定NUMA节点内存"><a href="#步骤4：绑定NUMA节点内存" class="headerlink" title="步骤4：绑定NUMA节点内存"></a>步骤4：绑定NUMA节点内存</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --physcpubind=2,3 --membind=0 ./my_program</span><br></pre></td></tr></table></figure><h2 id="步骤5：验证绑定结果"><a href="#步骤5：验证绑定结果" class="headerlink" title="步骤5：验证绑定结果"></a>步骤5：验证绑定结果</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numactl --show</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">policy: default</span><br><span class="line">physcpubind: 2 3 </span><br><span class="line">cpubind: 0 </span><br><span class="line">membind: 0 </span><br></pre></td></tr></table></figure><h2 id="步骤6：测试和监控"><a href="#步骤6：测试和监控" class="headerlink" title="步骤6：测试和监控"></a>步骤6：测试和监控</h2><p>使用 <code>htop</code> 或 <code>numastat</code> 等工具监控应用程序的性能和资源使用情况。</p><p>通过上述步骤，可以确保应用程序在NUMA系统上得到优化运行。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Numactl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在 Linux 系统中进入 S0、S1、S2、S3、S4 和 S5 模式</title>
      <link href="/2024/08/06/linux_power_state_mode/"/>
      <url>/2024/08/06/linux_power_state_mode/</url>
      
        <content type="html"><![CDATA[<h1 id="如何在-Linux-系统中进入-S0、S1、S2、S3、S4-和-S5-模式"><a href="#如何在-Linux-系统中进入-S0、S1、S2、S3、S4-和-S5-模式" class="headerlink" title="如何在 Linux 系统中进入 S0、S1、S2、S3、S4 和 S5 模式"></a>如何在 Linux 系统中进入 S0、S1、S2、S3、S4 和 S5 模式</h1><hr><h2 id="检查系统支持的电源模式"><a href="#检查系统支持的电源模式" class="headerlink" title="检查系统支持的电源模式"></a>检查系统支持的电源模式</h2><p>在进入这些模式之前，可以使用以下命令来检查系统支持哪些电源状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/power/state</span><br></pre></td></tr></table></figure><p>该命令的输出可能包括：</p><ul><li><code>freeze</code>：冻结当前任务，不关闭任何设备。</li><li><code>standby</code>：进入 S1 模式。</li><li><code>mem</code>：进入 S3 模式。</li><li><code>disk</code>：进入 S4 模式，即休眠，将内存内容保存到磁盘。</li></ul><h2 id="各电源模式简介"><a href="#各电源模式简介" class="headerlink" title="各电源模式简介"></a>各电源模式简介</h2><ul><li>S0（工作状态）：系统处于完全开机状态，所有部件都在运行。</li><li>S1（待机）：CPU 停止执行指令，但内存和其他关键部件保持供电。</li><li>S2（待机）：CPU 和系统缓存停止供电，但内存保持供电。</li><li>S3（挂起到内存）：系统状态保存到内存中，除内存外的所有部件都断电。</li><li>S4（休眠）：系统状态保存到硬盘，所有部件断电。系统恢复时从硬盘读取状态。</li><li>S5（软关机）：系统完全关机，但电源仍然供电，可以通过电源按钮启动。</li></ul><h2 id="进入各电源模式的命令"><a href="#进入各电源模式的命令" class="headerlink" title="进入各电源模式的命令"></a>进入各电源模式的命令</h2><ul><li><p>S0 模式（工作状态）<br>无需特殊命令，系统开机时即处于 S0 模式。</p></li><li><p>S1 模式（Standby）<br>使用 echo 命令：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> standby | sudo <span class="built_in">tee</span> /sys/power/state</span><br></pre></td></tr></table></figure><ul><li>S2 模式（待机）<br>请注意，S2 模式在很多系统上并不常用或不被支持。如果系统支持，可以尝试：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> standby | sudo <span class="built_in">tee</span> /sys/power/state</span><br></pre></td></tr></table></figure><ul><li>S3 模式（Suspend-to-RAM）</li></ul><p><strong>方法一：使用 systemctl 命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">suspend</span></span><br></pre></td></tr></table></figure><p><strong>方法二：使用 echo 命令</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> mem | sudo <span class="built_in">tee</span> /sys/power/state</span><br></pre></td></tr></table></figure><ul><li>S4 模式（休眠）<br>使用 systemctl 命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl hibernate</span><br></pre></td></tr></table></figure><p>或者使用 echo 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> disk | sudo <span class="built_in">tee</span> /sys/power/state</span><br></pre></td></tr></table></figure><ul><li>S5 模式（软关机）<br>使用 systemctl 命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl poweroff</span><br></pre></td></tr></table></figure><h2 id="示例操作"><a href="#示例操作" class="headerlink" title="示例操作"></a>示例操作</h2><p><strong>1. 检查系统支持的电源模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/power/state</span><br><span class="line">freeze standby mem disk</span><br></pre></td></tr></table></figure><p><strong>2. 进入 S1 模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> standby | sudo <span class="built_in">tee</span> /sys/power/state</span><br></pre></td></tr></table></figure><p><strong>3. 进入 S3 模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">suspend</span></span><br></pre></td></tr></table></figure><p><strong>4. 进入 S4 模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl hibernate</span><br></pre></td></tr></table></figure><p><strong>5. 进入 S5 模式：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl poweroff</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>硬件支持：确保你的硬件支持相应的电源模式。</p><p>数据保存：进入这些模式前保存所有未保存的工作，以避免数据丢失。</p><p>驱动支持：有些系统和设备驱动可能对某些电源模式支持不完善，可能会导致恢复时出现问题。 </p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 连接 USB 串口教程</title>
      <link href="/2024/08/05/Linux_USB_Serial_Tutorial/"/>
      <url>/2024/08/05/Linux_USB_Serial_Tutorial/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-连接-USB-串口教程"><a href="#Linux-连接-USB-串口教程" class="headerlink" title="Linux 连接 USB 串口教程"></a>Linux 连接 USB 串口教程</h1><hr><p>在Linux系统中，连接USB串口设备通常需要以下几个步骤：</p><h2 id="1-确认系统识别到USB串口设备"><a href="#1-确认系统识别到USB串口设备" class="headerlink" title="1. 确认系统识别到USB串口设备"></a>1. 确认系统识别到USB串口设备</h2><p>插入USB串口设备后，可以使用 <code>dmesg</code> 命令来查看系统是否识别到该设备。输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep ttyUSB</span><br></pre></td></tr></table></figure><p>应该看到类似以下的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[12345.678901] usb 1-1: cp210x converter now attached to ttyUSB0</span><br></pre></td></tr></table></figure><p>这表示系统已将USB串口设备识别为 <code>/dev/ttyUSB0</code>。</p><h2 id="2-安装必要的软件"><a href="#2-安装必要的软件" class="headerlink" title="2. 安装必要的软件"></a>2. 安装必要的软件</h2><p>使用USB串口设备通常需要安装 <code>screen</code> 或 <code>minicom</code> 等终端仿真软件。你可以使用以下命令来安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install screen</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install minicom</span><br></pre></td></tr></table></figure><h2 id="3-连接到USB串口设备"><a href="#3-连接到USB串口设备" class="headerlink" title="3. 连接到USB串口设备"></a>3. 连接到USB串口设备</h2><h3 id="使用-screen"><a href="#使用-screen" class="headerlink" title="使用 screen"></a>使用 screen</h3><p>可以使用 <code>screen</code> 命令连接到USB串口设备。例如，如果设备被识别为 <code>/dev/ttyUSB0</code>，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen /dev/ttyUSB0 115200</span><br></pre></td></tr></table></figure><p>这里的 <code>115200</code> 是波特率，根据你的设备配置进行调整。</p><h3 id="使用-minicom"><a href="#使用-minicom" class="headerlink" title="使用 minicom"></a>使用 minicom</h3><p>首先，配置 <code>minicom</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo minicom -s</span><br></pre></td></tr></table></figure><p>在配置界面中，选择“串口设置”，然后设置串口设备为 <code>/dev/ttyUSB0</code>，并设置相应的波特率。</p><p>配置完成后，选择“保存并退出”。然后可以使用以下命令连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minicom</span><br></pre></td></tr></table></figure><h2 id="4-退出连接"><a href="#4-退出连接" class="headerlink" title="4. 退出连接"></a>4. 退出连接</h2><h3 id="使用-screen-1"><a href="#使用-screen-1" class="headerlink" title="使用 screen"></a>使用 screen</h3><p>要退出 <code>screen</code> 会话，按 <code>Ctrl-a</code> 然后按 <code>k</code>，再按 <code>y</code> 确认。</p><h3 id="使用-minicom-1"><a href="#使用-minicom-1" class="headerlink" title="使用 minicom"></a>使用 minicom</h3><p>要退出 <code>minicom</code>，按 <code>Ctrl-a</code> 然后按 <code>q</code>，再选择“是”确认退出。</p><hr><p>以上就是在Linux系统中连接USB串口设备的基本步骤。</p><h2 id="DB9-串口线序"><a href="#DB9-串口线序" class="headerlink" title="DB9 串口线序"></a>DB9 串口线序</h2><h3 id="DB9公头（Male）针脚排列"><a href="#DB9公头（Male）针脚排列" class="headerlink" title="DB9公头（Male）针脚排列"></a>DB9公头（Male）针脚排列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5  4  3  2  1</span><br><span class="line"> ●  ●  ●  ●  ●</span><br><span class="line">  9  8  7  6</span><br><span class="line"> ●  ●  ●  ● </span><br></pre></td></tr></table></figure><h3 id="DB9母头（Female）针脚排列"><a href="#DB9母头（Female）针脚排列" class="headerlink" title="DB9母头（Female）针脚排列"></a>DB9母头（Female）针脚排列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1  2  3  4  5</span><br><span class="line"> ●  ●  ●  ●  ●</span><br><span class="line">  6  7  8  9</span><br><span class="line"> ●  ●  ●  ● </span><br></pre></td></tr></table></figure><h3 id="针脚定义"><a href="#针脚定义" class="headerlink" title="针脚定义"></a>针脚定义</h3><table><thead><tr><th>针脚编号</th><th>信号名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>DCD (Data Carrier Detect)</td><td>数据载波检测</td></tr><tr><td>2</td><td>RXD (Receive Data)</td><td>接收数据</td></tr><tr><td>3</td><td>TXD (Transmit Data)</td><td>发送数据</td></tr><tr><td>4</td><td>DTR (Data Terminal Ready)</td><td>数据终端准备好</td></tr><tr><td>5</td><td>GND (Ground)</td><td>信号地</td></tr><tr><td>6</td><td>DSR (Data Set Ready)</td><td>数据设置准备好</td></tr><tr><td>7</td><td>RTS (Request to Send)</td><td>请求发送</td></tr><tr><td>8</td><td>CTS (Clear to Send)</td><td>清除发送</td></tr><tr><td>9</td><td>RI (Ring Indicator)</td><td>振铃指示</td></tr></tbody></table><h3 id="常用连接"><a href="#常用连接" class="headerlink" title="常用连接"></a>常用连接</h3><h4 id="1-直连线（也称为直通线）"><a href="#1-直连线（也称为直通线）" class="headerlink" title="1. 直连线（也称为直通线）"></a>1. 直连线（也称为直通线）</h4><ul><li>这种连接方式通常用于PC与调制解调器（Modem）之间的连接。</li><li>直连线的针脚对应关系如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DB9公头 (Male)       DB9母头 (Female)</span><br><span class="line">2 (RXD)  &lt;--------&gt;  2 (RXD)</span><br><span class="line">3 (TXD)  &lt;--------&gt;  3 (TXD)</span><br><span class="line">5 (GND)  &lt;--------&gt;  5 (GND)</span><br><span class="line">7 (RTS)  &lt;--------&gt;  7 (RTS)</span><br><span class="line">8 (CTS)  &lt;--------&gt;  8 (CTS)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-交叉线（也称为null-modem线）"><a href="#2-交叉线（也称为null-modem线）" class="headerlink" title="2. 交叉线（也称为null modem线）"></a>2. 交叉线（也称为null modem线）</h4><ul><li>这种连接方式用于PC与PC之间，或PC与串口设备之间的直接通信。</li><li>交叉线的针脚对应关系如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DB9公头 (Male)       DB9公头 (Male)</span><br><span class="line">2 (RXD)  &lt;--------&gt;  3 (TXD)</span><br><span class="line">3 (TXD)  &lt;--------&gt;  2 (RXD)</span><br><span class="line">5 (GND)  &lt;--------&gt;  5 (GND)</span><br><span class="line">7 (RTS)  &lt;--------&gt;  8 (CTS)</span><br><span class="line">8 (CTS)  &lt;--------&gt;  7 (RTS)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> Serial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RHEL9 网络配置</title>
      <link href="/2024/07/29/RHEL9_network_config/"/>
      <url>/2024/07/29/RHEL9_network_config/</url>
      
        <content type="html"><![CDATA[<h1 id="RHEL9-网络配置"><a href="#RHEL9-网络配置" class="headerlink" title="RHEL9 网络配置"></a>RHEL9 网络配置</h1><hr><h2 id="开关interface和profile"><a href="#开关interface和profile" class="headerlink" title="开关interface和profile"></a>开关interface和profile</h2><ol><li><p><strong>获取网络状态</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection</span><br><span class="line">NAME           UUID                                  TYPE      DEVICE</span><br><span class="line">Profile 2      21906cd8-c04d-45fd-9b7f-e6e85c43f891  ethernet  enP21p1s0f1np1</span><br><span class="line">enP21s17f1np1  f9ed821f-f3db-46ea-90fd-13dd74dc5587  ethernet  --</span><br></pre></td></tr></table></figure></li><li><p><strong>ifdown profile</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ifdown &quot;Profile 2&quot;</span><br><span class="line">Connection &#x27;Profile 2&#x27; successfully deactivated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/7)</span><br></pre></td></tr></table></figure></li><li><p><strong>link down interface</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ip link set enP21p1s0f1np1 down</span><br></pre></td></tr></table></figure></li><li><p><strong>link up interface</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ip link set enP21p1s0f1np1 up</span><br></pre></td></tr></table></figure></li><li><p><strong>ifup interface</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ifup &quot;Profile 2&quot;</span><br><span class="line">Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/8)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>/etc/fstab 文件配置教程</title>
      <link href="/2024/07/28/fstab_config/"/>
      <url>/2024/07/28/fstab_config/</url>
      
        <content type="html"><![CDATA[<h1 id="etc-fstab-文件配置教程"><a href="#etc-fstab-文件配置教程" class="headerlink" title="/etc/fstab 文件配置教程"></a><code>/etc/fstab</code> 文件配置教程</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>/etc/fstab</code> 文件用于定义系统在启动时如何自动挂载各种文件系统。这个文件在 Linux 系统中非常重要，它决定了系统启动时哪些设备将被挂载到哪些挂载点。</p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p><code>/etc/fstab</code> 文件的每一行代表一个文件系统的挂载配置，每行包含六个字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;文件系统&gt; &lt;挂载点&gt; &lt;类型&gt; &lt;选项&gt; &lt;转储&gt; &lt;自检&gt;</span><br></pre></td></tr></table></figure><h3 id="字段解释"><a href="#字段解释" class="headerlink" title="字段解释"></a>字段解释</h3><ol><li><p><strong>文件系统（File System）：</strong></p><ul><li>设备文件或分区。例如：<code>/dev/sda1</code>，<code>UUID=xxxx-xxxx</code>，<code>LABEL=home</code>。</li></ul></li><li><p><strong>挂载点（Mount Point）：</strong></p><ul><li>文件系统挂载到的目录。例如：<code>/</code>，<code>/home</code>，<code>/mnt/backup</code>。</li></ul></li><li><p><strong>文件系统类型（Filesystem Type）：</strong></p><ul><li>指定文件系统类型。例如：<code>ext4</code>，<code>ntfs</code>，<code>vfat</code>。</li></ul></li><li><p><strong>挂载选项（Mount Options）：</strong></p><ul><li>挂载时的选项，多个选项使用逗号分隔。例如：<code>defaults</code>，<code>ro</code>（只读），<code>noexec</code>（不可执行）。</li></ul></li><li><p><strong>转储频率（Dump Frequency）：</strong></p><ul><li>数字，表示是否需要备份。通常为 <code>0</code>（不备份）或 <code>1</code>（备份）。</li></ul></li><li><p><strong>自检顺序（Fsck Order）：</strong></p><ul><li>数字，表示启动时文件系统检查的顺序。根文件系统通常为 <code>1</code>，其他为 <code>2</code>，不检查则为 <code>0</code>。</li></ul></li></ol><h2 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h2><p>以下是一个典型的 <code>/etc/fstab</code> 文件示例：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># &lt;文件系统&gt;  &lt;挂载点&gt;    &lt;类型&gt; &lt;选项&gt;     &lt;转储&gt; &lt;自检&gt;</span></span><br><span class="line">/dev/sda1     /           ext4   defaults    1      1</span><br><span class="line">/dev/sda2     /home       ext4   defaults    1      2</span><br><span class="line">/dev/sdb1     /mnt/backup ntfs   defaults    0      0</span><br><span class="line">UUID=xxxx-xxxx /mnt/data  ext4   defaults    0      2</span><br><span class="line">LABEL=usbdrv  /mnt/usb    vfat   noauto,user 0      0</span><br></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li><code>/dev/sda1</code> 挂载到根目录 <code>/</code>，文件系统类型为 <code>ext4</code>，使用默认选项，转储频率为 <code>1</code>，自检顺序为 <code>1</code>。</li><li><code>/dev/sda2</code> 挂载到 <code>/home</code>，文件系统类型为 <code>ext4</code>，使用默认选项，转储频率为 <code>1</code>，自检顺序为 <code>2</code>。</li><li><code>/dev/sdb1</code> 挂载到 <code>/mnt/backup</code>，文件系统类型为 <code>ntfs</code>，使用默认选项，不进行转储和自检。</li><li>使用 <code>UUID=xxxx-xxxx</code> 指定的分区挂载到 <code>/mnt/data</code>，文件系统类型为 <code>ext4</code>，使用默认选项，不进行转储，自检顺序为 <code>2</code>。</li><li>使用 <code>LABEL=usbdrv</code> 指定的设备挂载到 <code>/mnt/usb</code>，文件系统类型为 <code>vfat</code>，不自动挂载，允许用户挂载，不进行转储和自检。</li></ul><h2 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h2><h3 id="步骤-1：备份现有的-etc-fstab"><a href="#步骤-1：备份现有的-etc-fstab" class="headerlink" title="步骤 1：备份现有的 /etc/fstab"></a>步骤 1：备份现有的 <code>/etc/fstab</code></h3><p>在修改之前，备份现有的 <code>/etc/fstab</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /etc/fstab /etc/fstab.bak</span><br></pre></td></tr></table></figure><h3 id="步骤-2：编辑-etc-fstab"><a href="#步骤-2：编辑-etc-fstab" class="headerlink" title="步骤 2：编辑 /etc/fstab"></a>步骤 2：编辑 <code>/etc/fstab</code></h3><p>使用文本编辑器打开 <code>/etc/fstab</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/fstab</span><br></pre></td></tr></table></figure><h3 id="步骤-3：添加新的挂载条目"><a href="#步骤-3：添加新的挂载条目" class="headerlink" title="步骤 3：添加新的挂载条目"></a>步骤 3：添加新的挂载条目</h3><p>根据需要添加新的挂载条目。例如：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=xxxx-xxxx /mnt/data  ext4   defaults    0      2</span><br></pre></td></tr></table></figure><h3 id="步骤-4：保存并退出"><a href="#步骤-4：保存并退出" class="headerlink" title="步骤 4：保存并退出"></a>步骤 4：保存并退出</h3><p>编辑完成后，保存文件并退出编辑器。对于 <code>nano</code> 编辑器，按 <code>Ctrl+O</code> 保存文件，然后按 <code>Ctrl+X</code> 退出。</p><h3 id="步骤-5：验证配置"><a href="#步骤-5：验证配置" class="headerlink" title="步骤 5：验证配置"></a>步骤 5：验证配置</h3><p>使用以下命令验证 <code>fstab</code> 文件的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -a</span><br></pre></td></tr></table></figure><p>如果没有错误信息，说明配置正确。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>确保每个字段之间用空格或制表符分隔。</li><li>使用 <code>UUID</code> 或 <code>LABEL</code> 可以避免设备名称变化带来的问题。</li><li>错误的 <code>fstab</code> 配置可能导致系统无法启动，修改前务必备份。</li></ul><h2 id="常见挂载选项"><a href="#常见挂载选项" class="headerlink" title="常见挂载选项"></a>常见挂载选项</h2><ul><li><code>defaults</code>：使用默认挂载选项 <code>rw, suid, dev, exec, auto, nouser, async</code>。</li><li><code>ro</code>：只读挂载。</li><li><code>rw</code>：读写挂载。</li><li><code>noauto</code>：不自动挂载。</li><li><code>user</code>：允许普通用户挂载。</li><li><code>nouser</code>：只允许 root 用户挂载。</li><li><code>noexec</code>：禁止执行二进制文件。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><code>man fstab</code>：查看 <code>fstab</code> 的手册页。</li><li><code>man mount</code>：查看 <code>mount</code> 命令的手册页。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Iperf/Iperf3 进行网络性能测试</title>
      <link href="/2024/07/21/iperf_network_test/"/>
      <url>/2024/07/21/iperf_network_test/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Iperf-Iperf3-进行网络性能测试"><a href="#使用-Iperf-Iperf3-进行网络性能测试" class="headerlink" title="使用 Iperf&#x2F;Iperf3 进行网络性能测试"></a>使用 Iperf&#x2F;Iperf3 进行网络性能测试</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>详细介绍了如何使用Iperf或Iperf3工具进行网络性能测试。Iperf是一个功能强大且灵活的网络测试工具，能够测量网络的带宽、延迟、抖动和数据包丢失等关键指标。本文将包括Iperf&#x2F;Iperf3的安装、参数介绍、实际使用案例以及测试结果的解读。</p><h2 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="2. 适用范围"></a>2. 适用范围</h2><p>适用于网络管理员、系统管理员和开发人员，他们需要对局域网(LAN)、广域网(WAN)或其他网络环境的性能进行深入评估。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>网络管理员</strong>: 负责安装和配置Iperf&#x2F;Iperf3工具，并确保测试环境的稳定性。</li><li><strong>系统管理员</strong>: 配置并监控服务器和客户端之间的网络性能测试。</li><li><strong>开发人员</strong>: 利用Iperf&#x2F;Iperf3生成的网络性能数据，优化应用程序的网络使用效率。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>安装了Iperf或Iperf3的系统（包括测试服务器和客户端）。</li><li>目标网络的完全访问权限。</li><li>具备基本的网络知识，理解TCP&#x2F;IP协议、带宽、延迟等概念。</li><li>具备适当的权限进行网络测试，以避免影响生产网络。</li></ul><h2 id="5-参数介绍与使用示例"><a href="#5-参数介绍与使用示例" class="headerlink" title="5. 参数介绍与使用示例"></a>5. 参数介绍与使用示例</h2><h3 id="5-1-常用参数详解"><a href="#5-1-常用参数详解" class="headerlink" title="5.1 常用参数详解"></a>5.1 常用参数详解</h3><ul><li><strong><code>-s</code></strong>: 启动Iperf作为服务器模式，等待客户端连接。该模式下的Iperf不会发送数据，只负责接收并报告结果。</li><li><strong><code>-c &lt;服务器IP地址&gt;</code></strong>: 启动Iperf作为客户端，连接到指定的服务器IP地址。</li><li><strong><code>-u</code></strong>: 使用UDP协议进行测试。如果未指定该选项，Iperf默认使用TCP。</li><li><strong><code>-b &lt;带宽&gt;</code></strong>: 设定UDP测试的目标带宽，例如<code>-b 100M</code>表示目标带宽为100Mbps。对于TCP，该参数会限制发送速率。</li><li><strong><code>-P &lt;并发数&gt;</code></strong>: 指定同时运行的并发流数，通常用于测试多线程或多连接的网络性能。</li><li><strong><code>-t &lt;时间&gt;</code></strong>: 指定测试持续的时间，单位为秒，默认值为10秒。</li><li><strong><code>-i &lt;间隔时间&gt;</code></strong>: 设置报告输出的间隔时间，单位为秒。例如，<code>-i 1</code>表示每秒输出一次中间结果。</li><li><strong><code>--logfile &lt;文件名&gt;</code></strong>: 将测试结果保存到指定的日志文件中，便于后续分析。</li><li><strong><code>--json</code></strong>: 以JSON格式输出测试结果，便于集成到自动化工具或分析系统中。</li></ul><h3 id="5-2-安装-Iperf-Iperf3"><a href="#5-2-安装-Iperf-Iperf3" class="headerlink" title="5.2 安装 Iperf&#x2F;Iperf3"></a>5.2 安装 Iperf&#x2F;Iperf3</h3><ol><li><p><strong>在Linux上安装Iperf&#x2F;Iperf3</strong>:</p><ul><li>Iperf和Iperf3可以通过包管理器安装：<ul><li><strong>Iperf</strong>:<ul><li><strong>Debian&#x2F;Ubuntu</strong>: <code>sudo apt-get install iperf</code></li><li><strong>CentOS&#x2F;RHEL</strong>: <code>sudo yum install iperf</code></li></ul></li><li><strong>Iperf3</strong>:<ul><li><strong>Debian&#x2F;Ubuntu</strong>: <code>sudo apt-get install iperf3</code></li><li><strong>CentOS&#x2F;RHEL</strong>: <code>sudo yum install iperf3</code></li></ul></li></ul></li></ul></li><li><p><strong>验证安装</strong>:</p><ul><li>使用以下命令验证安装是否成功：<ul><li><strong>Iperf</strong>: <code>iperf --version</code></li><li><strong>Iperf3</strong>: <code>iperf3 --version</code></li></ul></li></ul></li></ol><h3 id="5-3-基本带宽测试"><a href="#5-3-基本带宽测试" class="headerlink" title="5.3 基本带宽测试"></a>5.3 基本带宽测试</h3><ol><li><p><strong>使用Iperf测试TCP带宽</strong></p><ul><li><strong>目的</strong>: 测量两台设备之间的最大TCP带宽。</li><li><strong>步骤</strong>:<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -s</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -c &lt;服务器IP地址&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li><strong>结果分析</strong>:<ul><li>测试结果显示客户端到服务器的TCP带宽，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[  3]  0.0-10.0 sec  1.12 GBytes  961 Mbits/sec</span><br></pre></td></tr></table></figure></li><li><code>961 Mbits/sec</code> 表示在10秒内平均带宽为961 Mbps。</li></ul></li></ul></li><li><p><strong>使用Iperf3测试TCP带宽</strong></p><ul><li><strong>目的</strong>: 测量两台设备之间的最大TCP带宽，类似于Iperf，但Iperf3提供了更多的选项和更详细的报告。</li><li><strong>步骤</strong>:<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -s</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;服务器IP地址&gt;</span><br></pre></td></tr></table></figure></li></ol></li><li><strong>结果分析</strong>:<ul><li>结果会显示更多细节，包括每秒的带宽、重传等信息，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ ID] Interval           Transfer     Bandwidth       Retr</span><br><span class="line">[  5]   0.00-10.00  sec  1.11 GBytes  952 Mbits/sec  12   sender</span><br><span class="line">[  5]   0.00-10.00  sec  1.11 GBytes  952 Mbits/sec          receiver</span><br></pre></td></tr></table></figure></li><li><code>952 Mbits/sec</code> 表示TCP带宽，<code>12 Retr</code> 表示发生了12次重传。</li></ul></li></ul></li></ol><h3 id="5-4-UDP性能测试"><a href="#5-4-UDP性能测试" class="headerlink" title="5.4 UDP性能测试"></a>5.4 UDP性能测试</h3><ol><li><p><strong>使用Iperf测试UDP带宽和抖动</strong></p><ul><li><strong>目的</strong>: 测量UDP带宽、抖动和丢包率，这对于实时应用（如VoIP）尤为重要。</li><li><strong>步骤</strong>:<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -s -u</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf -c &lt;服务器IP地址&gt; -u -b 100M</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>-b 100M</code> 表示发送100Mbps的UDP流量。</li></ul></li><li><strong>结果分析</strong>:<ul><li>测试结果显示UDP带宽、抖动和丢包率，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[  3]  0.0-10.0 sec  119 MBytes  100 Mbits/sec  0.025 ms  0/8501 (0%)</span><br></pre></td></tr></table></figure></li><li><code>0.025 ms</code> 是抖动值，<code>0/8501 (0%)</code> 表示没有发生丢包。</li></ul></li></ul></li><li><p><strong>使用Iperf3测试UDP性能</strong></p><ul><li><strong>目的</strong>: 类似于Iperf的UDP测试，但Iperf3提供了更详细的报告和控制。</li><li><strong>步骤</strong>:<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -s</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;服务器IP地址&gt; -u -b 50M</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>-b 50M</code> 表示发送50Mbps的UDP流量。</li></ul></li><li><strong>结果分析</strong>:<ul><li>结果显示了更详细的统计信息，包括UDP流量的丢包率和抖动，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ ID] Interval           Transfer     Bandwidth       Total Datagrams</span><br><span class="line">[  5]   0.00-10.00  sec  59.4 MBytes  49.8 Mbits/sec  7601</span><br><span class="line">[  5] Sent 7601 datagrams</span><br><span class="line">[  5] Server Report:</span><br><span class="line">[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams</span><br><span class="line">[  5]   0.00-10.00  sec  59.4 MBytes  49.8 Mbits/sec  0.043 ms  1/7601 (0.013%)</span><br></pre></td></tr></table></figure></li><li><code>0.043 ms</code> 是抖动值，<code>1/7601 (0.013%)</code> 表示丢失了1个数据包，丢包率为0.013%。</li></ul></li></ul></li></ol><h3 id="5-5-并发测试"><a href="#5-5-并发测试" class="headerlink" title="5.5 并发测试"></a>5.5 并发测试</h3><ol><li><strong>同时测试多个并发流</strong><ul><li><strong>目的</strong>: 测试多个并发TCP或UDP流对网络性能的影响，模拟多用户或多应用程序同时使用网络的情况。</li><li><strong>步骤</strong>:<ul><li><strong>TCP并发测试</strong>：<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -s</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;服务器IP地址&gt; -P 5</span><br></pre></td></tr></table></figure></li></ol><ul><li><code>-P 5</code> 表示同时启动5个并发流。</li></ul></li><li><strong>UDP并发测试</strong>：<ol><li>在服务器端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -s</span><br></pre></td></tr></table></figure></li><li>在客户端运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;服务器IP地址&gt; -u -b 50M -P 5</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><strong>结果分析</strong>:<ul><li>每个流的带宽</li></ul></li></ul></li></ol><p>、抖动和丢包率都会被单独报告，分析总带宽和每个流的性能可以帮助理解网络在并发场景下的表现。<br>     - 例如：<br>       <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ ID] Interval           Transfer     Bandwidth       Jitter    Lost/Total Datagrams</span><br><span class="line">[SUM]   0.00-10.00  sec  298 MBytes  250 Mbits/sec  0.090 ms  0/14900 (0%)</span><br></pre></td></tr></table></figure></p><h3 id="5-6-高级测试示例"><a href="#5-6-高级测试示例" class="headerlink" title="5.6 高级测试示例"></a>5.6 高级测试示例</h3><ol><li><p><strong>跨多个子网的测试</strong></p><ul><li><strong>目的</strong>: 测试跨多个子网的网络性能，评估路由器或防火墙的性能。</li><li><strong>步骤</strong>:<ul><li>在不同子网中的服务器和客户端分别运行Iperf3或Iperf。</li><li>例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;跨子网的服务器IP地址&gt; -P 5 -t 30</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>结果分析</strong>:<ul><li>通过分析延迟、带宽和丢包率，了解网络设备在跨子网环境下的表现。</li></ul></li></ul></li><li><p><strong>长时间稳定性测试</strong></p><ul><li><strong>目的</strong>: 进行长时间的网络性能测试，检查网络连接的稳定性和长期表现。</li><li><strong>步骤</strong>:<ul><li>运行长达数小时甚至数天的Iperf3测试：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iperf3 -c &lt;服务器IP地址&gt; -t 3600</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>结果分析</strong>:<ul><li>长时间测试结果有助于识别网络中的间歇性问题，如偶发的丢包或带宽波动。</li></ul></li></ul></li></ol><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul><li><a href="https://iperf.fr/">Iperf官方文档</a></li><li><a href="https://github.com/esnet/iperf">Iperf3 GitHub仓库</a></li><li><a href="https://www.redhat.com/en/topics/virtualization/network-performance">网络性能测试指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Proxy 设置</title>
      <link href="/2024/07/21/linux_proxy_config/"/>
      <url>/2024/07/21/linux_proxy_config/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-Proxy-设置"><a href="#Linux-Proxy-设置" class="headerlink" title="Linux Proxy 设置"></a>Linux Proxy 设置</h1><hr><h2 id="Terminal-全局-http-proxy-只在当前Session生效"><a href="#Terminal-全局-http-proxy-只在当前Session生效" class="headerlink" title="Terminal 全局 http proxy (只在当前Session生效)"></a>Terminal 全局 http proxy (只在当前Session生效)</h2><h3 id="启用"><a href="#启用" class="headerlink" title="启用"></a>启用</h3>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://&lt;ip address&gt;:&lt;port&gt;&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://&lt;ip address&gt;:&lt;port&gt;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h3>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> http_proxy</span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br></pre></td></tr></table></figure><h2 id="Proxychains"><a href="#Proxychains" class="headerlink" title="Proxychains"></a>Proxychains</h2><h3 id="安装-预先手动配置Terminal-proxy"><a href="#安装-预先手动配置Terminal-proxy" class="headerlink" title="安装 (预先手动配置Terminal proxy)"></a>安装 (预先手动配置Terminal proxy)</h3><ol><li><p>Debian</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install proxychains</span><br></pre></td></tr></table></figure></li><li><p>RHEL9</p><p><strong>x86_64</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install https://dl.fedoraproject.org/pub/epel/9/Everything/aarch64/Packages/p/proxychains-ng-4.17-1.el9.x86_64.rpm</span><br></pre></td></tr></table></figure><p><strong>ARM64</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install https://dl.fedoraproject.org/pub/epel/9/Everything/aarch64/Packages/p/proxychains-ng-4.17-1.el9.aarch64.rpm</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li>编辑 &#x2F;etc&#x2F;proxychains.conf</li><li>找到quiet_mode，去掉前面的#<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Quiet mode (no output from library)</span><br><span class="line">quiet_mode</span><br></pre></td></tr></table></figure></li><li>滚动到最下，注释原有的sock4<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line"># add proxy here ...</span><br><span class="line"># meanwile</span><br><span class="line"># defaults set to &quot;tor&quot;</span><br><span class="line">#socks4         127.0.0.1 9050</span><br></pre></td></tr></table></figure></li><li>增加要使用的代理<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line">http         192.168.1.147 58080</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>在要连接网络的命令或者脚本名之前加上proxychains即可<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains apt update</span><br><span class="line">proxychains apt install ipmitool</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Red Hat Enterprise Linux 9 YUM 本地源配置</title>
      <link href="/2024/07/16/rhel9_yum_repo/"/>
      <url>/2024/07/16/rhel9_yum_repo/</url>
      
        <content type="html"><![CDATA[<h1 id="准备安装ISO和挂载"><a href="#准备安装ISO和挂载" class="headerlink" title="准备安装ISO和挂载"></a>准备安装ISO和挂载</h1><h2 id="Mount-RHEL9-iso"><a href="#Mount-RHEL9-iso" class="headerlink" title="Mount RHEL9.iso"></a>Mount RHEL9.iso</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount RHEL9.iso /mnt</span><br></pre></td></tr></table></figure><h1 id="创建repo"><a href="#创建repo" class="headerlink" title="创建repo"></a>创建repo</h1><h2 id="增加一个iso-repo到-etc-yum-repos-d-修改baseurl路径为iso-mount的文件夹"><a href="#增加一个iso-repo到-etc-yum-repos-d-修改baseurl路径为iso-mount的文件夹" class="headerlink" title="增加一个iso.repo到&#x2F;etc&#x2F;yum.repos.d, 修改baseurl路径为iso mount的文件夹."></a>增加一个iso.repo到&#x2F;etc&#x2F;yum.repos.d, 修改baseurl路径为iso mount的文件夹.</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/yum.repos.d/iso.repo</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[BaseOS]</span><br><span class="line">name=BaseOS Packages Red Hat Enterprise Linux 9</span><br><span class="line">metadata_expire=-1</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">baseurl=file:///mnt/BaseOS/</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release</span><br><span class="line"></span><br><span class="line">[AppStream]</span><br><span class="line">name=AppStream Packages Red Hat Enterprise Linux 9</span><br><span class="line">metadata_expire=-1</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">baseurl=file:///mnt/AppStream/</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release</span><br></pre></td></tr></table></figure><h1 id="YUM-更新和安装"><a href="#YUM-更新和安装" class="headerlink" title="YUM 更新和安装"></a>YUM 更新和安装</h1><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install ipmitool</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> RHEL </tag>
            
            <tag> YUM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 ARM 平台上安装、编译和运行 Mlucas 并进行 FFTs 测试</title>
      <link href="/2024/07/03/ARM_FFTs_test/"/>
      <url>/2024/07/03/ARM_FFTs_test/</url>
      
        <content type="html"><![CDATA[<h1 id="在-ARM-平台上安装、编译和运行-Mlucas-并进行-FFTs-测试"><a href="#在-ARM-平台上安装、编译和运行-Mlucas-并进行-FFTs-测试" class="headerlink" title="在 ARM 平台上安装、编译和运行 Mlucas 并进行 FFTs 测试"></a>在 ARM 平台上安装、编译和运行 Mlucas 并进行 FFTs 测试</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>Mlucas 是一个用 C 编写的开源软件，专门用于多平台架构的高性能梅森数素性测试。在 ARM 平台上，由于 prime95&#x2F;mprime 仅支持 x86 架构，Mlucas 成为理想的替代方案。详细介绍了如何在 ARM 平台上安装、编译并运行 Mlucas，包括对各类参数的深入介绍与示例，并结合硬件资源优化进行了详细的配置步骤。</p><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h2><p>适用于希望在 ARM 平台上执行 FFTs 测试并优化硬件性能的技术人员。本文主要针对运行 Debian 系统的 ARM64 设备，但同样适用于其他 Linux 发行版，步骤可能略有不同。</p><h2 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h2><ul><li><strong>系统管理员</strong>：确保 ARM 平台上所需的软件和库均已正确安装，具备系统管理权限。</li><li><strong>操作员</strong>：严格按照本 SOP 进行 Mlucas 的安装、编译、调优和运行。</li></ul><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h2><ul><li>ARM64 架构的设备，运行 Linux 操作系统（如 Debian 或 RHEL9）。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>有效的互联网连接以下载必要的软件包和源码。</li></ul><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><h3 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h3><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装必要的依赖包</strong></p><ul><li><p><strong>Debian</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential libgmp-dev libhwloc-dev git clang</span><br></pre></td></tr></table></figure></li><li><p><strong>RHEL9</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf group install <span class="string">&quot;Development Tools&quot;</span></span><br><span class="line">sudo dnf install gmp-devel hwloc-devel clang git</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-下载和准备-Mlucas"><a href="#2-下载和准备-Mlucas" class="headerlink" title="2. 下载和准备 Mlucas"></a>2. <strong>下载和准备 Mlucas</strong></h3><p>2.1 <strong>从 GitHub 克隆 Mlucas 源码</strong></p><ul><li>使用以下命令克隆 Mlucas 项目到本地目录。也可以从 <a href="https://github.com/primesearch/Mlucas/releases">Release 页面</a> 下载源码包。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/primesearch/Mlucas.git</span><br></pre></td></tr></table></figure></li></ul><p>2.2 <strong>进入 Mlucas 项目目录</strong><br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Mlucas</span><br></pre></td></tr></table></figure></p><h3 id="3-编译-Mlucas"><a href="#3-编译-Mlucas" class="headerlink" title="3. 编译 Mlucas"></a>3. <strong>编译 Mlucas</strong></h3><p>3.1 <strong>设置编译器</strong></p><ul><li>将编译器设置为 <code>clang</code> 以优化编译过程。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CC=clang</span><br></pre></td></tr></table></figure></li></ul><p>3.2 <strong>使用 makemake.sh 脚本编译 Mlucas</strong></p><ul><li>执行 <code>makemake.sh</code> 脚本，确保启用 <code>hwloc</code> 支持，以优化 CPU 绑定和内存访问性能。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash makemake.sh use_hwloc</span><br></pre></td></tr></table></figure></li></ul><p>3.3 <strong>确认编译成功</strong></p><ul><li>编译完成后，编译生成的可执行文件将位于 <code>obj</code> 目录中。使用以下命令查看生成的文件：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> obj</span><br></pre></td></tr></table></figure></li><li>生成的文件名可能会因编译选项的不同而变化，如 <code>Mlucas</code>.</li></ul><h3 id="4-性能调优：为您的机器进行优化"><a href="#4-性能调优：为您的机器进行优化" class="headerlink" title="4. 性能调优：为您的机器进行优化"></a>4. <strong>性能调优：为您的机器进行优化</strong></h3><p><strong>STEP 2 − PERFORMANCE-TUNE FOR YOUR MACHINE</strong></p><p>在 Mlucas 编译完成后，重要的是对软件进行调优，以便充分利用您的硬件资源。这一步骤涉及运行一系列测试，以确定适合您机器的最佳 FFT 长度和 CPU 绑定配置。</p><p>4.1 <strong>运行自检</strong></p><ul><li><p>自检测试将评估您的硬件性能，并生成配置文件，帮助确定适合的 FFT 长度和其他参数。运行以下命令：</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Mlucas -s</span><br></pre></td></tr></table></figure></li><li><p>该命令将测试多个 FFT 长度和 CPU 配置，以确定最佳配置。测试结果将存储在生成的日志文件中。</p></li></ul><p>4.2 <strong>分析自检结果</strong></p><ul><li><p>自检完成后，打开并分析生成的日志文件（通常是 <code>mlucas.cfg</code> 或其他输出文件），查看不同 FFT 长度下的性能表现。</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> mlucas.cfg</span><br></pre></td></tr></table></figure></li><li><p>该文件会列出每个 FFT 长度的平均迭代时间。较短的时间意味着更优的性能。选择那些具有最短迭代时间的 FFT 长度和配置。</p></li></ul><p>4.3 <strong>配置 Mlucas</strong></p><ul><li>根据自检结果，手动编辑 <code>mlucas.cfg</code> 文件，以使用最佳配置进行实际测试。例如，设置合适的 FFT 长度和 CPU 绑定。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano mlucas.cfg</span><br></pre></td></tr></table></figure></li><li>在配置文件中指定最佳 FFT 长度和 CPU 核心分配，如：   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FFTlength=2048K</span><br><span class="line">CPU=0-7</span><br></pre></td></tr></table></figure></li></ul><p>4.4 <strong>再次测试并验证</strong></p><ul><li>使用优化后的配置重新运行 Mlucas，并通过日志文件验证性能是否有所提升。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Mlucas -s m -logfile optimized_test.log</span><br></pre></td></tr></table></figure></li><li>实时查看日志文件以确认测试正在按预期的配置进行：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f optimized_test.log</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-Mlucas-参数设置与执行-FFTs-测试"><a href="#5-Mlucas-参数设置与执行-FFTs-测试" class="headerlink" title="5. Mlucas 参数设置与执行 FFTs 测试"></a>5. <strong>Mlucas 参数设置与执行 FFTs 测试</strong></h3><p>5.1 <strong>获取系统的 CPU 信息</strong></p><ul><li>在执行测试之前，获取并了解测试机器的 CPU 配置情况。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure></li><li>例如，输出结果可能为：   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CPU(s):              32</span><br><span class="line">Thread(s) per core:  1</span><br><span class="line">NUMA node0 CPU(s):   0-15</span><br><span class="line">NUMA node1 CPU(s):   16-31</span><br></pre></td></tr></table></figure></li></ul><p>5.2 <strong>Mlucas 常用参数介绍</strong></p><ul><li><code>-s</code>：指定自检或特定素性测试模式。常见值包括：<ul><li><code>-s</code>：自检模式，测试系统性能并生成配置文件。</li><li><code>-s m</code>：启动梅森数的快速测试。</li><li><code>-s q</code>：启动快速素数测试（例如 Fermat 测试）。</li></ul></li><li><code>-cpu</code>：指定使用的 CPU 核心范围。格式为 <code>-cpu start:end</code>，例如 <code>-cpu 0:15</code> 表示使用 CPU 0 到 15 号核心。</li><li><code>-fftlen</code>：设置 FFT 长度。FFT 长度决定了可处理的最大数字大小。常见值为 1024K, 2048K, 4096K 等。</li><li><code>-iters</code>：设置每个测试的迭代次数。更高的迭代次数可提供更精确的结果，但需要更多时间。</li><li><code>-logfile</code>：指定日志文件路径。默认值为 <code>mlucas.log</code>。</li></ul><p>5.3 <strong>FFT 测试的参数示例</strong></p><ul><li>自检模式：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Mlucas -s</span><br></pre></td></tr></table></figure></li><li>运行 FFTs 测试并指定 CPU 核心范围：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Mlucas -s m -cpu 0:3 -fftlen 2048K -iters 10000 -logfile fft_test.log</span><br></pre></td></tr></table></figure></li><li>对不同核心组运行 FFTs 测试：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./Mlucas -s m -cpu 0:3</span><br><span class="line">./Mlucas -s m -cpu 4:7</span><br><span class="line">./Mlucas -s m -cpu 8:11</span><br><span class="line">./Mlucas -s m -cpu 12:15</span><br><span class="line">./Mlucas -s m -cpu 16:19</span><br><span class="line">./Mlucas -s m -cpu 20:23</span><br><span class="line">./Mlucas -s m -cpu 24:27</span><br><span class="line">./Mlucas -s m -cpu 28:31</span><br></pre></td></tr></table></figure></li></ul><p>5.4 <strong>监控测试进度</strong></p><ul><li>Mlucas 运行过程中会生成日志文件，可以使用以下命令实时查看日志以监控测试进度和性能表现：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f mlucas.log</span><br></pre></td></tr></table></figure></li></ul><p>5.5 <strong>常见优化建议</strong></p><ul><li><strong>调整 FFT 长度</strong>：根据硬件配置和测试目标，选择适合的 FFT 长度。较大的 FFT 长度通常适用于处理更大的数字，但可能会增加计算时间。</li><li><strong>核心绑定</strong>：通过 <code>-cpu</code> 参数绑定特定核心组，以避免不同进程争夺相同的 CPU 资源，从而提升性能。</li></ul><h3 id="6-优化与维护"><a href="#6-优化与维护" class="headerlink" title="6. 优化与维护"></a>6. <strong>优化与维护</strong></h3><p>6.1 <strong>优化 CPU 绑定</strong></p><ul><li>根据测试需求和系统资源，调整 <code>-cpu</code> 参数中的核心范围，以进一步优化计算性能。</li></ul><p>6.2 <strong>定期更新</strong></p><ul><li>通过定期从 GitHub 仓库获取最新的源码，并重新编译，以确保使用最新版的 Mlucas 并获得最新的性能优化。</li></ul><h3 id="7-自动化测试脚本"><a href="#7-自动化测试脚本" class="headerlink" title="7. 自动化测试脚本"></a>7. <strong>自动化测试脚本</strong></h3><p>7.1 <strong>编写自动化测试脚本</strong></p><ul><li>以下是 Bash 脚本<code>run_mlucas.sh</code>的详细说明，用于自动化 Mlucas 的测试过程。该脚本支持两种 FFT 模式 (<code>small</code> 和 <code>large</code>)，根据 CPU 核心数量自动分配核心组，并并行运行多个 Mlucas 实例。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 FFT 模式和其他关键参数</span></span><br><span class="line">fft_mode=<span class="string">&quot;small&quot;</span>  <span class="comment"># 默认模式为 small，可以通过传入参数修改</span></span><br><span class="line">fft_mode=<span class="variable">$1</span>  <span class="comment"># 接收传入的 FFT 模式参数</span></span><br><span class="line">mlucas_dir=<span class="string">&quot;/Mlucas&quot;</span>  <span class="comment"># 定义 Mlucas 目录路径</span></span><br><span class="line">s_mode=<span class="string">&quot;l&quot;</span></span><br><span class="line">duration=60  <span class="comment"># 定义测试持续时间</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$mlucas_dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义配置文件和核心分配策略</span></span><br><span class="line">small_cfg_file=<span class="string">&quot;mlucas_small.cfg&quot;</span></span><br><span class="line">large_cfg_file=<span class="string">&quot;mlucas_large.cfg&quot;</span></span><br><span class="line">cores_per_group=2  <span class="comment"># 每组分配的核心数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除旧的配置文件</span></span><br><span class="line"><span class="built_in">rm</span> mlucas.cfg -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查并初始化 small FFT 配置文件</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">&quot;<span class="variable">$small_cfg_file</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Basic testing - small FFTs...&quot;</span></span><br><span class="line">    ./obj_asimd/Mlucas -s small -cpu 0:$((cores_per_group-<span class="number">1</span>)) &gt;&amp; small_test.log</span><br><span class="line">    <span class="built_in">mv</span> mlucas.cfg mlucas_small.cfg</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Initialized mlucas_small.cfg.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查并初始化 large FFT 配置文件</span></span><br><span class="line"><span class="keyword">if</span> [ ! -f <span class="string">&quot;<span class="variable">$large_cfg_file</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Basic testing - large FFTs, this will take a long time...&quot;</span></span><br><span class="line">    ./obj_asimd/Mlucas -s large -cpu 0:$((cores_per_group-<span class="number">1</span>)) &gt;&amp; large_test.log</span><br><span class="line">    <span class="built_in">mv</span> mlucas.cfg mlucas_large.cfg</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Initialized mlucas_large.cfg.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果两个配置文件都存在，提取相关信息</span></span><br><span class="line"><span class="keyword">if</span> [ -f <span class="string">&quot;<span class="variable">$small_cfg_file</span>&quot;</span> ] &amp;&amp; [ -f <span class="string">&quot;<span class="variable">$large_cfg_file</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$small_cfg_file</span> and <span class="variable">$large_cfg_file</span> are existed.&quot;</span></span><br><span class="line">    small_fft=$(<span class="built_in">tail</span> -n 1 mlucas_small.cfg | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">    small_fft_radix=$(<span class="built_in">tail</span> -n 1 mlucas_small.cfg | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $11&#125;&#x27;</span>)</span><br><span class="line">    small_fft_time=$(<span class="built_in">tail</span> -n 1 mlucas_small.cfg | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    large_fft=$(<span class="built_in">tail</span> -n 1 mlucas_large.cfg | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">    large_fft_radix=$(<span class="built_in">tail</span> -n 1 mlucas_large.cfg | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $11&#125;&#x27;</span>)</span><br><span class="line">    large_fft_time=$(<span class="built_in">tail</span> -n 1 mlucas_large.cfg | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    small_fft_iter=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$small_fft_time</span> 1000 <span class="variable">$duration</span>&quot;</span> | awk <span class="string">&#x27;&#123;printf &quot;%.0f\n&quot;, $3 / ($1 / $2)/ 2&#125;&#x27;</span>)</span><br><span class="line">    large_fft_iter=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$large_fft_time</span> 1000 <span class="variable">$duration</span>&quot;</span> | awk <span class="string">&#x27;&#123;printf &quot;%.0f\n&quot;, $3 / ($1 / $2)/ 2&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据模式设置链接和参数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$fft_mode</span>&quot;</span> = <span class="string">&quot;large&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    instance_count=1</span><br><span class="line">    <span class="built_in">ln</span> -s mlucas_large.cfg mlucas.cfg</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    instance_count=2</span><br><span class="line">    <span class="built_in">ln</span> -s mlucas_small.cfg mlucas.cfg</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据模式选择 FFT 配置</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$fft_mode</span>&quot;</span> = <span class="string">&quot;large&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    fft=<span class="variable">$large_fft</span></span><br><span class="line">    fft_radix=<span class="variable">$large_fft_radix</span></span><br><span class="line">    iter=<span class="variable">$large_fft_iter</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    fft=<span class="variable">$small_fft</span></span><br><span class="line">    fft_radix=<span class="variable">$small_fft_radix</span></span><br><span class="line">    iter=<span class="variable">$small_fft_iter</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> fft: <span class="variable">$fft</span> fft_radix: <span class="variable">$fft_radix</span> iter: <span class="variable">$iter</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建运行环境</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Creating env...&quot;</span></span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$mlucas_dir</span>/runset -rf</span><br><span class="line"><span class="built_in">rm</span> <span class="variable">$mlucas_dir</span>/jobs.sh -f</span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$mlucas_dir</span>/runset</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#!/bin/bash&quot;</span> &gt;&gt; jobs.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 CPU 核心数量</span></span><br><span class="line">cores=$(<span class="built_in">cat</span> /proc/cpuinfo | grep processor | <span class="built_in">wc</span> -l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算总共需要多少组</span></span><br><span class="line">num_groups=$((cores / cores_per_group))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环输出每组的核心范围并生成任务脚本</span></span><br><span class="line"><span class="keyword">for</span> ((i = <span class="number">0</span>; i &lt; num_groups; i++)); <span class="keyword">do</span></span><br><span class="line">    start=$((i * cores_per_group))</span><br><span class="line">    end=$((start + cores_per_group - <span class="number">1</span>))</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Group <span class="variable">$i</span>: <span class="variable">$start</span>:<span class="variable">$end</span>&quot;</span></span><br><span class="line">    <span class="built_in">mkdir</span> <span class="variable">$mlucas_dir</span>/runset/run<span class="variable">$i</span></span><br><span class="line">    <span class="keyword">for</span> ((j = <span class="number">0</span>; j &lt; instance_count; j++)); <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;cd <span class="variable">$mlucas_dir</span>/runset/run<span class="variable">$i</span> &amp;&amp; nohup ../../obj_asimd/Mlucas -fft <span class="variable">$fft</span> -iters <span class="variable">$iter</span> -maxalloc 50 -cpu <span class="variable">$start</span>:<span class="variable">$end</span> -radset 1 &gt;&gt; <span class="variable">$mlucas_dir</span>/runset/run<span class="variable">$i</span>/test<span class="variable">$j</span>.log 2&gt;&amp;1 &amp;&quot;</span> &gt;&gt; jobs.sh</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行生成的任务脚本</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Running jobs.sh...&quot;</span></span><br><span class="line">bash jobs.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;jobs.sh running in background.&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&#x27;pkill -x Mlucas&#x27; to end testing.&quot;</span></span><br></pre></td></tr></table></figure><p>7.2 <strong>脚本运行说明</strong></p><ul><li>该脚本在启动时会根据传入的参数选择 FFT 模式（small 或 large），并自动初始化相应的配置文件。</li><li>脚本自动检测系统中的 CPU 核心数量，并将核心划分为多个组，每组运行一个或多个 Mlucas 实例。</li><li>生成的任务脚本 <code>jobs.sh</code> 会在后台启动所有的 Mlucas 实例，并记录测试日志。</li></ul><p>7.3 <strong>执行脚本</strong></p><ul><li>在终端中执行脚本，传入所需的 FFT 模式（如 <code>small</code> 或 <code>large</code>）。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash run_mlucas.sh small</span><br></pre></td></tr></table></figure></li></ul><p>7.4 <strong>监控日志</strong></p><ul><li>脚本将测试日志记录在每个核心组的 <code>test.log</code> 文件中，可以通过以下命令实时监控日志：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -f /Mlucas/runset/run0/test0.<span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ul><p>7.5 <strong>停止测试</strong></p><ul><li>如果需要终止测试，可以使用以下命令终止所有正在运行的 Mlucas 实例：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -x Mlucas</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><ul><li><a href="https://www.mersenneforum.org/mayer/README.html">Mlucas README</a></li><li><a href="https://github.com/primesearch/Mlucas">Mlucas GitHub Repository</a></li><li><a href="https://www.arm.com/resources/developer/guide">ARM64 Linux Compilation Guides</a></li><li><a href="https://linuxconfig.org/bash-scripting-tutorial-for-beginners">Bash Scripting Basics</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Memtester 进行内存测试</title>
      <link href="/2024/07/03/memtester_test/"/>
      <url>/2024/07/03/memtester_test/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Memtester-进行内存测试"><a href="#使用-Memtester-进行内存测试" class="headerlink" title="使用 Memtester 进行内存测试"></a>使用 Memtester 进行内存测试</h1><hr><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>详细介绍了如何使用 Memtester 工具进行内存的稳定性和健康检查。Memtester 是一个内存测试工具，它通过对内存执行各种读写操作来检测可能存在的内存错误。它可以在操作系统运行时对内存进行测试，是诊断内存故障的有效工具。</p><h2 id="2-适用范围"><a href="#2-适用范围" class="headerlink" title="2. 适用范围"></a>2. 适用范围</h2><p>适用于系统管理员、硬件技术人员和其他需要检测和诊断内存问题的用户，尤其是在Linux和类Unix操作系统环境中。</p><h2 id="3-职责"><a href="#3-职责" class="headerlink" title="3. 职责"></a>3. 职责</h2><ul><li><strong>系统管理员</strong>: 负责安装和运行 Memtester 工具，并根据测试结果采取必要的维护或更换操作。</li><li><strong>硬件技术人员</strong>: 评估内存的物理健康状况，尤其是在发生系统崩溃或不稳定性时。</li><li><strong>开发人员</strong>: 在开发高负载应用程序时，利用 Memtester 测试内存的稳定性。</li></ul><h2 id="4-要求"><a href="#4-要求" class="headerlink" title="4. 要求"></a>4. 要求</h2><ul><li>具有 root 或 sudo 权限的系统账户。</li><li>系统内存的足够可用空间以进行测试（通常建议至少有一半以上的空闲内存）。</li><li>系统对 Memtester 工具的支持和安装（通常在大多数 Linux 发行版的包管理器中可用）。</li></ul><h2 id="5-流程和示例"><a href="#5-流程和示例" class="headerlink" title="5. 流程和示例"></a>5. 流程和示例</h2><h3 id="5-1-安装-Memtester"><a href="#5-1-安装-Memtester" class="headerlink" title="5.1 安装 Memtester"></a>5.1 安装 Memtester</h3><ol><li><strong>在Linux上安装Memtester</strong>:<ul><li>Memtester 可以通过包管理器安装：<ul><li><strong>Debian&#x2F;Ubuntu</strong>: <code>sudo apt-get install memtester</code></li><li><strong>CentOS&#x2F;RHEL</strong>: <code>sudo yum install memtester</code></li><li><strong>Fedora</strong>: <code>sudo dnf install memtester</code></li></ul></li><li>也可以通过编译source code:<ul><li>To build: download, unpack, and type <code>make</code>. That’s all.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://pyropus.ca./software/memtester/old-versions/memtester-4.6.0.tar.gz</span><br><span class="line">tar zxvf memtester-4.6.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> memtester-4.6.0</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><strong>验证安装</strong>:<ul><li>使用以下命令验证安装是否成功：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memtester --version</span><br></pre></td></tr></table></figure></li><li>如果成功安装，Memtester 会返回版本号信息。</li></ul></li></ol><h3 id="5-2-基本内存测试"><a href="#5-2-基本内存测试" class="headerlink" title="5.2 基本内存测试"></a>5.2 基本内存测试</h3><ol><li><strong>运行Memtester</strong>:<ul><li><strong>目的</strong>: 测试指定大小的内存块以检测潜在的内存错误。</li><li><strong>步骤</strong>:<ol><li>以 root 或具有 sudo 权限的用户运行 Memtester：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo memtester &lt;测试内存大小&gt; &lt;测试次数&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>例如，要测试 1 GB 的内存并运行 5 次测试循环：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo memtester 1G 5</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>结果分析</strong>:<ul><li>Memtester 会显示内存测试的详细过程，包括每次测试的结果和通过或失败的标志。</li><li>输出示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">memtester version 4.3.0 (64-bit)</span><br><span class="line">Copyright (C) 2004 Charles Cazabon.</span><br><span class="line">Licensed under the GNU General Public License version 2 (only).</span><br><span class="line"></span><br><span class="line">pagesize is 4096</span><br><span class="line">pagesizemask is 0xfffffffffffff000</span><br><span class="line">want 1024MB (1073741824 bytes)</span><br><span class="line">got  1024MB (1073741824 bytes), trying mlock ...locked.</span><br><span class="line">Loop 1/5:</span><br><span class="line">Stuck Address       : ok</span><br><span class="line">Random Value        : ok</span><br><span class="line">Compare XOR         : ok</span><br><span class="line">Compare SUB         : ok</span><br><span class="line">Compare MUL         : ok</span><br><span class="line">Compare DIV         : ok</span><br><span class="line">Compare OR          : ok</span><br><span class="line">Compare AND         : ok</span><br><span class="line">Sequential Increment: ok</span><br><span class="line">Solid Bits          : ok</span><br><span class="line">Block Sequential    : ok</span><br><span class="line">Checkerboard        : ok</span><br><span class="line">Bit Spread          : ok</span><br><span class="line">Bit Flip            : ok</span><br><span class="line">Walking Ones        : ok</span><br><span class="line">Walking Zeroes      : ok</span><br><span class="line">8-bit Writes        : ok</span><br><span class="line">16-bit Writes       : ok</span><br></pre></td></tr></table></figure></li><li><code>ok</code> 表示该测试项通过。如果有任何测试未通过，Memtester 会在输出中标记错误。</li></ul></li></ul></li></ol><h3 id="5-3-高级内存测试"><a href="#5-3-高级内存测试" class="headerlink" title="5.3 高级内存测试"></a>5.3 高级内存测试</h3><ol><li><p><strong>测试所有可用内存</strong>:</p><ul><li><strong>目的</strong>: 在不指定内存大小的情况下，测试系统中所有可用的空闲内存。</li><li><strong>步骤</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo memtester $(free -m | grep -oP <span class="string">&#x27;\\d+&#x27;</span> | <span class="built_in">head</span> -n 1)M 1</span><br></pre></td></tr></table></figure></li><li><strong>结果分析</strong>:<ul><li>该命令会自动检测并使用系统的所有可用内存进行测试。</li><li>如果在测试期间检测到错误，Memtester 会报告并建议进一步的物理检查或更换内存模块。</li></ul></li></ul></li><li><p><strong>连续运行内存测试以检测间歇性错误</strong>:</p><ul><li><strong>目的</strong>: 长时间连续运行内存测试以捕获间歇性或偶发的内存错误。</li><li><strong>步骤</strong>:<ul><li>使用较大内存块和更多的测试循环，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo memtester 2G 50</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>结果分析</strong>:<ul><li>通过连续的测试循环，Memtester 能够检测到由于热胀冷缩或电气干扰导致的间歇性错误。</li><li>如果发现任何错误，建议检查物理内存模块，并考虑在不同的插槽中进行测试。</li></ul></li></ul></li></ol><h3 id="5-4-多任务环境中的内存测试"><a href="#5-4-多任务环境中的内存测试" class="headerlink" title="5.4 多任务环境中的内存测试"></a>5.4 多任务环境中的内存测试</h3><ol><li><strong>在多任务系统中运行Memtester</strong>:<ul><li><strong>目的</strong>: 在多任务负载下测试内存的稳定性。</li><li><strong>步骤</strong>:<ul><li>在进行内存测试时，可以让系统继续运行其他任务，例如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo memtester 512M 10 &amp;</span><br><span class="line">stress --cpu 4 --<span class="built_in">timeout</span> 600</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>结果分析</strong>:<ul><li>Memtester 与其他高负载任务（如 CPU 压力测试）同时运行，可以有效检测内存模块在高压力下的可靠性。</li><li>如果 Memtester 报告错误或系统崩溃，表明可能存在内存不稳定的情况。</li></ul></li></ul></li></ol><h2 id="6-参考文献"><a href="#6-参考文献" class="headerlink" title="6. 参考文献"></a>6. 参考文献</h2><ul><li><a href="https://pyropus.ca/software/memtester/">Memtester 官方文档</a></li><li><a href="https://www.memtest86.com/troubleshooting.htm">内存测试与诊断指南</a></li><li><a href="https://www.redhat.com/en/topics/linux/hardware-diagnostics">系统硬件诊断最佳实践</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> Memtester </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stressapptest 测试</title>
      <link href="/2024/07/03/stressapptest_test/"/>
      <url>/2024/07/03/stressapptest_test/</url>
      
        <content type="html"><![CDATA[<h1 id="在-ARM-平台上使用-Stressapptest-进行压力测试"><a href="#在-ARM-平台上使用-Stressapptest-进行压力测试" class="headerlink" title="在 ARM 平台上使用 Stressapptest 进行压力测试"></a>在 ARM 平台上使用 Stressapptest 进行压力测试</h1><hr><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h4><p>Stressapptest 是一款专门用于内存和 I&#x2F;O 子系统压力测试的工具。它通过在系统上施加高负荷来发现硬件问题，特别是在内存和缓存方面的潜在故障。<br>详细介绍了在 ARM 平台上安装、配置并运行 Stressapptest 进行系统稳定性和性能测试的过程。</p><h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a><strong>范围</strong></h4><p>适用于希望在平台上验证硬件稳定性和性能的技术人员，特别是在内存和 I&#x2F;O 方面的测试。</p><h4 id="职责"><a href="#职责" class="headerlink" title="职责"></a><strong>职责</strong></h4><ul><li><strong>系统管理员</strong>：确保系统已正确安装所有必需的依赖包，并具备执行测试所需的权限。</li><li><strong>操作员</strong>：按照本 SOP 正确执行 Stressapptest，确保测试顺利进行。</li></ul><h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a><strong>要求</strong></h4><ul><li>运行 Linux 操作系统（如 Debian 或 RHEL9）。</li><li>基本的命令行操作知识。</li><li>具备 sudo 或 root 权限。</li><li>有效的互联网连接以下载必要的软件包和工具。</li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h4><h5 id="1-系统环境准备"><a href="#1-系统环境准备" class="headerlink" title="1. 系统环境准备"></a>1. <strong>系统环境准备</strong></h5><p>1.1 <strong>更新系统软件包列表</strong></p><ul><li>在进行软件安装前，先确保系统软件包是最新的。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li></ul><p>1.2 <strong>安装 Stressapptest</strong></p><ul><li><p><strong>在 Debian&#x2F;Ubuntu 系统上使用 <code>apt</code> 安装 Stressapptest：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install stressapptest</span><br></pre></td></tr></table></figure></li><li><p><strong>在 RHEL&#x2F;CentOS 系统上使用 <code>yum</code> 安装 Stressapptest：</strong></p><ul><li>首先，启用 EPEL 仓库（如果尚未启用）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure></li><li>然后安装 Stressapptest：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install stressapptest</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2-手动下载并编译-Stressapptest"><a href="#2-手动下载并编译-Stressapptest" class="headerlink" title="2. 手动下载并编译 Stressapptest"></a>2. <strong>手动下载并编译 Stressapptest</strong></h5><blockquote><p>注意：如果通过包管理器安装 Stressapptest 不可行或需要最新版，可以通过手动编译安装。</p></blockquote><p>2.1 <strong>从 GitHub 克隆 Stressapptest 源码</strong></p><ul><li>使用以下命令从 GitHub 克隆 Stressapptest 项目到本地目录。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/stressapptest/stressapptest.git</span><br></pre></td></tr></table></figure></li></ul><p>2.2 <strong>进入项目目录</strong><br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> stressapptest</span><br></pre></td></tr></table></figure></p><p>2.3 <strong>编译 Stressapptest</strong></p><ul><li>使用以下命令编译 Stressapptest。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li></ul><p>2.4 <strong>安装 Stressapptest</strong></p><ul><li>编译完成后，可以选择将其安装到系统中，便于全局使用。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-配置与运行-Stressapptest"><a href="#3-配置与运行-Stressapptest" class="headerlink" title="3. 配置与运行 Stressapptest"></a>3. <strong>配置与运行 Stressapptest</strong></h5><p>3.1 <strong>运行基本测试</strong></p><ul><li>在默认配置下运行 Stressapptest。此命令将在默认设置下运行一个 20 分钟的压力测试：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stressapptest -s 1200 -M 1024 -W</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>-s 1200</code>：指定测试时长为 1200 秒（即 20 分钟）。</li><li><code>-M 1024</code>：使用 1024 MB 内存进行测试。</li><li><code>-W</code>：使测试过程的 I&#x2F;O 操作更具挑战性。</li></ul></li></ul><p>3.2 <strong>测试所有可用内存</strong></p><ul><li>为了测试系统的所有可用内存，使用 <code>-m</code> 选项指定测试内存的百分比。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stressapptest -s 1800 -m 90</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>-m 90</code>：使用 90% 的系统内存进行测试。</li><li><code>-s 1800</code>：测试时长为 1800 秒（即 30 分钟）。</li></ul></li></ul><p>3.3 <strong>并行运行多个测试实例</strong></p><ul><li>在多核系统上，可以并行运行多个测试实例，以加大测试负荷。   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stressapptest -s 3600 -M 512 -m 80 -C 16</span><br></pre></td></tr></table></figure></li><li>解释：<ul><li><code>-C 16</code>：使用 16 个 CPU 核心进行测试。</li><li><code>-M 512</code>：每个测试实例使用 512 MB 内存。</li></ul></li></ul><h5 id="4-监控与分析测试结果"><a href="#4-监控与分析测试结果" class="headerlink" title="4. 监控与分析测试结果"></a>4. <strong>监控与分析测试结果</strong></h5><p>4.1 <strong>监控测试进度</strong></p><ul><li>在测试过程中，可以实时查看输出，了解测试进度和当前的系统状态。</li></ul><p>4.2 <strong>分析测试结果</strong></p><ul><li>测试完成后，Stressapptest 将生成一份测试报告，显示任何检测到的内存错误或 I&#x2F;O 错误。检查输出中的错误报告，以确定是否存在硬件问题。</li></ul><p>4.3 <strong>保存测试日志</strong></p><ul><li>可以将测试日志保存到文件中，以便后续分析：   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stressapptest -s 3600 -M 1024 -W &gt; stressapptest_log.txt</span><br></pre></td></tr></table></figure></li></ul><h5 id="5-优化与维护"><a href="#5-优化与维护" class="headerlink" title="5. 优化与维护"></a>5. <strong>优化与维护</strong></h5><p>5.1 <strong>定期测试</strong></p><ul><li>建议定期运行 Stressapptest，特别是在系统进行重大变更（如硬件升级或系统更新）之后，以确保系统的持续稳定性。</li></ul><p>5.2 <strong>调整参数</strong></p><ul><li>根据测试结果，调整 Stressapptest 的参数，以便更好地检测系统潜在问题。</li></ul><h5 id="6-常见问题与故障排除"><a href="#6-常见问题与故障排除" class="headerlink" title="6. 常见问题与故障排除"></a>6. <strong>常见问题与故障排除</strong></h5><p>6.1 <strong>测试失败或系统崩溃</strong></p><ul><li>如果在测试过程中系统崩溃或测试失败，请检查系统日志以确定故障原因。可能需要降低测试负荷，或排查硬件问题。</li></ul><p>6.2 <strong>内存不足</strong></p><ul><li>如果在测试过程中出现内存不足的错误，考虑减少分配给测试的内存量，或增加系统的虚拟内存。</li></ul><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h4><ul><li><a href="https://github.com/stressapptest/stressapptest">Stressapptest GitHub Repository</a></li><li><a href="https://linux.die.net/man/1/stressapptest">Linux Performance Tools</a></li><li><a href="https://linuxconfig.org/bash-scripting-tutorial-for-beginners">Bash Scripting Basics</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tool </tag>
            
            <tag> 测试 </tag>
            
            <tag> Stressapptest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 基本命令操作</title>
      <link href="/2024/07/02/linux_common_commands/"/>
      <url>/2024/07/02/linux_common_commands/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-基本命令操作"><a href="#Linux-基本命令操作" class="headerlink" title="Linux 基本命令操作"></a>Linux 基本命令操作</h1><hr><h2 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h2><ol><li><p><strong>列出目录内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file1.txt  file2.txt  directory1  directory2</span><br></pre></td></tr></table></figure></li><li><p><strong>切换到指定目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> directory1</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(无输出，仅切换目录)</span><br></pre></td></tr></table></figure></li><li><p><strong>显示当前工作目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/user/directory1</span><br></pre></td></tr></table></figure></li><li><p><strong>创建新目录</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> new_directory</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(无输出，仅创建目录)</span><br></pre></td></tr></table></figure></li><li><p><strong>删除文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> file1.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(无输出，仅删除文件)</span><br></pre></td></tr></table></figure></li></ol><h2 id="文件内容查看和编辑"><a href="#文件内容查看和编辑" class="headerlink" title="文件内容查看和编辑"></a>文件内容查看和编辑</h2><ol><li><p><strong>显示文件内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> file2.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is the content of file2.txt.</span><br></pre></td></tr></table></figure></li><li><p><strong>分页显示文件内容</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more file2.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the content of file2.txt.</span><br><span class="line">--More-- (按空格键翻页)</span><br></pre></td></tr></table></figure></li><li><p><strong>编辑文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano file2.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(进入 nano 编辑界面)</span><br></pre></td></tr></table></figure></li></ol><h2 id="文件权限和所有权"><a href="#文件权限和所有权" class="headerlink" title="文件权限和所有权"></a>文件权限和所有权</h2><ol><li><p><strong>更改文件权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 file2.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(无输出，仅更改权限)</span><br></pre></td></tr></table></figure></li><li><p><strong>更改文件所有者</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> newuser file2.txt</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(无输出，仅更改所有者)</span><br></pre></td></tr></table></figure></li></ol><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><ol><li><p><strong>显示当前运行的进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> PID TTY          TIME CMD</span><br><span class="line">1056 pts/0    00:00:00 bash</span><br><span class="line">1082 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure></li><li><p><strong>实时显示系统资源使用情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top - 10:45:14 up 2 days,  4:22,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks: 118 total,   1 running, 117 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.7 us,  0.3 sy,  0.0 ni, 99.0 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  2048576 total,   192652 free,  1298964 used,   556960 buff/cache</span><br><span class="line">KiB Swap:  1048572 total,  1048572 free,        0 used.   652632 avail Mem </span><br></pre></td></tr></table></figure></li><li><p><strong>清除journalctl系统日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --flush --rotate --vacuum-time=1s</span><br></pre></td></tr></table></figure></li><li><p><strong>显示磁盘使用情况</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1        20G  9.3G  9.1G  51% /</span><br><span class="line">tmpfs           996M  1.2M  995M   1% /run</span><br></pre></td></tr></table></figure></li><li><p><strong>关机或重启系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo shutdown -h now</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(系统会显示关机通知并在几秒钟后关机)</span><br></pre></td></tr></table></figure></li></ol><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><ol><li><p><strong>检测网络连接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping google.com</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PING google.com (172.217.164.110) 56(84) bytes of data.</span><br><span class="line">64 bytes from lga25s61-in-f14.1e100.net (172.217.164.110): icmp_seq=1 ttl=54 time=10.8 ms</span><br></pre></td></tr></table></figure></li><li><p><strong>设置 terminal proxy</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://192.168.50.1:58080&quot;</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://192.168.50.1:58080&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 proxychains proxy</strong></p><p>A. 安装 proxychains</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install proxychains</span><br></pre></td></tr></table></figure><p>B. 修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/proxychains.conf</span><br><span class="line"><span class="comment"># Quiet mode (no output from library)</span></span><br><span class="line">quiet_mode</span><br><span class="line"></span><br><span class="line">[ProxyList]</span><br><span class="line"><span class="comment"># add proxy here ...</span></span><br><span class="line"><span class="comment"># meanwile</span></span><br><span class="line"><span class="comment"># defaults set to &quot;tor&quot;</span></span><br><span class="line"><span class="comment">#socks4         127.0.0.1 9050</span></span><br><span class="line">http    192.168.50.1    58080</span><br></pre></td></tr></table></figure><p>C. 使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains apt update</span><br></pre></td></tr></table></figure></li></ol><h2 id="软件安装相关"><a href="#软件安装相关" class="headerlink" title="软件安装相关"></a>软件安装相关</h2><ol><li><p><strong>apt 安装软件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install stress</span><br></pre></td></tr></table></figure></li><li><p><strong>apt 卸载软件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt remove stress</span><br></pre></td></tr></table></figure></li><li><p><strong>apt 搜索软件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search stress</span><br></pre></td></tr></table></figure></li><li><p><strong>dpkg 查看已安装软件信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l</span><br></pre></td></tr></table></figure></li><li><p><strong>编译安装</strong></p><p>A. 安装编译组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -y build-essential</span><br></pre></td></tr></table></figure><p>B. 下载并解压 source code</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://jaist.dl.sourceforge.net/project/smartmontools/smartmontools/7.4/smartmontools-7.4.tar.gz</span><br><span class="line">tar xvf smartmontools-7.4.tar.gz</span><br></pre></td></tr></table></figure><p>C. 编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> smartmontools-7.4/</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>D. 检查是否成功编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smartctl -v</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机迁移指南</title>
      <link href="/2024/06/30/VM_Migration_Guide_Full/"/>
      <url>/2024/06/30/VM_Migration_Guide_Full/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机迁移指南"><a href="#虚拟机迁移指南" class="headerlink" title="虚拟机迁移指南"></a>虚拟机迁移指南</h1><hr><h2 id="1-确保虚拟机是持久化的"><a href="#1-确保虚拟机是持久化的" class="headerlink" title="1. 确保虚拟机是持久化的"></a>1. 确保虚拟机是持久化的</h2><p>虚拟机必须是持久化的才能进行迁移。如果虚拟机是临时的（transient），需要先将其配置为持久化。</p><h3 id="将临时虚拟机转换为持久化虚拟机"><a href="#将临时虚拟机转换为持久化虚拟机" class="headerlink" title="将临时虚拟机转换为持久化虚拟机"></a>将临时虚拟机转换为持久化虚拟机</h3><p>如果虚拟机是临时的，可以使用以下命令将其转换为持久化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh dumpxml mgtest &gt; /tmp/mgtest.xml</span><br><span class="line">sudo virsh define /tmp/mgtest.xml</span><br></pre></td></tr></table></figure><h2 id="2-在线迁移虚拟机"><a href="#2-在线迁移虚拟机" class="headerlink" title="2. 在线迁移虚拟机"></a>2. 在线迁移虚拟机</h2><h3 id="确保虚拟机磁盘缓存设置为-none-或-directsync"><a href="#确保虚拟机磁盘缓存设置为-none-或-directsync" class="headerlink" title="确保虚拟机磁盘缓存设置为 none 或 directsync"></a>确保虚拟机磁盘缓存设置为 none 或 directsync</h3><p>编辑虚拟机的 XML 配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh edit mgtest</span><br></pre></td></tr></table></figure><p>在 <code>&lt;disk&gt;</code> 部分中添加或修改 <code>&lt;driver&gt;</code> 部分，将 <code>cache</code> 设置为 <code>none</code> 或 <code>directsync</code>，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span> <span class="attr">device</span>=<span class="string">&#x27;disk&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&#x27;qemu&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;qcow2&#x27;</span> <span class="attr">cache</span>=<span class="string">&#x27;none&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&#x27;/mnt/nfs_share/mgtest.qcow2&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;vda&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;virtio&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x04&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br></pre></td></tr></table></figure><p>保存并退出编辑器。</p><h3 id="重启虚拟机"><a href="#重启虚拟机" class="headerlink" title="重启虚拟机"></a>重启虚拟机</h3><p>为了使配置生效，需要重启虚拟机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh shutdown mgtest</span><br><span class="line">sudo virsh start mgtest</span><br></pre></td></tr></table></figure><h3 id="进行在线迁移"><a href="#进行在线迁移" class="headerlink" title="进行在线迁移"></a>进行在线迁移</h3><p>使用以下命令进行在线迁移：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh migrate --live mgtest qemu+ssh://192.168.50.235/system</span><br></pre></td></tr></table></figure><h2 id="3-离线迁移虚拟机"><a href="#3-离线迁移虚拟机" class="headerlink" title="3. 离线迁移虚拟机"></a>3. 离线迁移虚拟机</h2><h3 id="确保虚拟机是持久化的"><a href="#确保虚拟机是持久化的" class="headerlink" title="确保虚拟机是持久化的"></a>确保虚拟机是持久化的</h3><p>如果虚拟机是临时的，可以使用以下命令将其转换为持久化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh dumpxml mgtest &gt; /tmp/mgtest.xml</span><br><span class="line">sudo virsh define /tmp/mgtest.xml</span><br></pre></td></tr></table></figure><h3 id="关闭虚拟机"><a href="#关闭虚拟机" class="headerlink" title="关闭虚拟机"></a>关闭虚拟机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh shutdown mgtest</span><br></pre></td></tr></table></figure><h3 id="进行离线迁移"><a href="#进行离线迁移" class="headerlink" title="进行离线迁移"></a>进行离线迁移</h3><p>执行离线迁移命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh migrate --offline --persistent mgtest qemu+ssh://192.168.50.235/system</span><br></pre></td></tr></table></figure><h2 id="4-示例流程"><a href="#4-示例流程" class="headerlink" title="4. 示例流程"></a>4. 示例流程</h2><h3 id="检查虚拟机状态"><a href="#检查虚拟机状态" class="headerlink" title="检查虚拟机状态"></a>检查虚拟机状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh list --all</span><br></pre></td></tr></table></figure><h3 id="将临时虚拟机转换为持久化（如果需要）"><a href="#将临时虚拟机转换为持久化（如果需要）" class="headerlink" title="将临时虚拟机转换为持久化（如果需要）"></a>将临时虚拟机转换为持久化（如果需要）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh dumpxml mgtest &gt; /tmp/mgtest.xml</span><br><span class="line">sudo virsh define /tmp/mgtest.xml</span><br></pre></td></tr></table></figure><h3 id="关闭虚拟机-1"><a href="#关闭虚拟机-1" class="headerlink" title="关闭虚拟机"></a>关闭虚拟机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh shutdown mgtest</span><br></pre></td></tr></table></figure><h3 id="进行在线迁移-1"><a href="#进行在线迁移-1" class="headerlink" title="进行在线迁移"></a>进行在线迁移</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh migrate --live mgtest qemu+ssh://192.168.50.235/system</span><br></pre></td></tr></table></figure><h3 id="进行离线迁移-1"><a href="#进行离线迁移-1" class="headerlink" title="进行离线迁移"></a>进行离线迁移</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo virsh migrate --offline --persistent mgtest qemu+ssh://192.168.50.235/system</span><br></pre></td></tr></table></figure><h2 id="5-NFS-配置步骤"><a href="#5-NFS-配置步骤" class="headerlink" title="5. NFS 配置步骤"></a>5. NFS 配置步骤</h2><h3 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h3><ol><li><p><strong>安装NFS服务器：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure></li><li><p><strong>创建共享目录：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /srv/nfs_share</span><br><span class="line">sudo <span class="built_in">chown</span> nobody:nogroup /srv/nfs_share</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 /srv/nfs_share</span><br></pre></td></tr></table></figure></li><li><p><strong>配置NFS导出：</strong></p><p>编辑 <code>/etc/exports</code> 文件，添加共享目录的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/exports</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/srv/nfs_share 192.168.50.0/24(rw,sync,no_subtree_check,no_root_squash)</span><br></pre></td></tr></table></figure></li><li><p><strong>导出NFS共享目录：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo exportfs -ra</span><br></pre></td></tr></table></figure></li><li><p><strong>启动并启用NFS服务：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nfs-kernel-server</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> nfs-kernel-server</span><br></pre></td></tr></table></figure></li></ol><h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3><ol><li><p><strong>安装NFS客户端：</strong></p><p>在两个主机上分别安装NFS客户端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nfs-common</span><br></pre></td></tr></table></figure></li><li><p><strong>创建挂载点目录：</strong></p><p>在两个主机上分别创建挂载点目录，例如 <code>/mnt/nfs_share</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /mnt/nfs_share</span><br></pre></td></tr></table></figure></li><li><p><strong>挂载NFS共享目录：</strong></p><p>在两个主机上分别执行以下命令，将NFS共享目录挂载到本地目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t nfs -o rw 192.168.50.100:/srv/nfs_share /mnt/nfs_share</span><br></pre></td></tr></table></figure></li><li><p><strong>配置自动挂载（可选）：</strong></p><p>为了在系统重启后自动挂载NFS共享目录，可以编辑 <code>/etc/fstab</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/fstab</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.50.100:/srv/nfs_share /mnt/nfs_share nfs defaults 0 0</span><br></pre></td></tr></table></figure></li></ol><h3 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h3><ol><li><p><strong>验证挂载：</strong></p><p>在两个主机上分别执行以下命令，确认NFS共享目录是否成功挂载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure></li><li><p><strong>测试读写权限：</strong></p><p>在两个主机上分别尝试在挂载的共享目录中创建文件，确保读写权限正常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">touch</span> /mnt/nfs_share/testfile</span><br><span class="line"><span class="built_in">ls</span> -l /mnt/nfs_share/testfile</span><br></pre></td></tr></table></figure></li></ol><p>通过以上步骤，可以配置和验证NFS共享目录，以便在虚拟机迁移过程中使用。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>禁用 Debian 系统的屏幕锁定和自动睡眠</title>
      <link href="/2024/06/30/disable_screen_lock_and_sleep/"/>
      <url>/2024/06/30/disable_screen_lock_and_sleep/</url>
      
        <content type="html"><![CDATA[<h1 id="禁用-Debian-系统的屏幕锁定和自动睡眠"><a href="#禁用-Debian-系统的屏幕锁定和自动睡眠" class="headerlink" title="禁用 Debian 系统的屏幕锁定和自动睡眠"></a>禁用 Debian 系统的屏幕锁定和自动睡眠</h1><p>本文档提供了禁用 Debian 系统屏幕锁定和自动睡眠功能的详细步骤。</p><h2 id="1-禁用屏幕锁定"><a href="#1-禁用屏幕锁定" class="headerlink" title="1. 禁用屏幕锁定"></a>1. 禁用屏幕锁定</h2><p>首先，确保屏幕锁定被禁用。你可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.screensaver lock-enabled <span class="literal">false</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.screensaver idle-activation-enabled <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="2-禁用系统睡眠"><a href="#2-禁用系统睡眠" class="headerlink" title="2. 禁用系统睡眠"></a>2. 禁用系统睡眠</h2><p>要禁用系统的自动睡眠功能，可以通过 <code>systemd</code> 的配置文件来实现。编辑 <code>/etc/systemd/logind.conf</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/logind.conf</span><br></pre></td></tr></table></figure><p>找到并修改以下行：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#HandleLidSwitch=suspend</span></span><br><span class="line"><span class="attr">HandleLidSwitch</span>=ignore</span><br><span class="line"><span class="comment">#HandleLidSwitchDocked=ignore</span></span><br><span class="line"><span class="attr">HandleLidSwitchDocked</span>=ignore</span><br><span class="line"><span class="comment">#HandleSuspendKey=suspend</span></span><br><span class="line"><span class="attr">HandleSuspendKey</span>=ignore</span><br><span class="line"><span class="comment">#HandleHibernateKey=hibernate</span></span><br><span class="line"><span class="attr">HandleHibernateKey</span>=ignore</span><br><span class="line"><span class="comment">#HandleLidSwitchExternalPower=suspend</span></span><br><span class="line"><span class="attr">HandleLidSwitchExternalPower</span>=ignore</span><br><span class="line"><span class="comment">#HandleLidSwitchDockedExternalPower=ignore</span></span><br><span class="line"><span class="attr">HandleLidSwitchDockedExternalPower</span>=ignore</span><br></pre></td></tr></table></figure><p>保存文件并重启 <code>systemd-logind</code> 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart systemd-logind</span><br></pre></td></tr></table></figure><h2 id="3-禁用-GNOME-电源设置中的自动睡眠"><a href="#3-禁用-GNOME-电源设置中的自动睡眠" class="headerlink" title="3. 禁用 GNOME 电源设置中的自动睡眠"></a>3. 禁用 GNOME 电源设置中的自动睡眠</h2><p>打开终端，使用以下命令禁用 GNOME 电源设置中的自动睡眠：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.power sleep-inactive-ac-timeout 0</span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.power sleep-inactive-battery-timeout 0</span><br></pre></td></tr></table></figure><h2 id="4-确认配置"><a href="#4-确认配置" class="headerlink" title="4. 确认配置"></a>4. 确认配置</h2><p>再次检查这些配置是否已经生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gsettings get org.gnome.desktop.screensaver lock-enabled</span><br><span class="line">gsettings get org.gnome.desktop.screensaver idle-activation-enabled</span><br><span class="line">gsettings get org.gnome.settings-daemon.plugins.power sleep-inactive-ac-timeout</span><br><span class="line">gsettings get org.gnome.settings-daemon.plugins.power sleep-inactive-battery-timeout</span><br></pre></td></tr></table></figure><h2 id="5-检查日志信息"><a href="#5-检查日志信息" class="headerlink" title="5. 检查日志信息"></a>5. 检查日志信息</h2><p>如果问题依旧存在，请检查系统日志以获取更多信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -xe</span><br></pre></td></tr></table></figure><p>通过以上步骤，你应该能够成功禁用 Debian 系统中的屏幕锁定和自动睡眠功能。如果需要更多帮助，请提供更详细的信息以便进一步排查。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World!</title>
      <link href="/2024/06/30/hello-world/"/>
      <url>/2024/06/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> template </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POST TEMPLATE</title>
      <link href="/2024/06/30/post_template/"/>
      <url>/2024/06/30/post_template/</url>
      
        <content type="html"><![CDATA[<p>写法解释<br>title【必需】文章标题<br>date【必需】文章创建日期<br>updated【可选】文章更新日期<br>tags【可选】文章标签<br>categories【可选】文章分类<br>keywords【可选】文章关键字<br>description【可选】文章描述<br>top_img【可选】文章顶部图片<br>cover【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false&#x2F;图片地址&#x2F;留空)<br>comments【可选】显示文章评论模块(默认 true)<br>toc【可选】显示文章TOC(默认为设置中toc的enable配置)<br>toc_number【可选】显示toc_number(默认为设置中toc的number配置)<br>toc_style_simple【可选】显示 toc 简洁模式<br>copyright【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)<br>copyright_author【可选】文章版权模块的文章作者<br>copyright_author_href【可选】文章版权模块的文章作者链接<br>copyright_url【可选】文章版权模块的文章连结链接<br>copyright_info【可选】文章版权模块的版权声明文字<br>mathjax【可选】显示mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false )<br>katex【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false )<br>aplayer【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置<br>highlight_shrink【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中 highlight_shrink 的配置)<br>aside【可选】显示侧边栏 (默认 true)<br>abcjs【可选】加载 abcjs (当设置 abcjs 的 per_page: false 时，才需要配置，默认 false )</p><p>作者: Jerry<br>連結: <a href="https://butterfly.js.org/posts/dc584b87/#Post-Front-matter">https://butterfly.js.org/posts/dc584b87/#Post-Front-matter</a><br>來源: Butterfly<br>著作權歸作者所有。商業轉載請聯繫作者獲得授權，非商業轉載請註明出處。</p>]]></content>
      
      
      
        <tags>
            
            <tag> template </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Template</title>
      <link href="/2024/06/28/README/"/>
      <url>/2024/06/28/README/</url>
      
        <content type="html"><![CDATA[<img src="https://raw.githubusercontent.com/hexojs/logo/master/hexo-logo-avatar.png" alt="Hexo logo" width="100" height="100" align="right" /><h1 id="Hexo-Template"><a href="#Hexo-Template" class="headerlink" title="Hexo Template"></a>Hexo Template</h1><blockquote><p>A fast, simple &amp; powerful blog framework, powered by <a href="https://nodejs.org/">Node.js</a>. Here is the template of it.</p></blockquote><p><a href="https://mmdjiji.github.io/hexo-template">Demo</a> |<br><a href="https://hexo.io/">Official Website</a> |<br><a href="https://hexo.io/docs/">Documentation</a> |<br><a href="https://github.com/mmdjiji/hexo-template">GitHub</a></p><h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><p>There are two lines to modify in <code>_config.yml</code>:</p><ol><li><p>Set your site url at <strong>line 16</strong>. For example, if you use GitHub Page, set url as <code>https://username.github.io/project</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://jiji.pro/hexo-template</span></span><br></pre></td></tr></table></figure></li><li><p>Set your project name at <strong>line 107</strong>, if your project name is <code>username</code> or <code>username.github.io</code>, just remove it at the end of <code>_config.yml</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">root:</span> <span class="string">/hexo-template</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h2><p>This repository uses GitHub Actions for CI&#x2F;CD. You don’t need to build your documents manually. Just commit your documents (then run <code>git push</code>), and then turn on the GitHub Pages in the settings to access your online documents. (For this demo is <a href="https://mmdjiji.github.io/hexo-template">https://mmdjiji.github.io/hexo-template</a>)</p><h2 id="Hexo-Features"><a href="#Hexo-Features" class="headerlink" title="Hexo Features"></a>Hexo Features</h2><ul><li>Blazing fast generating</li><li>Support for GitHub Flavored Markdown and most Octopress plugins</li><li>One-command deploy to GitHub Pages, Heroku, etc.</li><li>Powerful API for limitless extensibility</li><li>Hundreds of <a href="https://hexo.io/themes/">themes</a> &amp; <a href="https://hexo.io/plugins/">plugins</a></li></ul><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><p><strong>Install Hexo</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>Install with <a href="https://brew.sh/">brew</a> on macOS and Linux:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install hexo</span><br></pre></td></tr></table></figure><p><strong>Setup your blog</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br></pre></td></tr></table></figure><p><strong>Start the server</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p><strong>Create a new post</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;Hello Hexo&quot;</span></span><br></pre></td></tr></table></figure><p><strong>Generate static files</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h2 id="More-Information"><a href="#More-Information" class="headerlink" title="More Information"></a>More Information</h2><ul><li>Read the <a href="https://hexo.io/">documentation</a></li><li>Visit the <a href="https://github.com/hexojs/awesome-hexo">Awesome Hexo</a> list</li><li>Find solutions in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a></li><li>Join discussion on <a href="https://groups.google.com/group/hexo">Google Group</a>, <a href="https://discord.gg/teM2Anj">Discord</a>, <a href="https://gitter.im/hexojs/hexo">Gitter</a> or <a href="https://t.me/hexojs">Telegram</a></li><li>See the <a href="https://hexo.io/plugins/">plugin list</a> and the <a href="https://hexo.io/themes/">theme list</a> on wiki</li><li>Follow <a href="https://twitter.com/hexojs">@hexojs</a> for latest news</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Follows <a href="https://github.com/hexojs/hexo">hexojs&#x2F;hexo</a> , use <a href="LICENSE">MIT License</a>.</p><p><a href="https://app.fossa.com/projects/git%2Bgithub.com%2Fhexojs%2Fhexo?ref=badge_large"><img src="https://app.fossa.com/api/projects/git%2Bgithub.com%2Fhexojs%2Fhexo.svg?type=large" alt="FOSSA Status"></a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Template </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
